{"version":3,"file":"593.CadEngine.js","mappings":"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","sources":["webpack://CadEngine/webpack/runtime/chunk loaded","webpack://CadEngine/webpack/runtime/startup chunk dependencies","webpack://CadEngine/./src/vendor/protobuf/packet2d.ts","webpack://CadEngine/./src/utils/StringUtils.ts","webpack://CadEngine/./src/core/DBEntity.ts","webpack://CadEngine/./src/core/DbLine.ts","webpack://CadEngine/./src/core/DbMesh.ts","webpack://CadEngine/./src/core/DbLayer.ts","webpack://CadEngine/./src/core/DbBlockRecord.ts","webpack://CadEngine/./src/core/DbBlockInstance.ts","webpack://CadEngine/./src/worker/P2dLoader.worker.ts","webpack://CadEngine/webpack/bootstrap","webpack://CadEngine/webpack/runtime/define property getters","webpack://CadEngine/webpack/runtime/ensure chunk","webpack://CadEngine/webpack/runtime/get javascript chunk filename","webpack://CadEngine/webpack/runtime/global","webpack://CadEngine/webpack/runtime/hasOwnProperty shorthand","webpack://CadEngine/webpack/runtime/publicPath","webpack://CadEngine/webpack/runtime/importScripts chunk loading","webpack://CadEngine/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(306).then(next);\n};","export interface Packet2d {\r\n  index?: number;\r\n  count?: number;\r\n  layers?: Layer[];\r\n  blocks?: BlockReference[];\r\n  block_table?: Block[];\r\n  lines?: Line[];\r\n  meshs?: Mesh[];\r\n  line_types?: LineType[];\r\n}\r\n\r\nexport function encodePacket2d(message: Packet2d): Uint8Array {\r\n  let bb = popByteBuffer();\r\n  _encodePacket2d(message, bb);\r\n  return toUint8Array(bb);\r\n}\r\n\r\nfunction _encodePacket2d(message: Packet2d, bb: ByteBuffer): void {\r\n  // optional uint32 index = 1;\r\n  let $index = message.index;\r\n  if ($index !== undefined) {\r\n    writeVarint32(bb, 8);\r\n    writeVarint32(bb, $index);\r\n  }\r\n\r\n  // optional uint32 count = 2;\r\n  let $count = message.count;\r\n  if ($count !== undefined) {\r\n    writeVarint32(bb, 16);\r\n    writeVarint32(bb, $count);\r\n  }\r\n\r\n  // repeated Layer layers = 3;\r\n  let array$layers = message.layers;\r\n  if (array$layers !== undefined) {\r\n    for (let value of array$layers) {\r\n      writeVarint32(bb, 26);\r\n      let nested = popByteBuffer();\r\n      _encodeLayer(value, nested);\r\n      writeVarint32(bb, nested.limit);\r\n      writeByteBuffer(bb, nested);\r\n      pushByteBuffer(nested);\r\n    }\r\n  }\r\n\r\n  // repeated BlockReference blocks = 4;\r\n  let array$blocks = message.blocks;\r\n  if (array$blocks !== undefined) {\r\n    for (let value of array$blocks) {\r\n      writeVarint32(bb, 34);\r\n      let nested = popByteBuffer();\r\n      _encodeBlockReference(value, nested);\r\n      writeVarint32(bb, nested.limit);\r\n      writeByteBuffer(bb, nested);\r\n      pushByteBuffer(nested);\r\n    }\r\n  }\r\n\r\n  // repeated Block block_table = 5;\r\n  let array$block_table = message.block_table;\r\n  if (array$block_table !== undefined) {\r\n    for (let value of array$block_table) {\r\n      writeVarint32(bb, 42);\r\n      let nested = popByteBuffer();\r\n      _encodeBlock(value, nested);\r\n      writeVarint32(bb, nested.limit);\r\n      writeByteBuffer(bb, nested);\r\n      pushByteBuffer(nested);\r\n    }\r\n  }\r\n\r\n  // repeated Line lines = 6;\r\n  let array$lines = message.lines;\r\n  if (array$lines !== undefined) {\r\n    for (let value of array$lines) {\r\n      writeVarint32(bb, 50);\r\n      let nested = popByteBuffer();\r\n      _encodeLine(value, nested);\r\n      writeVarint32(bb, nested.limit);\r\n      writeByteBuffer(bb, nested);\r\n      pushByteBuffer(nested);\r\n    }\r\n  }\r\n\r\n  // repeated Mesh meshs = 7;\r\n  let array$meshs = message.meshs;\r\n  if (array$meshs !== undefined) {\r\n    for (let value of array$meshs) {\r\n      writeVarint32(bb, 58);\r\n      let nested = popByteBuffer();\r\n      _encodeMesh(value, nested);\r\n      writeVarint32(bb, nested.limit);\r\n      writeByteBuffer(bb, nested);\r\n      pushByteBuffer(nested);\r\n    }\r\n  }\r\n\r\n  // repeated LineType line_types = 8;\r\n  let array$line_types = message.line_types;\r\n  if (array$line_types !== undefined) {\r\n    for (let value of array$line_types) {\r\n      writeVarint32(bb, 66);\r\n      let nested = popByteBuffer();\r\n      _encodeLineType(value, nested);\r\n      writeVarint32(bb, nested.limit);\r\n      writeByteBuffer(bb, nested);\r\n      pushByteBuffer(nested);\r\n    }\r\n  }\r\n}\r\n\r\nexport function decodePacket2d(binary: Uint8Array): Packet2d {\r\n  return _decodePacket2d(wrapByteBuffer(binary));\r\n}\r\n\r\nfunction _decodePacket2d(bb: ByteBuffer): Packet2d {\r\n  let message: Packet2d = {} as any;\r\n\r\n  end_of_message: while (!isAtEnd(bb)) {\r\n    let tag = readVarint32(bb);\r\n\r\n    switch (tag >>> 3) {\r\n      case 0:\r\n        break end_of_message;\r\n\r\n      // optional uint32 index = 1;\r\n      case 1: {\r\n        message.index = readVarint32(bb) >>> 0;\r\n        break;\r\n      }\r\n\r\n      // optional uint32 count = 2;\r\n      case 2: {\r\n        message.count = readVarint32(bb) >>> 0;\r\n        break;\r\n      }\r\n\r\n      // repeated Layer layers = 3;\r\n      case 3: {\r\n        let limit = pushTemporaryLength(bb);\r\n        let values = message.layers || (message.layers = []);\r\n        values.push(_decodeLayer(bb));\r\n        bb.limit = limit;\r\n        break;\r\n      }\r\n\r\n      // repeated BlockReference blocks = 4;\r\n      case 4: {\r\n        let limit = pushTemporaryLength(bb);\r\n        let values = message.blocks || (message.blocks = []);\r\n        values.push(_decodeBlockReference(bb));\r\n        bb.limit = limit;\r\n        break;\r\n      }\r\n\r\n      // repeated Block block_table = 5;\r\n      case 5: {\r\n        let limit = pushTemporaryLength(bb);\r\n        let values = message.block_table || (message.block_table = []);\r\n        values.push(_decodeBlock(bb));\r\n        bb.limit = limit;\r\n        break;\r\n      }\r\n\r\n      // repeated Line lines = 6;\r\n      case 6: {\r\n        let limit = pushTemporaryLength(bb);\r\n        let values = message.lines || (message.lines = []);\r\n        values.push(_decodeLine(bb));\r\n        bb.limit = limit;\r\n        break;\r\n      }\r\n\r\n      // repeated Mesh meshs = 7;\r\n      case 7: {\r\n        let limit = pushTemporaryLength(bb);\r\n        let values = message.meshs || (message.meshs = []);\r\n        values.push(_decodeMesh(bb));\r\n        bb.limit = limit;\r\n        break;\r\n      }\r\n\r\n      // repeated LineType line_types = 8;\r\n      case 8: {\r\n        let limit = pushTemporaryLength(bb);\r\n        let values = message.line_types || (message.line_types = []);\r\n        values.push(_decodeLineType(bb));\r\n        bb.limit = limit;\r\n        break;\r\n      }\r\n\r\n      default:\r\n        skipUnknownField(bb, tag & 7);\r\n    }\r\n  }\r\n\r\n  return message;\r\n}\r\n\r\nexport interface Block {\r\n  id?: string;\r\n  name?: Uint8Array;\r\n  lines?: Line[];\r\n  meshs?: Mesh[];\r\n  blocks?: BlockReference[];\r\n  point_count?: Long;\r\n}\r\n\r\nexport function encodeBlock(message: Block): Uint8Array {\r\n  let bb = popByteBuffer();\r\n  _encodeBlock(message, bb);\r\n  return toUint8Array(bb);\r\n}\r\n\r\nfunction _encodeBlock(message: Block, bb: ByteBuffer): void {\r\n  // optional string id = 1;\r\n  let $id = message.id;\r\n  if ($id !== undefined) {\r\n    writeVarint32(bb, 10);\r\n    writeString(bb, $id);\r\n  }\r\n\r\n  // optional bytes name = 2;\r\n  let $name = message.name;\r\n  if ($name !== undefined) {\r\n    writeVarint32(bb, 18);\r\n    writeVarint32(bb, $name.length), writeBytes(bb, $name);\r\n  }\r\n\r\n  // repeated Line lines = 3;\r\n  let array$lines = message.lines;\r\n  if (array$lines !== undefined) {\r\n    for (let value of array$lines) {\r\n      writeVarint32(bb, 26);\r\n      let nested = popByteBuffer();\r\n      _encodeLine(value, nested);\r\n      writeVarint32(bb, nested.limit);\r\n      writeByteBuffer(bb, nested);\r\n      pushByteBuffer(nested);\r\n    }\r\n  }\r\n\r\n  // repeated Mesh meshs = 4;\r\n  let array$meshs = message.meshs;\r\n  if (array$meshs !== undefined) {\r\n    for (let value of array$meshs) {\r\n      writeVarint32(bb, 34);\r\n      let nested = popByteBuffer();\r\n      _encodeMesh(value, nested);\r\n      writeVarint32(bb, nested.limit);\r\n      writeByteBuffer(bb, nested);\r\n      pushByteBuffer(nested);\r\n    }\r\n  }\r\n\r\n  // repeated BlockReference blocks = 5;\r\n  let array$blocks = message.blocks;\r\n  if (array$blocks !== undefined) {\r\n    for (let value of array$blocks) {\r\n      writeVarint32(bb, 42);\r\n      let nested = popByteBuffer();\r\n      _encodeBlockReference(value, nested);\r\n      writeVarint32(bb, nested.limit);\r\n      writeByteBuffer(bb, nested);\r\n      pushByteBuffer(nested);\r\n    }\r\n  }\r\n\r\n  // optional uint64 point_count = 6;\r\n  let $point_count = message.point_count;\r\n  if ($point_count !== undefined) {\r\n    writeVarint32(bb, 48);\r\n    writeVarint64(bb, $point_count);\r\n  }\r\n}\r\n\r\nexport function decodeBlock(binary: Uint8Array): Block {\r\n  return _decodeBlock(wrapByteBuffer(binary));\r\n}\r\n\r\nfunction _decodeBlock(bb: ByteBuffer): Block {\r\n  let message: Block = {} as any;\r\n\r\n  end_of_message: while (!isAtEnd(bb)) {\r\n    let tag = readVarint32(bb);\r\n\r\n    switch (tag >>> 3) {\r\n      case 0:\r\n        break end_of_message;\r\n\r\n      // optional string id = 1;\r\n      case 1: {\r\n        message.id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional bytes name = 2;\r\n      case 2: {\r\n        message.name = readBytes(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // repeated Line lines = 3;\r\n      case 3: {\r\n        let limit = pushTemporaryLength(bb);\r\n        let values = message.lines || (message.lines = []);\r\n        values.push(_decodeLine(bb));\r\n        bb.limit = limit;\r\n        break;\r\n      }\r\n\r\n      // repeated Mesh meshs = 4;\r\n      case 4: {\r\n        let limit = pushTemporaryLength(bb);\r\n        let values = message.meshs || (message.meshs = []);\r\n        values.push(_decodeMesh(bb));\r\n        bb.limit = limit;\r\n        break;\r\n      }\r\n\r\n      // repeated BlockReference blocks = 5;\r\n      case 5: {\r\n        let limit = pushTemporaryLength(bb);\r\n        let values = message.blocks || (message.blocks = []);\r\n        values.push(_decodeBlockReference(bb));\r\n        bb.limit = limit;\r\n        break;\r\n      }\r\n\r\n      // optional uint64 point_count = 6;\r\n      case 6: {\r\n        message.point_count = readVarint64(bb, /* unsigned */ true);\r\n        break;\r\n      }\r\n\r\n      default:\r\n        skipUnknownField(bb, tag & 7);\r\n    }\r\n  }\r\n\r\n  return message;\r\n}\r\n\r\nexport interface BlockReference {\r\n  id?: string;\r\n  layer_id?: string;\r\n  matrix?: number[];\r\n  block_id?: string;\r\n  block_table_id?: string;\r\n  color?: number;\r\n  color_index?: number;\r\n  raw_layer_id?: string;\r\n}\r\n\r\nexport function encodeBlockReference(message: BlockReference): Uint8Array {\r\n  let bb = popByteBuffer();\r\n  _encodeBlockReference(message, bb);\r\n  return toUint8Array(bb);\r\n}\r\n\r\nfunction _encodeBlockReference(message: BlockReference, bb: ByteBuffer): void {\r\n  // optional string id = 1;\r\n  let $id = message.id;\r\n  if ($id !== undefined) {\r\n    writeVarint32(bb, 10);\r\n    writeString(bb, $id);\r\n  }\r\n\r\n  // optional string layer_id = 2;\r\n  let $layer_id = message.layer_id;\r\n  if ($layer_id !== undefined) {\r\n    writeVarint32(bb, 18);\r\n    writeString(bb, $layer_id);\r\n  }\r\n\r\n  // repeated float matirx = 3;\r\n  let array$matirx = message.matrix;\r\n  if (array$matirx !== undefined) {\r\n    let packed = popByteBuffer();\r\n    for (let value of array$matirx) {\r\n      writeFloat(packed, value);\r\n    }\r\n    writeVarint32(bb, 26);\r\n    writeVarint32(bb, packed.offset);\r\n    writeByteBuffer(bb, packed);\r\n    pushByteBuffer(packed);\r\n  }\r\n\r\n  // optional string block_id = 4;\r\n  let $block_id = message.block_id;\r\n  if ($block_id !== undefined) {\r\n    writeVarint32(bb, 34);\r\n    writeString(bb, $block_id);\r\n  }\r\n\r\n  // optional string block_table_id = 5;\r\n  let $block_table_id = message.block_table_id;\r\n  if ($block_table_id !== undefined) {\r\n    writeVarint32(bb, 42);\r\n    writeString(bb, $block_table_id);\r\n  }\r\n\r\n  // optional uint32 color = 6;\r\n  let $color = message.color;\r\n  if ($color !== undefined) {\r\n    writeVarint32(bb, 48);\r\n    writeVarint32(bb, $color);\r\n  }\r\n\r\n  // optional uint32 color_index = 7;\r\n  let $color_index = message.color_index;\r\n  if ($color_index !== undefined) {\r\n    writeVarint32(bb, 56);\r\n    writeVarint32(bb, $color_index);\r\n  }\r\n\r\n  // optional string raw_layer_id = 8;\r\n  let $raw_layer_id = message.raw_layer_id;\r\n  if ($raw_layer_id !== undefined) {\r\n    writeVarint32(bb, 66);\r\n    writeString(bb, $raw_layer_id);\r\n  }\r\n}\r\n\r\nexport function decodeBlockReference(binary: Uint8Array): BlockReference {\r\n  return _decodeBlockReference(wrapByteBuffer(binary));\r\n}\r\n\r\nfunction _decodeBlockReference(bb: ByteBuffer): BlockReference {\r\n  let message: BlockReference = {} as any;\r\n\r\n  end_of_message: while (!isAtEnd(bb)) {\r\n    let tag = readVarint32(bb);\r\n\r\n    switch (tag >>> 3) {\r\n      case 0:\r\n        break end_of_message;\r\n\r\n      // optional string id = 1;\r\n      case 1: {\r\n        message.id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional string layer_id = 2;\r\n      case 2: {\r\n        message.layer_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // repeated float matirx = 3;\r\n      case 3: {\r\n        let values = message.matrix || (message.matrix = []);\r\n        if ((tag & 7) === 2) {\r\n          let outerLimit = pushTemporaryLength(bb);\r\n          while (!isAtEnd(bb)) {\r\n            values.push(readFloat(bb));\r\n          }\r\n          bb.limit = outerLimit;\r\n        } else {\r\n          values.push(readFloat(bb));\r\n        }\r\n        break;\r\n      }\r\n\r\n      // optional string block_id = 4;\r\n      case 4: {\r\n        message.block_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional string block_table_id = 5;\r\n      case 5: {\r\n        message.block_table_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional uint32 color = 6;\r\n      case 6: {\r\n        message.color = readVarint32(bb) >>> 0;\r\n        break;\r\n      }\r\n\r\n      // optional uint32 color_index = 7;\r\n      case 7: {\r\n        message.color_index = readVarint32(bb) >>> 0;\r\n        break;\r\n      }\r\n\r\n      // optional string raw_layer_id = 8;\r\n      case 8: {\r\n        message.raw_layer_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      default:\r\n        skipUnknownField(bb, tag & 7);\r\n    }\r\n  }\r\n\r\n  return message;\r\n}\r\n\r\nexport interface Layer {\r\n  id?: string;\r\n  name?: Uint8Array;\r\n  color?: number;\r\n  color_index?: number;\r\n  line_count?: number;\r\n  mesh_count?: number;\r\n}\r\n\r\nexport function encodeLayer(message: Layer): Uint8Array {\r\n  let bb = popByteBuffer();\r\n  _encodeLayer(message, bb);\r\n  return toUint8Array(bb);\r\n}\r\n\r\nfunction _encodeLayer(message: Layer, bb: ByteBuffer): void {\r\n  // optional string id = 1;\r\n  let $id = message.id;\r\n  if ($id !== undefined) {\r\n    writeVarint32(bb, 10);\r\n    writeString(bb, $id);\r\n  }\r\n\r\n  // optional bytes name = 2;\r\n  let $name = message.name;\r\n  if ($name !== undefined) {\r\n    writeVarint32(bb, 18);\r\n    writeVarint32(bb, $name.length), writeBytes(bb, $name);\r\n  }\r\n\r\n  // optional uint32 color = 3;\r\n  let $color = message.color;\r\n  if ($color !== undefined) {\r\n    writeVarint32(bb, 24);\r\n    writeVarint32(bb, $color);\r\n  }\r\n\r\n  // optional uint32 color_index = 4;\r\n  let $color_index = message.color_index;\r\n  if ($color_index !== undefined) {\r\n    writeVarint32(bb, 32);\r\n    writeVarint32(bb, $color_index);\r\n  }\r\n\r\n  // optional uint32 line_count = 5;\r\n  let $line_count = message.line_count;\r\n  if ($line_count !== undefined) {\r\n    writeVarint32(bb, 40);\r\n    writeVarint32(bb, $line_count);\r\n  }\r\n\r\n  // optional uint32 mesh_count = 6;\r\n  let $mesh_count = message.mesh_count;\r\n  if ($mesh_count !== undefined) {\r\n    writeVarint32(bb, 48);\r\n    writeVarint32(bb, $mesh_count);\r\n  }\r\n}\r\n\r\nexport function decodeLayer(binary: Uint8Array): Layer {\r\n  return _decodeLayer(wrapByteBuffer(binary));\r\n}\r\n\r\nfunction _decodeLayer(bb: ByteBuffer): Layer {\r\n  let message: Layer = {} as any;\r\n\r\n  end_of_message: while (!isAtEnd(bb)) {\r\n    let tag = readVarint32(bb);\r\n\r\n    switch (tag >>> 3) {\r\n      case 0:\r\n        break end_of_message;\r\n\r\n      // optional string id = 1;\r\n      case 1: {\r\n        message.id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional bytes name = 2;\r\n      case 2: {\r\n        message.name = readBytes(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional uint32 color = 3;\r\n      case 3: {\r\n        message.color = readVarint32(bb) >>> 0;\r\n        break;\r\n      }\r\n\r\n      // optional uint32 color_index = 4;\r\n      case 4: {\r\n        message.color_index = readVarint32(bb) >>> 0;\r\n        break;\r\n      }\r\n\r\n      // optional uint32 line_count = 5;\r\n      case 5: {\r\n        message.line_count = readVarint32(bb) >>> 0;\r\n        break;\r\n      }\r\n\r\n      // optional uint32 mesh_count = 6;\r\n      case 6: {\r\n        message.mesh_count = readVarint32(bb) >>> 0;\r\n        break;\r\n      }\r\n\r\n      default:\r\n        skipUnknownField(bb, tag & 7);\r\n    }\r\n  }\r\n\r\n  return message;\r\n}\r\n\r\nexport interface Point {\r\n  x?: number;\r\n  y?: number;\r\n  z?: number;\r\n}\r\n\r\nexport function encodePoint(message: Point): Uint8Array {\r\n  let bb = popByteBuffer();\r\n  _encodePoint(message, bb);\r\n  return toUint8Array(bb);\r\n}\r\n\r\nfunction _encodePoint(message: Point, bb: ByteBuffer): void {\r\n  // optional double x = 1;\r\n  let $x = message.x;\r\n  if ($x !== undefined) {\r\n    writeVarint32(bb, 9);\r\n    writeDouble(bb, $x);\r\n  }\r\n\r\n  // optional double y = 2;\r\n  let $y = message.y;\r\n  if ($y !== undefined) {\r\n    writeVarint32(bb, 17);\r\n    writeDouble(bb, $y);\r\n  }\r\n\r\n  // optional double z = 3;\r\n  let $z = message.z;\r\n  if ($z !== undefined) {\r\n    writeVarint32(bb, 25);\r\n    writeDouble(bb, $z);\r\n  }\r\n}\r\n\r\nexport function decodePoint(binary: Uint8Array): Point {\r\n  return _decodePoint(wrapByteBuffer(binary));\r\n}\r\n\r\nfunction _decodePoint(bb: ByteBuffer): Point {\r\n  let message: Point = {} as any;\r\n\r\n  end_of_message: while (!isAtEnd(bb)) {\r\n    let tag = readVarint32(bb);\r\n\r\n    switch (tag >>> 3) {\r\n      case 0:\r\n        break end_of_message;\r\n\r\n      // optional double x = 1;\r\n      case 1: {\r\n        message.x = readDouble(bb);\r\n        break;\r\n      }\r\n\r\n      // optional double y = 2;\r\n      case 2: {\r\n        message.y = readDouble(bb);\r\n        break;\r\n      }\r\n\r\n      // optional double z = 3;\r\n      case 3: {\r\n        message.z = readDouble(bb);\r\n        break;\r\n      }\r\n\r\n      default:\r\n        skipUnknownField(bb, tag & 7);\r\n    }\r\n  }\r\n\r\n  return message;\r\n}\r\n\r\nexport interface Line {\r\n  id?: string;\r\n  layer_id?: string;\r\n  block_id?: string;\r\n  line_type_id?: string;\r\n  color?: number;\r\n  color_index?: number;\r\n  points?: Point[];\r\n  indexes?: number[];\r\n  line_type_scale?: number;\r\n  raw_layer_id?: string;\r\n  root_reference_id?: string;\r\n  root_block_id?: string;\r\n  block_path?: Uint8Array[];\r\n}\r\n\r\nexport function encodeLine(message: Line): Uint8Array {\r\n  let bb = popByteBuffer();\r\n  _encodeLine(message, bb);\r\n  return toUint8Array(bb);\r\n}\r\n\r\nfunction _encodeLine(message: Line, bb: ByteBuffer): void {\r\n  // optional string id = 1;\r\n  let $id = message.id;\r\n  if ($id !== undefined) {\r\n    writeVarint32(bb, 10);\r\n    writeString(bb, $id);\r\n  }\r\n\r\n  // optional string layer_id = 2;\r\n  let $layer_id = message.layer_id;\r\n  if ($layer_id !== undefined) {\r\n    writeVarint32(bb, 18);\r\n    writeString(bb, $layer_id);\r\n  }\r\n\r\n  // optional string block_id = 3;\r\n  let $block_id = message.block_id;\r\n  if ($block_id !== undefined) {\r\n    writeVarint32(bb, 26);\r\n    writeString(bb, $block_id);\r\n  }\r\n\r\n  // optional string line_type_id = 4;\r\n  let $line_type_id = message.line_type_id;\r\n  if ($line_type_id !== undefined) {\r\n    writeVarint32(bb, 34);\r\n    writeString(bb, $line_type_id);\r\n  }\r\n\r\n  // optional uint32 color = 5;\r\n  let $color = message.color;\r\n  if ($color !== undefined) {\r\n    writeVarint32(bb, 40);\r\n    writeVarint32(bb, $color);\r\n  }\r\n\r\n  // optional uint32 color_index = 6;\r\n  let $color_index = message.color_index;\r\n  if ($color_index !== undefined) {\r\n    writeVarint32(bb, 48);\r\n    writeVarint32(bb, $color_index);\r\n  }\r\n\r\n  // repeated Point points = 7;\r\n  let array$points = message.points;\r\n  if (array$points !== undefined) {\r\n    for (let value of array$points) {\r\n      writeVarint32(bb, 58);\r\n      let nested = popByteBuffer();\r\n      _encodePoint(value, nested);\r\n      writeVarint32(bb, nested.limit);\r\n      writeByteBuffer(bb, nested);\r\n      pushByteBuffer(nested);\r\n    }\r\n  }\r\n\r\n  // repeated uint32 indexes = 8;\r\n  let array$indexes = message.indexes;\r\n  if (array$indexes !== undefined) {\r\n    let packed = popByteBuffer();\r\n    for (let value of array$indexes) {\r\n      writeVarint32(packed, value);\r\n    }\r\n    writeVarint32(bb, 66);\r\n    writeVarint32(bb, packed.offset);\r\n    writeByteBuffer(bb, packed);\r\n    pushByteBuffer(packed);\r\n  }\r\n\r\n  // optional double line_type_scale = 9;\r\n  let $line_type_scale = message.line_type_scale;\r\n  if ($line_type_scale !== undefined) {\r\n    writeVarint32(bb, 73);\r\n    writeDouble(bb, $line_type_scale);\r\n  }\r\n\r\n  // optional string raw_layer_id = 10;\r\n  let $raw_layer_id = message.raw_layer_id;\r\n  if ($raw_layer_id !== undefined) {\r\n    writeVarint32(bb, 82);\r\n    writeString(bb, $raw_layer_id);\r\n  }\r\n\r\n  // optional string root_reference_id = 11;\r\n  let $root_reference_id = message.root_reference_id;\r\n  if ($root_reference_id !== undefined) {\r\n    writeVarint32(bb, 90);\r\n    writeString(bb, $root_reference_id);\r\n  }\r\n\r\n  // optional string root_block_id = 12;\r\n  let $root_block_id = message.root_block_id;\r\n  if ($root_block_id !== undefined) {\r\n    writeVarint32(bb, 98);\r\n    writeString(bb, $root_block_id);\r\n  }\r\n\r\n  // repeated bytes block_path = 13;\r\n  let array$block_path = message.block_path;\r\n  if (array$block_path !== undefined) {\r\n    for (let value of array$block_path) {\r\n      writeVarint32(bb, 106);\r\n      writeVarint32(bb, value.length), writeBytes(bb, value);\r\n    }\r\n  }\r\n}\r\n\r\nexport function decodeLine(binary: Uint8Array): Line {\r\n  return _decodeLine(wrapByteBuffer(binary));\r\n}\r\n\r\nfunction _decodeLine(bb: ByteBuffer): Line {\r\n  let message: Line = {} as any;\r\n\r\n  end_of_message: while (!isAtEnd(bb)) {\r\n    let tag = readVarint32(bb);\r\n\r\n    switch (tag >>> 3) {\r\n      case 0:\r\n        break end_of_message;\r\n\r\n      // optional string id = 1;\r\n      case 1: {\r\n        message.id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional string layer_id = 2;\r\n      case 2: {\r\n        message.layer_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional string block_id = 3;\r\n      case 3: {\r\n        message.block_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional string line_type_id = 4;\r\n      case 4: {\r\n        message.line_type_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional uint32 color = 5;\r\n      case 5: {\r\n        message.color = readVarint32(bb) >>> 0;\r\n        break;\r\n      }\r\n\r\n      // optional uint32 color_index = 6;\r\n      case 6: {\r\n        message.color_index = readVarint32(bb) >>> 0;\r\n        break;\r\n      }\r\n\r\n      // repeated Point points = 7;\r\n      case 7: {\r\n        let limit = pushTemporaryLength(bb);\r\n        let values = message.points || (message.points = []);\r\n        values.push(_decodePoint(bb));\r\n        bb.limit = limit;\r\n        break;\r\n      }\r\n\r\n      // repeated uint32 indexes = 8;\r\n      case 8: {\r\n        let values = message.indexes || (message.indexes = []);\r\n        if ((tag & 7) === 2) {\r\n          let outerLimit = pushTemporaryLength(bb);\r\n          while (!isAtEnd(bb)) {\r\n            values.push(readVarint32(bb) >>> 0);\r\n          }\r\n          bb.limit = outerLimit;\r\n        } else {\r\n          values.push(readVarint32(bb) >>> 0);\r\n        }\r\n        break;\r\n      }\r\n\r\n      // optional double line_type_scale = 9;\r\n      case 9: {\r\n        message.line_type_scale = readDouble(bb);\r\n        break;\r\n      }\r\n\r\n      // optional string raw_layer_id = 10;\r\n      case 10: {\r\n        message.raw_layer_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional string root_reference_id = 11;\r\n      case 11: {\r\n        message.root_reference_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional string root_block_id = 12;\r\n      case 12: {\r\n        message.root_block_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // repeated bytes block_path = 13;\r\n      case 13: {\r\n        let values = message.block_path || (message.block_path = []);\r\n        values.push(readBytes(bb, readVarint32(bb)));\r\n        break;\r\n      }\r\n\r\n      default:\r\n        skipUnknownField(bb, tag & 7);\r\n    }\r\n  }\r\n\r\n  return message;\r\n}\r\n\r\nexport interface Mesh {\r\n  id?: string;\r\n  layer_id?: string;\r\n  block_id?: string;\r\n  line_type_id?: string;\r\n  color?: number;\r\n  color_index?: number;\r\n  vertexs?: number[];\r\n  indexes?: number[];\r\n  line_type_scale?: number;\r\n  raw_layer_id?: string;\r\n  root_reference_id?: string;\r\n  root_block_id?: string;\r\n  block_path?: Uint8Array[];\r\n}\r\n\r\nexport function encodeMesh(message: Mesh): Uint8Array {\r\n  let bb = popByteBuffer();\r\n  _encodeMesh(message, bb);\r\n  return toUint8Array(bb);\r\n}\r\n\r\nfunction _encodeMesh(message: Mesh, bb: ByteBuffer): void {\r\n  // optional string id = 1;\r\n  let $id = message.id;\r\n  if ($id !== undefined) {\r\n    writeVarint32(bb, 10);\r\n    writeString(bb, $id);\r\n  }\r\n\r\n  // optional string layer_id = 2;\r\n  let $layer_id = message.layer_id;\r\n  if ($layer_id !== undefined) {\r\n    writeVarint32(bb, 18);\r\n    writeString(bb, $layer_id);\r\n  }\r\n\r\n  // optional string block_id = 3;\r\n  let $block_id = message.block_id;\r\n  if ($block_id !== undefined) {\r\n    writeVarint32(bb, 26);\r\n    writeString(bb, $block_id);\r\n  }\r\n\r\n  // optional string line_type_id = 4;\r\n  let $line_type_id = message.line_type_id;\r\n  if ($line_type_id !== undefined) {\r\n    writeVarint32(bb, 34);\r\n    writeString(bb, $line_type_id);\r\n  }\r\n\r\n  // optional uint32 color = 5;\r\n  let $color = message.color;\r\n  if ($color !== undefined) {\r\n    writeVarint32(bb, 40);\r\n    writeVarint32(bb, $color);\r\n  }\r\n\r\n  // optional uint32 color_index = 6;\r\n  let $color_index = message.color_index;\r\n  if ($color_index !== undefined) {\r\n    writeVarint32(bb, 48);\r\n    writeVarint32(bb, $color_index);\r\n  }\r\n\r\n  // repeated double vertexs = 7;\r\n  let array$vertexs = message.vertexs;\r\n  if (array$vertexs !== undefined) {\r\n    let packed = popByteBuffer();\r\n    for (let value of array$vertexs) {\r\n      writeDouble(packed, value);\r\n    }\r\n    writeVarint32(bb, 58);\r\n    writeVarint32(bb, packed.offset);\r\n    writeByteBuffer(bb, packed);\r\n    pushByteBuffer(packed);\r\n  }\r\n\r\n  // repeated int32 indexes = 8;\r\n  let array$indexes = message.indexes;\r\n  if (array$indexes !== undefined) {\r\n    let packed = popByteBuffer();\r\n    for (let value of array$indexes) {\r\n      writeVarint64(packed, intToLong(value));\r\n    }\r\n    writeVarint32(bb, 66);\r\n    writeVarint32(bb, packed.offset);\r\n    writeByteBuffer(bb, packed);\r\n    pushByteBuffer(packed);\r\n  }\r\n\r\n  // optional double line_type_scale = 9;\r\n  let $line_type_scale = message.line_type_scale;\r\n  if ($line_type_scale !== undefined) {\r\n    writeVarint32(bb, 73);\r\n    writeDouble(bb, $line_type_scale);\r\n  }\r\n\r\n  // optional string raw_layer_id = 10;\r\n  let $raw_layer_id = message.raw_layer_id;\r\n  if ($raw_layer_id !== undefined) {\r\n    writeVarint32(bb, 82);\r\n    writeString(bb, $raw_layer_id);\r\n  }\r\n\r\n  // optional string root_reference_id = 11;\r\n  let $root_reference_id = message.root_reference_id;\r\n  if ($root_reference_id !== undefined) {\r\n    writeVarint32(bb, 90);\r\n    writeString(bb, $root_reference_id);\r\n  }\r\n\r\n  // optional string root_block_id = 12;\r\n  let $root_block_id = message.root_block_id;\r\n  if ($root_block_id !== undefined) {\r\n    writeVarint32(bb, 98);\r\n    writeString(bb, $root_block_id);\r\n  }\r\n\r\n  // repeated bytes block_path = 13;\r\n  let array$block_path = message.block_path;\r\n  if (array$block_path !== undefined) {\r\n    for (let value of array$block_path) {\r\n      writeVarint32(bb, 106);\r\n      writeVarint32(bb, value.length), writeBytes(bb, value);\r\n    }\r\n  }\r\n}\r\n\r\nexport function decodeMesh(binary: Uint8Array): Mesh {\r\n  return _decodeMesh(wrapByteBuffer(binary));\r\n}\r\n\r\nfunction _decodeMesh(bb: ByteBuffer): Mesh {\r\n  let message: Mesh = {} as any;\r\n\r\n  end_of_message: while (!isAtEnd(bb)) {\r\n    let tag = readVarint32(bb);\r\n\r\n    switch (tag >>> 3) {\r\n      case 0:\r\n        break end_of_message;\r\n\r\n      // optional string id = 1;\r\n      case 1: {\r\n        message.id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional string layer_id = 2;\r\n      case 2: {\r\n        message.layer_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional string block_id = 3;\r\n      case 3: {\r\n        message.block_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional string line_type_id = 4;\r\n      case 4: {\r\n        message.line_type_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional uint32 color = 5;\r\n      case 5: {\r\n        message.color = readVarint32(bb) >>> 0;\r\n        break;\r\n      }\r\n\r\n      // optional uint32 color_index = 6;\r\n      case 6: {\r\n        message.color_index = readVarint32(bb) >>> 0;\r\n        break;\r\n      }\r\n\r\n      // repeated double vertexs = 7;\r\n      case 7: {\r\n        let values = message.vertexs || (message.vertexs = []);\r\n        if ((tag & 7) === 2) {\r\n          let outerLimit = pushTemporaryLength(bb);\r\n          while (!isAtEnd(bb)) {\r\n            values.push(readDouble(bb));\r\n          }\r\n          bb.limit = outerLimit;\r\n        } else {\r\n          values.push(readDouble(bb));\r\n        }\r\n        break;\r\n      }\r\n\r\n      // repeated int32 indexes = 8;\r\n      case 8: {\r\n        let values = message.indexes || (message.indexes = []);\r\n        if ((tag & 7) === 2) {\r\n          let outerLimit = pushTemporaryLength(bb);\r\n          while (!isAtEnd(bb)) {\r\n            values.push(readVarint32(bb));\r\n          }\r\n          bb.limit = outerLimit;\r\n        } else {\r\n          values.push(readVarint32(bb));\r\n        }\r\n        break;\r\n      }\r\n\r\n      // optional double line_type_scale = 9;\r\n      case 9: {\r\n        message.line_type_scale = readDouble(bb);\r\n        break;\r\n      }\r\n\r\n      // optional string raw_layer_id = 10;\r\n      case 10: {\r\n        message.raw_layer_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional string root_reference_id = 11;\r\n      case 11: {\r\n        message.root_reference_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional string root_block_id = 12;\r\n      case 12: {\r\n        message.root_block_id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // repeated bytes block_path = 13;\r\n      case 13: {\r\n        let values = message.block_path || (message.block_path = []);\r\n        values.push(readBytes(bb, readVarint32(bb)));\r\n        break;\r\n      }\r\n\r\n      default:\r\n        skipUnknownField(bb, tag & 7);\r\n    }\r\n  }\r\n\r\n  return message;\r\n}\r\n\r\nexport interface LineType {\r\n  id?: string;\r\n  name?: Uint8Array;\r\n  scale?: number;\r\n  description?: string;\r\n  deash?: number[];\r\n  labels?: LineTypeLabel[];\r\n}\r\n\r\nexport function encodeLineType(message: LineType): Uint8Array {\r\n  let bb = popByteBuffer();\r\n  _encodeLineType(message, bb);\r\n  return toUint8Array(bb);\r\n}\r\n\r\nfunction _encodeLineType(message: LineType, bb: ByteBuffer): void {\r\n  // optional string id = 1;\r\n  let $id = message.id;\r\n  if ($id !== undefined) {\r\n    writeVarint32(bb, 10);\r\n    writeString(bb, $id);\r\n  }\r\n\r\n  // optional bytes name = 2;\r\n  let $name = message.name;\r\n  if ($name !== undefined) {\r\n    writeVarint32(bb, 18);\r\n    writeVarint32(bb, $name.length), writeBytes(bb, $name);\r\n  }\r\n\r\n  // optional double scale = 3;\r\n  let $scale = message.scale;\r\n  if ($scale !== undefined) {\r\n    writeVarint32(bb, 25);\r\n    writeDouble(bb, $scale);\r\n  }\r\n\r\n  // optional string description = 4;\r\n  let $description = message.description;\r\n  if ($description !== undefined) {\r\n    writeVarint32(bb, 34);\r\n    writeString(bb, $description);\r\n  }\r\n\r\n  // repeated float deash = 5;\r\n  let array$deash = message.deash;\r\n  if (array$deash !== undefined) {\r\n    let packed = popByteBuffer();\r\n    for (let value of array$deash) {\r\n      writeFloat(packed, value);\r\n    }\r\n    writeVarint32(bb, 42);\r\n    writeVarint32(bb, packed.offset);\r\n    writeByteBuffer(bb, packed);\r\n    pushByteBuffer(packed);\r\n  }\r\n\r\n  // repeated LineTypeLabel labels = 6;\r\n  let array$labels = message.labels;\r\n  if (array$labels !== undefined) {\r\n    for (let value of array$labels) {\r\n      writeVarint32(bb, 50);\r\n      let nested = popByteBuffer();\r\n      _encodeLineTypeLabel(value, nested);\r\n      writeVarint32(bb, nested.limit);\r\n      writeByteBuffer(bb, nested);\r\n      pushByteBuffer(nested);\r\n    }\r\n  }\r\n}\r\n\r\nexport function decodeLineType(binary: Uint8Array): LineType {\r\n  return _decodeLineType(wrapByteBuffer(binary));\r\n}\r\n\r\nfunction _decodeLineType(bb: ByteBuffer): LineType {\r\n  let message: LineType = {} as any;\r\n\r\n  end_of_message: while (!isAtEnd(bb)) {\r\n    let tag = readVarint32(bb);\r\n\r\n    switch (tag >>> 3) {\r\n      case 0:\r\n        break end_of_message;\r\n\r\n      // optional string id = 1;\r\n      case 1: {\r\n        message.id = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional bytes name = 2;\r\n      case 2: {\r\n        message.name = readBytes(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional double scale = 3;\r\n      case 3: {\r\n        message.scale = readDouble(bb);\r\n        break;\r\n      }\r\n\r\n      // optional string description = 4;\r\n      case 4: {\r\n        message.description = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // repeated float deash = 5;\r\n      case 5: {\r\n        let values = message.deash || (message.deash = []);\r\n        if ((tag & 7) === 2) {\r\n          let outerLimit = pushTemporaryLength(bb);\r\n          while (!isAtEnd(bb)) {\r\n            values.push(readFloat(bb));\r\n          }\r\n          bb.limit = outerLimit;\r\n        } else {\r\n          values.push(readFloat(bb));\r\n        }\r\n        break;\r\n      }\r\n\r\n      // repeated LineTypeLabel labels = 6;\r\n      case 6: {\r\n        let limit = pushTemporaryLength(bb);\r\n        let values = message.labels || (message.labels = []);\r\n        values.push(_decodeLineTypeLabel(bb));\r\n        bb.limit = limit;\r\n        break;\r\n      }\r\n\r\n      default:\r\n        skipUnknownField(bb, tag & 7);\r\n    }\r\n  }\r\n\r\n  return message;\r\n}\r\n\r\nexport interface LineTypeLabel {\r\n  label?: string;\r\n  postion?: number;\r\n  scale?: number;\r\n  angle?: number;\r\n  offset_x?: number;\r\n  offset_y?: number;\r\n}\r\n\r\nexport function encodeLineTypeLabel(message: LineTypeLabel): Uint8Array {\r\n  let bb = popByteBuffer();\r\n  _encodeLineTypeLabel(message, bb);\r\n  return toUint8Array(bb);\r\n}\r\n\r\nfunction _encodeLineTypeLabel(message: LineTypeLabel, bb: ByteBuffer): void {\r\n  // optional string label = 1;\r\n  let $label = message.label;\r\n  if ($label !== undefined) {\r\n    writeVarint32(bb, 10);\r\n    writeString(bb, $label);\r\n  }\r\n\r\n  // optional float postion = 2;\r\n  let $postion = message.postion;\r\n  if ($postion !== undefined) {\r\n    writeVarint32(bb, 21);\r\n    writeFloat(bb, $postion);\r\n  }\r\n\r\n  // optional float scale = 3;\r\n  let $scale = message.scale;\r\n  if ($scale !== undefined) {\r\n    writeVarint32(bb, 29);\r\n    writeFloat(bb, $scale);\r\n  }\r\n\r\n  // optional float angle = 4;\r\n  let $angle = message.angle;\r\n  if ($angle !== undefined) {\r\n    writeVarint32(bb, 37);\r\n    writeFloat(bb, $angle);\r\n  }\r\n\r\n  // optional float offset_x = 5;\r\n  let $offset_x = message.offset_x;\r\n  if ($offset_x !== undefined) {\r\n    writeVarint32(bb, 45);\r\n    writeFloat(bb, $offset_x);\r\n  }\r\n\r\n  // optional float offset_y = 6;\r\n  let $offset_y = message.offset_y;\r\n  if ($offset_y !== undefined) {\r\n    writeVarint32(bb, 53);\r\n    writeFloat(bb, $offset_y);\r\n  }\r\n}\r\n\r\nexport function decodeLineTypeLabel(binary: Uint8Array): LineTypeLabel {\r\n  return _decodeLineTypeLabel(wrapByteBuffer(binary));\r\n}\r\n\r\nfunction _decodeLineTypeLabel(bb: ByteBuffer): LineTypeLabel {\r\n  let message: LineTypeLabel = {} as any;\r\n\r\n  end_of_message: while (!isAtEnd(bb)) {\r\n    let tag = readVarint32(bb);\r\n\r\n    switch (tag >>> 3) {\r\n      case 0:\r\n        break end_of_message;\r\n\r\n      // optional string label = 1;\r\n      case 1: {\r\n        message.label = readString(bb, readVarint32(bb));\r\n        break;\r\n      }\r\n\r\n      // optional float postion = 2;\r\n      case 2: {\r\n        message.postion = readFloat(bb);\r\n        break;\r\n      }\r\n\r\n      // optional float scale = 3;\r\n      case 3: {\r\n        message.scale = readFloat(bb);\r\n        break;\r\n      }\r\n\r\n      // optional float angle = 4;\r\n      case 4: {\r\n        message.angle = readFloat(bb);\r\n        break;\r\n      }\r\n\r\n      // optional float offset_x = 5;\r\n      case 5: {\r\n        message.offset_x = readFloat(bb);\r\n        break;\r\n      }\r\n\r\n      // optional float offset_y = 6;\r\n      case 6: {\r\n        message.offset_y = readFloat(bb);\r\n        break;\r\n      }\r\n\r\n      default:\r\n        skipUnknownField(bb, tag & 7);\r\n    }\r\n  }\r\n\r\n  return message;\r\n}\r\n\r\nexport interface Long {\r\n  low: number;\r\n  high: number;\r\n  unsigned: boolean;\r\n}\r\n\r\ninterface ByteBuffer {\r\n  bytes: Uint8Array;\r\n  offset: number;\r\n  limit: number;\r\n}\r\n\r\nfunction pushTemporaryLength(bb: ByteBuffer): number {\r\n  let length = readVarint32(bb);\r\n  let limit = bb.limit;\r\n  bb.limit = bb.offset + length;\r\n  return limit;\r\n}\r\n\r\nfunction skipUnknownField(bb: ByteBuffer, type: number): void {\r\n  switch (type) {\r\n    case 0: while (readByte(bb) & 0x80) { } break;\r\n    case 2: skip(bb, readVarint32(bb)); break;\r\n    case 5: skip(bb, 4); break;\r\n    case 1: skip(bb, 8); break;\r\n    default: throw new Error(\"Unimplemented type: \" + type);\r\n  }\r\n}\r\n\r\nfunction stringToLong(value: string): Long {\r\n  return {\r\n    low: value.charCodeAt(0) | (value.charCodeAt(1) << 16),\r\n    high: value.charCodeAt(2) | (value.charCodeAt(3) << 16),\r\n    unsigned: false,\r\n  };\r\n}\r\n\r\nfunction longToString(value: Long): string {\r\n  let low = value.low;\r\n  let high = value.high;\r\n  return String.fromCharCode(\r\n    low & 0xFFFF,\r\n    low >>> 16,\r\n    high & 0xFFFF,\r\n    high >>> 16);\r\n}\r\n\r\n// The code below was modified from https://github.com/protobufjs/bytebuffer.js\r\n// which is under the Apache License 2.0.\r\n\r\nlet f32 = new Float32Array(1);\r\nlet f32_u8 = new Uint8Array(f32.buffer);\r\n\r\nlet f64 = new Float64Array(1);\r\nlet f64_u8 = new Uint8Array(f64.buffer);\r\n\r\nfunction intToLong(value: number): Long {\r\n  value |= 0;\r\n  return {\r\n    low: value,\r\n    high: value >> 31,\r\n    unsigned: value >= 0,\r\n  };\r\n}\r\n\r\nlet bbStack: ByteBuffer[] = [];\r\n\r\nfunction popByteBuffer(): ByteBuffer {\r\n  const bb = bbStack.pop();\r\n  if (!bb) return { bytes: new Uint8Array(64), offset: 0, limit: 0 };\r\n  bb.offset = bb.limit = 0;\r\n  return bb;\r\n}\r\n\r\nfunction pushByteBuffer(bb: ByteBuffer): void {\r\n  bbStack.push(bb);\r\n}\r\n\r\nfunction wrapByteBuffer(bytes: Uint8Array): ByteBuffer {\r\n  return { bytes, offset: 0, limit: bytes.length };\r\n}\r\n\r\nfunction toUint8Array(bb: ByteBuffer): Uint8Array {\r\n  let bytes = bb.bytes;\r\n  let limit = bb.limit;\r\n  return bytes.length === limit ? bytes : bytes.subarray(0, limit);\r\n}\r\n\r\nfunction skip(bb: ByteBuffer, offset: number): void {\r\n  if (bb.offset + offset > bb.limit) {\r\n    throw new Error('Skip past limit');\r\n  }\r\n  bb.offset += offset;\r\n}\r\n\r\nfunction isAtEnd(bb: ByteBuffer): boolean {\r\n  return bb.offset >= bb.limit;\r\n}\r\n\r\nfunction grow(bb: ByteBuffer, count: number): number {\r\n  let bytes = bb.bytes;\r\n  let offset = bb.offset;\r\n  let limit = bb.limit;\r\n  let finalOffset = offset + count;\r\n  if (finalOffset > bytes.length) {\r\n    let newBytes = new Uint8Array(finalOffset * 2);\r\n    newBytes.set(bytes);\r\n    bb.bytes = newBytes;\r\n  }\r\n  bb.offset = finalOffset;\r\n  if (finalOffset > limit) {\r\n    bb.limit = finalOffset;\r\n  }\r\n  return offset;\r\n}\r\n\r\nfunction advance(bb: ByteBuffer, count: number): number {\r\n  let offset = bb.offset;\r\n  if (offset + count > bb.limit) {\r\n    throw new Error('Read past limit');\r\n  }\r\n  bb.offset += count;\r\n  return offset;\r\n}\r\n\r\nfunction readBytes(bb: ByteBuffer, count: number): Uint8Array {\r\n  let offset = advance(bb, count);\r\n  return bb.bytes.subarray(offset, offset + count);\r\n}\r\n\r\nfunction writeBytes(bb: ByteBuffer, buffer: Uint8Array): void {\r\n  let offset = grow(bb, buffer.length);\r\n  bb.bytes.set(buffer, offset);\r\n}\r\n\r\nfunction readString(bb: ByteBuffer, count: number): string {\r\n  // Sadly a hand-coded UTF8 decoder is much faster than subarray+TextDecoder in V8\r\n  let offset = advance(bb, count);\r\n  let fromCharCode = String.fromCharCode;\r\n  let bytes = bb.bytes;\r\n  let invalid = '\\uFFFD';\r\n  let text = '';\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    let c1 = bytes[i + offset], c2: number, c3: number, c4: number, c: number;\r\n\r\n    // 1 byte\r\n    if ((c1 & 0x80) === 0) {\r\n      text += fromCharCode(c1);\r\n    }\r\n\r\n    // 2 bytes\r\n    else if ((c1 & 0xE0) === 0xC0) {\r\n      if (i + 1 >= count) text += invalid;\r\n      else {\r\n        c2 = bytes[i + offset + 1];\r\n        if ((c2 & 0xC0) !== 0x80) text += invalid;\r\n        else {\r\n          c = ((c1 & 0x1F) << 6) | (c2 & 0x3F);\r\n          if (c < 0x80) text += invalid;\r\n          else {\r\n            text += fromCharCode(c);\r\n            i++;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // 3 bytes\r\n    else if ((c1 & 0xF0) == 0xE0) {\r\n      if (i + 2 >= count) text += invalid;\r\n      else {\r\n        c2 = bytes[i + offset + 1];\r\n        c3 = bytes[i + offset + 2];\r\n        if (((c2 | (c3 << 8)) & 0xC0C0) !== 0x8080) text += invalid;\r\n        else {\r\n          c = ((c1 & 0x0F) << 12) | ((c2 & 0x3F) << 6) | (c3 & 0x3F);\r\n          if (c < 0x0800 || (c >= 0xD800 && c <= 0xDFFF)) text += invalid;\r\n          else {\r\n            text += fromCharCode(c);\r\n            i += 2;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // 4 bytes\r\n    else if ((c1 & 0xF8) == 0xF0) {\r\n      if (i + 3 >= count) text += invalid;\r\n      else {\r\n        c2 = bytes[i + offset + 1];\r\n        c3 = bytes[i + offset + 2];\r\n        c4 = bytes[i + offset + 3];\r\n        if (((c2 | (c3 << 8) | (c4 << 16)) & 0xC0C0C0) !== 0x808080) text += invalid;\r\n        else {\r\n          c = ((c1 & 0x07) << 0x12) | ((c2 & 0x3F) << 0x0C) | ((c3 & 0x3F) << 0x06) | (c4 & 0x3F);\r\n          if (c < 0x10000 || c > 0x10FFFF) text += invalid;\r\n          else {\r\n            c -= 0x10000;\r\n            text += fromCharCode((c >> 10) + 0xD800, (c & 0x3FF) + 0xDC00);\r\n            i += 3;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    else text += invalid;\r\n  }\r\n\r\n  return text;\r\n}\r\n\r\nfunction writeString(bb: ByteBuffer, text: string): void {\r\n  // Sadly a hand-coded UTF8 encoder is much faster than TextEncoder+set in V8\r\n  let n = text.length;\r\n  let byteCount = 0;\r\n\r\n  // Write the byte count first\r\n  for (let i = 0; i < n; i++) {\r\n    let c = text.charCodeAt(i);\r\n    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {\r\n      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;\r\n    }\r\n    byteCount += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\r\n  }\r\n  writeVarint32(bb, byteCount);\r\n\r\n  let offset = grow(bb, byteCount);\r\n  let bytes = bb.bytes;\r\n\r\n  // Then write the bytes\r\n  for (let i = 0; i < n; i++) {\r\n    let c = text.charCodeAt(i);\r\n    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {\r\n      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;\r\n    }\r\n    if (c < 0x80) {\r\n      bytes[offset++] = c;\r\n    } else {\r\n      if (c < 0x800) {\r\n        bytes[offset++] = ((c >> 6) & 0x1F) | 0xC0;\r\n      } else {\r\n        if (c < 0x10000) {\r\n          bytes[offset++] = ((c >> 12) & 0x0F) | 0xE0;\r\n        } else {\r\n          bytes[offset++] = ((c >> 18) & 0x07) | 0xF0;\r\n          bytes[offset++] = ((c >> 12) & 0x3F) | 0x80;\r\n        }\r\n        bytes[offset++] = ((c >> 6) & 0x3F) | 0x80;\r\n      }\r\n      bytes[offset++] = (c & 0x3F) | 0x80;\r\n    }\r\n  }\r\n}\r\n\r\nfunction writeByteBuffer(bb: ByteBuffer, buffer: ByteBuffer): void {\r\n  let offset = grow(bb, buffer.limit);\r\n  let from = bb.bytes;\r\n  let to = buffer.bytes;\r\n\r\n  // This for loop is much faster than subarray+set on V8\r\n  for (let i = 0, n = buffer.limit; i < n; i++) {\r\n    from[i + offset] = to[i];\r\n  }\r\n}\r\n\r\nfunction readByte(bb: ByteBuffer): number {\r\n  return bb.bytes[advance(bb, 1)];\r\n}\r\n\r\nfunction writeByte(bb: ByteBuffer, value: number): void {\r\n  let offset = grow(bb, 1);\r\n  bb.bytes[offset] = value;\r\n}\r\n\r\nfunction readFloat(bb: ByteBuffer): number {\r\n  let offset = advance(bb, 4);\r\n  let bytes = bb.bytes;\r\n\r\n  // Manual copying is much faster than subarray+set in V8\r\n  f32_u8[0] = bytes[offset++];\r\n  f32_u8[1] = bytes[offset++];\r\n  f32_u8[2] = bytes[offset++];\r\n  f32_u8[3] = bytes[offset++];\r\n  return f32[0];\r\n}\r\n\r\nfunction writeFloat(bb: ByteBuffer, value: number): void {\r\n  let offset = grow(bb, 4);\r\n  let bytes = bb.bytes;\r\n  f32[0] = value;\r\n\r\n  // Manual copying is much faster than subarray+set in V8\r\n  bytes[offset++] = f32_u8[0];\r\n  bytes[offset++] = f32_u8[1];\r\n  bytes[offset++] = f32_u8[2];\r\n  bytes[offset++] = f32_u8[3];\r\n}\r\n\r\nfunction readDouble(bb: ByteBuffer): number {\r\n  let offset = advance(bb, 8);\r\n  let bytes = bb.bytes;\r\n\r\n  // Manual copying is much faster than subarray+set in V8\r\n  f64_u8[0] = bytes[offset++];\r\n  f64_u8[1] = bytes[offset++];\r\n  f64_u8[2] = bytes[offset++];\r\n  f64_u8[3] = bytes[offset++];\r\n  f64_u8[4] = bytes[offset++];\r\n  f64_u8[5] = bytes[offset++];\r\n  f64_u8[6] = bytes[offset++];\r\n  f64_u8[7] = bytes[offset++];\r\n  return f64[0];\r\n}\r\n\r\nfunction writeDouble(bb: ByteBuffer, value: number): void {\r\n  let offset = grow(bb, 8);\r\n  let bytes = bb.bytes;\r\n  f64[0] = value;\r\n\r\n  // Manual copying is much faster than subarray+set in V8\r\n  bytes[offset++] = f64_u8[0];\r\n  bytes[offset++] = f64_u8[1];\r\n  bytes[offset++] = f64_u8[2];\r\n  bytes[offset++] = f64_u8[3];\r\n  bytes[offset++] = f64_u8[4];\r\n  bytes[offset++] = f64_u8[5];\r\n  bytes[offset++] = f64_u8[6];\r\n  bytes[offset++] = f64_u8[7];\r\n}\r\n\r\nfunction readInt32(bb: ByteBuffer): number {\r\n  let offset = advance(bb, 4);\r\n  let bytes = bb.bytes;\r\n  return (\r\n    bytes[offset] |\r\n    (bytes[offset + 1] << 8) |\r\n    (bytes[offset + 2] << 16) |\r\n    (bytes[offset + 3] << 24)\r\n  );\r\n}\r\n\r\nfunction writeInt32(bb: ByteBuffer, value: number): void {\r\n  let offset = grow(bb, 4);\r\n  let bytes = bb.bytes;\r\n  bytes[offset] = value;\r\n  bytes[offset + 1] = value >> 8;\r\n  bytes[offset + 2] = value >> 16;\r\n  bytes[offset + 3] = value >> 24;\r\n}\r\n\r\nfunction readInt64(bb: ByteBuffer, unsigned: boolean): Long {\r\n  return {\r\n    low: readInt32(bb),\r\n    high: readInt32(bb),\r\n    unsigned,\r\n  };\r\n}\r\n\r\nfunction writeInt64(bb: ByteBuffer, value: Long): void {\r\n  writeInt32(bb, value.low);\r\n  writeInt32(bb, value.high);\r\n}\r\n\r\nfunction readVarint32(bb: ByteBuffer): number {\r\n  let c = 0;\r\n  let value = 0;\r\n  let b: number;\r\n  do {\r\n    b = readByte(bb);\r\n    if (c < 32) value |= (b & 0x7F) << c;\r\n    c += 7;\r\n  } while (b & 0x80);\r\n  return value;\r\n}\r\n\r\nfunction writeVarint32(bb: ByteBuffer, value: number): void {\r\n  value >>>= 0;\r\n  while (value >= 0x80) {\r\n    writeByte(bb, (value & 0x7f) | 0x80);\r\n    value >>>= 7;\r\n  }\r\n  writeByte(bb, value);\r\n}\r\n\r\nfunction readVarint64(bb: ByteBuffer, unsigned: boolean): Long {\r\n  let part0 = 0;\r\n  let part1 = 0;\r\n  let part2 = 0;\r\n  let b: number;\r\n\r\n  b = readByte(bb); part0 = (b & 0x7F); if (b & 0x80) {\r\n    b = readByte(bb); part0 |= (b & 0x7F) << 7; if (b & 0x80) {\r\n      b = readByte(bb); part0 |= (b & 0x7F) << 14; if (b & 0x80) {\r\n        b = readByte(bb); part0 |= (b & 0x7F) << 21; if (b & 0x80) {\r\n\r\n          b = readByte(bb); part1 = (b & 0x7F); if (b & 0x80) {\r\n            b = readByte(bb); part1 |= (b & 0x7F) << 7; if (b & 0x80) {\r\n              b = readByte(bb); part1 |= (b & 0x7F) << 14; if (b & 0x80) {\r\n                b = readByte(bb); part1 |= (b & 0x7F) << 21; if (b & 0x80) {\r\n\r\n                  b = readByte(bb); part2 = (b & 0x7F); if (b & 0x80) {\r\n                    b = readByte(bb); part2 |= (b & 0x7F) << 7;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    low: part0 | (part1 << 28),\r\n    high: (part1 >>> 4) | (part2 << 24),\r\n    unsigned,\r\n  };\r\n}\r\n\r\nfunction writeVarint64(bb: ByteBuffer, value: Long): void {\r\n  let part0 = value.low >>> 0;\r\n  let part1 = ((value.low >>> 28) | (value.high << 4)) >>> 0;\r\n  let part2 = value.high >>> 24;\r\n\r\n  // ref: src/google/protobuf/io/coded_stream.cc\r\n  let size =\r\n    part2 === 0 ?\r\n      part1 === 0 ?\r\n        part0 < 1 << 14 ?\r\n          part0 < 1 << 7 ? 1 : 2 :\r\n          part0 < 1 << 21 ? 3 : 4 :\r\n        part1 < 1 << 14 ?\r\n          part1 < 1 << 7 ? 5 : 6 :\r\n          part1 < 1 << 21 ? 7 : 8 :\r\n      part2 < 1 << 7 ? 9 : 10;\r\n\r\n  let offset = grow(bb, size);\r\n  let bytes = bb.bytes;\r\n\r\n  switch (size) {\r\n    case 10: bytes[offset + 9] = (part2 >>> 7) & 0x01;\r\n    case 9: bytes[offset + 8] = size !== 9 ? part2 | 0x80 : part2 & 0x7F;\r\n    case 8: bytes[offset + 7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;\r\n    case 7: bytes[offset + 6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;\r\n    case 6: bytes[offset + 5] = size !== 6 ? (part1 >>> 7) | 0x80 : (part1 >>> 7) & 0x7F;\r\n    case 5: bytes[offset + 4] = size !== 5 ? part1 | 0x80 : part1 & 0x7F;\r\n    case 4: bytes[offset + 3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;\r\n    case 3: bytes[offset + 2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;\r\n    case 2: bytes[offset + 1] = size !== 2 ? (part0 >>> 7) | 0x80 : (part0 >>> 7) & 0x7F;\r\n    case 1: bytes[offset] = size !== 1 ? part0 | 0x80 : part0 & 0x7F;\r\n  }\r\n}\r\n\r\nfunction readVarint32ZigZag(bb: ByteBuffer): number {\r\n  let value = readVarint32(bb);\r\n\r\n  // ref: src/google/protobuf/wire_format_lite.h\r\n  return (value >>> 1) ^ -(value & 1);\r\n}\r\n\r\nfunction writeVarint32ZigZag(bb: ByteBuffer, value: number): void {\r\n  // ref: src/google/protobuf/wire_format_lite.h\r\n  writeVarint32(bb, (value << 1) ^ (value >> 31));\r\n}\r\n\r\nfunction readVarint64ZigZag(bb: ByteBuffer): Long {\r\n  let value = readVarint64(bb, /* unsigned */ false);\r\n  let low = value.low;\r\n  let high = value.high;\r\n  let flip = -(low & 1);\r\n\r\n  // ref: src/google/protobuf/wire_format_lite.h\r\n  return {\r\n    low: ((low >>> 1) | (high << 31)) ^ flip,\r\n    high: (high >>> 1) ^ flip,\r\n    unsigned: false,\r\n  };\r\n}\r\n\r\nfunction writeVarint64ZigZag(bb: ByteBuffer, value: Long): void {\r\n  let low = value.low;\r\n  let high = value.high;\r\n  let flip = high >> 31;\r\n\r\n  // ref: src/google/protobuf/wire_format_lite.h\r\n  writeVarint64(bb, {\r\n    low: (low << 1) ^ flip,\r\n    high: ((high << 1) | (low >>> 31)) ^ flip,\r\n    unsigned: false,\r\n  });\r\n}\r\n","namespace stringUtils {\r\n  export function StringToByte(str: string) {\r\n    var bytes = new Array();\r\n    var len, c;\r\n    len = str.length;\r\n    for (var i = 0; i < len; i++) {\r\n      c = str.charCodeAt(i);\r\n      if (c >= 0x010000 && c <= 0x10ffff) {\r\n        bytes.push(((c >> 18) & 0x07) | 0xf0);\r\n        bytes.push(((c >> 12) & 0x3f) | 0x80);\r\n        bytes.push(((c >> 6) & 0x3f) | 0x80);\r\n        bytes.push((c & 0x3f) | 0x80);\r\n      } else if (c >= 0x000800 && c <= 0x00ffff) {\r\n        bytes.push(((c >> 12) & 0x0f) | 0xe0);\r\n        bytes.push(((c >> 6) & 0x3f) | 0x80);\r\n        bytes.push((c & 0x3f) | 0x80);\r\n      } else if (c >= 0x000080 && c <= 0x0007ff) {\r\n        bytes.push(((c >> 6) & 0x1f) | 0xc0);\r\n        bytes.push((c & 0x3f) | 0x80);\r\n      } else {\r\n        bytes.push(c & 0xff);\r\n      }\r\n    }\r\n    return bytes;\r\n  }\r\n  /**\r\n   *\r\n   * @param bytes 字节码转字符串\r\n   * @returns\r\n   */\r\n  export function BytesToString(bytes: Uint8Array): string {\r\n    if (typeof bytes === \"string\") {\r\n      return bytes;\r\n    }\r\n    let isUtf8 = canUseUTF8(bytes);\r\n    if (isUtf8) {\r\n      var str = \"\",\r\n        _arr = bytes;\r\n      for (var i = 0; i < _arr.length; i++) {\r\n        var one = _arr[i].toString(2),\r\n          v = one.match(/^1+?(?=0)/);\r\n        if (v && one.length == 8) {\r\n          var bytesLength = v[0].length;\r\n          var store = _arr[i].toString(2).slice(7 - bytesLength);\r\n          for (var st = 1; st < bytesLength; st++) {\r\n            store += _arr[st + i].toString(2).slice(2);\r\n          }\r\n          str += String.fromCharCode(parseInt(store, 2));\r\n          i += bytesLength - 1;\r\n        } else {\r\n          str += String.fromCharCode(_arr[i]);\r\n        }\r\n      }\r\n      return str;\r\n    }else{\r\n      const decoder  = new TextDecoder(\"gbk\");\r\n      return decoder.decode(bytes);\r\n    }\r\n  }\r\n\r\n  //判断传入的字节流能否使用utf8转成可读字符串\r\n  function canUseUTF8(buffer: Uint8Array) {\r\n    if (buffer.length > 0 && buffer[0] == 0) {\r\n      return false; //首字节为0的就不是可读字符串\r\n    }\r\n    var i = 0;\r\n    while (i < buffer.length) {\r\n      var b = buffer[i++];\r\n      var count; //判断是否符合utf8格式，并且确定后续的字节数\r\n      if (b <= 127) {\r\n        //0xxxxxxx\r\n        count = 0;\r\n      } else if (b >= 194 && b <= 223) {\r\n        //110xxxxx 10xxxxxx\r\n        count = 1;\r\n      } else if (b >= 224 && b <= 239) {\r\n        //1110xxxx 10xxxxxx 10xxxxxx\r\n        count = 2;\r\n      } else if (b >= 240 && b <= 244) {\r\n        //11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\r\n        count = 3;\r\n      } else {\r\n        return false; //不符合utf8格式的首字节\r\n      }\r\n      while (count > 0 && i < buffer.length) {\r\n        b = buffer[i++];\r\n        if (b < 128 || b > 191) {\r\n          //utf的非首字节处于128-191之间，因为10xxxxxx\r\n          return false;\r\n        }\r\n        count--;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\nexport { stringUtils };\r\n","/**\r\n * 模型数据的抽象实体，所有对外的模型数据交互，均通过该对象，或者该对象的子类\r\n */\r\n import {stringUtils} from \"../utils/StringUtils\";\r\n import {Md5} from \"ts-md5\"\r\nexport class DBEntity {\r\n  type: string; //对象类型\r\n  id: string; //对象id\r\n  layerId: string; //所属层id\r\n  blockId: string; //所属块id\r\n  parameters: { [key: string]: any } | undefined; //参数\r\n  tag: any | undefined;\r\n  unions: DBEntity[] | undefined;\r\n  model: THREE.Object3D | undefined;\r\n  points: Float32Array | undefined;\r\n  root_reference_id?: string = \"\";\r\n  block_path?: string = \"\";\r\n  root_block_id?: string=''\r\n  // geometry: any|undefined;//几何体F\r\n  //material: THREE.MeshBasicMaterial;//材质\r\n\r\n  constructor(params: {\r\n    id: string;\r\n    layerId: string;\r\n    blockId: string;\r\n    root_reference_id?: string;\r\n    block_path?: Uint8Array[];\r\n    root_block_id?:string\r\n  }) {\r\n    this.type = \"\";\r\n    this.id = params.id;\r\n    this.blockId = params.blockId;\r\n    this.layerId = params.layerId;\r\n    this.root_reference_id = params.root_reference_id;\r\n    params.block_path?.length&&params.block_path.forEach((item,index)=>{\r\n      this.block_path += stringUtils.BytesToString(item);\r\n    })\r\n    this.root_block_id=params.root_block_id\r\n    const md5:any = new Md5\r\n    this.block_path = this.block_path?.replace(/,/g, \"\");\r\n    md5.appendAsciiStr( this.block_path)\r\n    this.block_path=md5.end()\r\n\r\n  }\r\n}\r\n","import * as THREE from \"three\";\r\nimport { DBEntity } from \"./DBEntity\";\r\n/**\r\n * 存储的线\r\n */\r\nexport class DbLine extends DBEntity {\r\n  constructor(params: {\r\n    id: string;\r\n    layerId: string;\r\n    blockId: string;\r\n    points: Float32Array;\r\n    indexes: Int32Array;\r\n    root_reference_id?: string;\r\n    block_path?: Uint8Array[];\r\n    root_block_id?: string;\r\n  }) {\r\n    super(params);\r\n    this.points = params.points;\r\n    this.indexes = params.indexes;\r\n\r\n  }\r\n  points: Float32Array;\r\n  indexes: Int32Array;\r\n  sphere: THREE.Sphere | undefined;\r\n  box: THREE.Box3 | undefined;\r\n  index?: number = 0;\r\n  radiusCp?: number;\r\n\r\n\r\n\r\n  /**\r\n   * 获取连续线内的所有点\r\n   */\r\n  public get V3Points() {\r\n    let points = [];\r\n    for (let index = 0; index < this.points.length; index += 3) {\r\n      points.push(\r\n        new THREE.Vector3(\r\n          this.points[index],\r\n          this.points[index + 1],\r\n          this.points[index + 2]\r\n        )\r\n      );\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * 获取连续线内的子线段\r\n   */\r\n  public get Lines() {\r\n    let points = this.V3Points;\r\n    let lines: THREE.Line3[] = [];\r\n    for (let index = 0; index < this.indexes.length; index += 2) {\r\n      const startIndex = this.indexes[index];\r\n      const endIndex = this.indexes[index + 1];\r\n      lines.push(new THREE.Line3(points[startIndex], points[endIndex]));\r\n    }\r\n    return lines;\r\n  }\r\n  /**\r\n   *\r\n   * @param line 克隆方法，用于解决woker传递过来得对象没有属性了\r\n   */\r\n  static clone(line: DbLine): DbLine {\r\n    let newLine: DbLine = new DbLine({\r\n      id: line.id,\r\n      blockId: line.blockId,\r\n      indexes: line.indexes,\r\n      layerId: line.layerId,\r\n      points: line.points,\r\n    });\r\n    newLine.sphere = line.sphere;\r\n    newLine.box = line.box;\r\n    newLine.root_reference_id = line.root_reference_id\r\n    newLine.block_path = line.block_path;\r\n    newLine.root_block_id = line.root_block_id;\r\n    return newLine;\r\n  }\r\n}\r\n","import * as THREE from \"three\";\r\nimport { DBEntity } from \"./DBEntity\";\r\n\r\n/**\r\n * mesh的抽象实体\r\n */\r\nexport class DbMesh extends DBEntity {\r\n    constructor(params: { id: string, layerId: string, blockId: string, vertexs: Float32Array, indexes: Int32Array ,    \r\n        root_reference_id?: string;\r\n        block_path?: Uint8Array[],\r\n        root_block_id?: string}) {\r\n        super(params);\r\n        this.vertexs = params.vertexs;\r\n        this.indexes = params.indexes;\r\n    }\r\n    vertexs: Float32Array;\r\n    indexes: Int32Array;\r\n    count: number = 0;\r\n    sphere: THREE.Sphere | undefined;\r\n    box: THREE.Box3 | undefined;\r\n    index?: number;\r\n    radiusCp?: number;\r\n\r\n    /**\r\n     * \r\n     * @param mesh 克隆方法，用于解决woker传递过来得对象没有属性了\r\n     */\r\n    static clone(mesh: DbMesh): DbMesh {\r\n        let newMesh: DbMesh = new DbMesh({ id: mesh.id, blockId: mesh.blockId, indexes: mesh.indexes, layerId: mesh.layerId, vertexs: mesh.vertexs });\r\n        newMesh.sphere = mesh.sphere;\r\n        newMesh.box = mesh.box;\r\n        newMesh.root_reference_id = mesh.root_reference_id\r\n        newMesh.block_path = mesh.block_path;\r\n        newMesh.root_block_id = mesh.root_block_id\r\n        return newMesh;\r\n    }\r\n}","/**\r\n * 图层\r\n */\r\nexport class DbLayer {\r\n    public Name: string;\r\n    public Id: string;\r\n    Color: number | undefined;\r\n    ColorIndex: number | undefined;\r\n    Enabled: boolean = true;\r\n    Visible: boolean = true;\r\n    /**\r\n     * 存储得关联对象\r\n     */\r\n    Objects: THREE.Object3D[] = [];\r\n    LineCount: number | undefined;\r\n    MeshCount: number | undefined;\r\n    constructor(name: string, id: string) {\r\n        this.Name = name;\r\n        this.Id = id;\r\n    }\r\n}","import * as THREE from \"three\";\r\nimport { DbBlockInstance } from \"./DbBlockInstance\";\r\nimport { DbLine } from \"./DbLine\";\r\nimport { DbMesh } from \"./DbMesh\";\r\n\r\n/**\r\n * 块记录，块作为数据存储在model内，通过instance实例化到场景内\r\n */\r\nexport class DbBlockRecord{\r\n    private  m_lineGeos:{[key:string]:DbLine[]} = {}\r\n    private  m_meshGeos:{[key:string]:DbMesh[]} = {}\r\n    instances:DbBlockInstance[] = [];\r\n    Name: string|undefined;\r\n    Id: string|undefined;\r\n    public  get meshs(){\r\n        return this.m_meshGeos;\r\n    }\r\n    public  get lines(){\r\n        return this.m_lineGeos;\r\n    }\r\n}","import { DbBlockRecord } from \"./DbBlockRecord\";\r\nimport { DBEntity } from \"./DBEntity\";\r\n/**\r\n * 块的实体，DbBlockRecord通过DbBlockInstance实例化到场景内\r\n */\r\nexport class DbBlockInstance extends DBEntity {\r\n    blockRecord:DbBlockRecord;\r\n    matrix:THREE.Matrix4;\r\n    color:THREE.Color|undefined;\r\n    sphere: THREE.Sphere|undefined;\r\n    line: THREE.InstancedMesh|undefined;\r\n    Mesh:  THREE.Mesh|undefined;\r\n    originData?:{matrix:THREE.Matrix4};\r\n\r\n    constructor(params:{id:string, layerId: string, blockId: string, matrix: THREE.Matrix4, blockRecord?: DbBlockRecord})\r\n    {\r\n        super(params);\r\n        //@ts-ignore\r\n        this.blockRecord = params.blockRecord;\r\n        this.matrix = params.matrix;\r\n\r\n    }\r\n\r\n}","import {\r\n  Line,\r\n  Mesh,\r\n  decodePacket2d,\r\n  Packet2d,\r\n  Block,\r\n  BlockReference,\r\n} from \"../vendor/protobuf/packet2d\";\r\nimport { init, decompress, compress } from \"@bokuweb/zstd-wasm\";\r\nimport * as THREE from \"three\";\r\nimport { DbLine } from \"../core/DbLine\";\r\nimport { DbMesh } from \"../core/DbMesh\";\r\nimport { DbLayer } from \"../core/DbLayer\";\r\nimport { DbBlockRecord } from \"../core/DbBlockRecord\";\r\nimport { DbBlockInstance } from \"../core/DbBlockInstance\";\r\nimport { stringUtils } from \"../utils/StringUtils\";\r\n\r\n\r\nfunction loadProtobuf(url: string, callback: (p2d: Packet2d) => void) {\r\n  fetch(url)\r\n    .then((response) => response.arrayBuffer())\r\n    .then((arrayBuffer) => {\r\n      try {\r\n        const decompressed = decompress(new Uint8Array(arrayBuffer));\r\n        const p2d = decodePacket2d(new Uint8Array(decompressed));\r\n        callback(p2d);\r\n      }\r\n      catch (e) {\r\n        onComplete(false);\r\n        console.log(e,'解析错误')\r\n      }\r\n\r\n    });\r\n}\r\n// let m_lineGeos: { [key: string]:DbLine[] } = {}\r\n// let m_meshGeos: { [key: string]: DbMesh[] } = {}\r\nfunction onComplete(isComplete:boolean) {\r\n  self.postMessage({ complete: isComplete });\r\n}\r\nfunction pushData(\r\n  lines: { [key: string]: DbLine[] } | undefined,\r\n  meshs: { [key: string]: DbMesh[] } | undefined,\r\n  instances: { [key: string]: DbBlockInstance[] } | undefined,\r\n  blocks: { [key: string]: DbBlockRecord } | undefined\r\n) {\r\n  self.postMessage({\r\n    lines: lines,\r\n    meshs: meshs,\r\n    instances: instances,\r\n    blocks: blocks,\r\n  });\r\n}\r\nfunction pushLayers(layers: DbLayer[]) {\r\n  self.postMessage({ layers: layers });\r\n}\r\n/**\r\n * 统计加载的模型数量\r\n */\r\nlet layerCount: { [key: string]: { keys: string[][]; cal: number[] } } = {};\r\n\r\nself.onmessage = ({ data: { command, url } }) => {\r\n  init().then(() => {\r\n    console.time(\"load\");\r\n    loadProtobuf(url, (p2d) => {\r\n      let sum = p2d.count ?? 0;\r\n      let count = 0;\r\n      let layers: DbLayer[] = [];\r\n      p2d.layers?.forEach((layer) => {\r\n        if (layer.id) {\r\n          let name = stringUtils.BytesToString(layer.name ?? new Uint8Array());\r\n          let dbLayer = new DbLayer(name, layer.id);\r\n          dbLayer.Color = layer.color;\r\n          dbLayer.ColorIndex = layer.color_index;\r\n          dbLayer.LineCount = layer.line_count;\r\n          dbLayer.MeshCount = layer.mesh_count;\r\n          layers.push(dbLayer);\r\n          layerCount[layer.id] = {\r\n            cal: [layer.line_count ?? 0, 0, layer.mesh_count ?? 0, 0],\r\n            keys: [[], []],\r\n          };\r\n        }\r\n      });\r\n      pushLayers(layers);\r\n      let urlPre = url.substring(0, url.lastIndexOf(\".\"));\r\n      let lines: { [key: string]: DbLine[] } = {};\r\n      let meshs: { [key: string]: DbMesh[] } = {};\r\n      let blocks: { [key: string]: DbBlockRecord } = {};\r\n      let instacnces: { [key: string]: DbBlockInstance[] } = {};\r\n      let index = 1;\r\n      let path = `${urlPre}_${index}.p2d`;\r\n\r\n      LoadBodyData(p2d, lines, meshs, blocks, instacnces);\r\n      if (sum == 0) {\r\n        pushData(lines, undefined, instacnces, blocks);\r\n        pushData(undefined, meshs, instacnces, blocks);\r\n        layerCount = {};\r\n        onComplete(true);\r\n        console.timeEnd(\"load\");\r\n      }\r\n      /**\r\n       *\r\n       * @param p2d 一次加载一个文件，避免内存过快增加\r\n       */\r\n      const loadproc = (p2d: Packet2d) => {\r\n        count++;\r\n        index++;\r\n        LoadBodyData(p2d, lines, meshs, blocks, instacnces);\r\n        if (sum == count) {\r\n          /**\r\n           * 如果这里有数据，this is a bug\r\n           */\r\n          pushData(lines, undefined, instacnces, blocks);\r\n          pushData(undefined, meshs, instacnces, blocks);\r\n          layerCount = {};\r\n          onComplete(true);\r\n          console.timeEnd(\"load\");\r\n        }\r\n        let path = `${urlPre}_${index}.p2d`;\r\n        if (index <= sum) loadProtobuf(path, loadproc);\r\n      };\r\n      loadProtobuf(path, loadproc);\r\n    });\r\n  });\r\n};\r\n\r\nfunction LoadBodyData(\r\n  p2d: Packet2d,\r\n  lines: { [key: string]: DbLine[] },\r\n  meshs: { [key: string]: DbMesh[] },\r\n  blocks: { [key: string]: DbBlockRecord },\r\n  instacnces: { [key: string]: DbBlockInstance[] }\r\n) {\r\n  p2d.lines?.forEach((line) => {\r\n    addLine(lines, line);\r\n  });\r\n  p2d.meshs?.forEach((mesh) => {\r\n    addMesh(meshs, mesh);\r\n  });\r\n  p2d.block_table?.forEach((blockTable) => {\r\n    addBlocks(blocks, blockTable);\r\n  });\r\n  p2d.blocks?.forEach((block) => {\r\n    addInstance(blocks, instacnces, block);\r\n  });\r\n}\r\n\r\nfunction addLine(lines: { [key: string]: DbLine[] }, line: Line) {\r\n  const layerId = line.layer_id ?? \"\";\r\n\r\n  if (!line.points) return;\r\n  let position: number[] = [];\r\n  line.points.forEach((point) => {\r\n    position.push(point.x ?? 0, point.y ?? 0, point.z ?? 0);\r\n  });\r\n  let key = `${line.layer_id}_${line.color}`;\r\n  // console.log(JSON.stringify(line))\r\n  let linegeo: DbLine = new DbLine({\r\n    layerId: layerId,\r\n    id: line.id ?? \"\",\r\n    blockId: line.block_id ?? \"\",\r\n    points: new Float32Array(position),\r\n    indexes: new Int32Array(line.indexes || []),\r\n    root_reference_id: line.root_reference_id,\r\n    block_path: line.block_path,\r\n    root_block_id: line.root_block_id,\r\n  });\r\n  let sphere = new THREE.Sphere();\r\n  let box = new THREE.Box3();\r\n  //\r\n  box.setFromArray(linegeo.points);\r\n  box.getBoundingSphere(sphere);\r\n  linegeo.sphere = sphere;\r\n  linegeo.box = box;\r\n  if (lines[key]) {\r\n    lines[key].push(linegeo);\r\n  } else {\r\n    lines[key] = [linegeo];\r\n    layerCount[layerId].keys[0].push(key);\r\n  }\r\n  /**\r\n   * 当一个图层加载完时，提交到界面渲染\r\n   */\r\n  layerCount[layerId].cal[1]++;\r\n  if (\r\n    layerCount[layerId].cal[1] >= layerCount[layerId].cal[0] &&\r\n    layerCount[layerId].cal[0] != 0\r\n  ) {\r\n    let postLines: { [key: string]: DbLine[] } = {};\r\n    layerCount[layerId].keys[0].forEach((key) => {\r\n      postLines[key] = lines[key];\r\n      delete lines[key];\r\n    });\r\n    layerCount[layerId].keys[0] = [];\r\n    pushData(postLines, undefined, undefined, undefined);\r\n  }\r\n}\r\nfunction addMesh(meshs: { [key: string]: DbMesh[] }, mesh: Mesh) {\r\n  const layerId = mesh.layer_id ?? \"\";\r\n\r\n  if (!mesh.vertexs) return;\r\n  let key = `${mesh.layer_id}_${mesh.color ?? 0}`;\r\n\r\n  let last = mesh.vertexs.length % 9;\r\n  //不够一个三角面的点，直接舍去， 当前版本暂时不使用索引\r\n  if (last != 0) {\r\n    mesh.vertexs.splice(mesh.vertexs.length - last, last);\r\n  }\r\n  let mesGeo: DbMesh = new DbMesh({\r\n    layerId: mesh.layer_id ?? \"\",\r\n    id: mesh.id ?? \"\",\r\n    blockId: mesh.block_id ?? \"\",\r\n    vertexs: new Float32Array(mesh.vertexs),\r\n    indexes: new Int32Array(mesh.indexes || []),\r\n    root_reference_id: mesh.root_reference_id,\r\n    block_path: mesh.block_path  ,\r\n  });\r\n  let sphere = new THREE.Sphere();\r\n  let box = new THREE.Box3();\r\n  box.setFromArray(mesGeo.vertexs);\r\n  box.getBoundingSphere(sphere);\r\n  mesGeo.sphere = sphere;\r\n  mesGeo.box = box;\r\n  if (meshs[key]) {\r\n    meshs[key].push(mesGeo);\r\n  } else {\r\n    meshs[key] = [mesGeo];\r\n    layerCount[layerId].keys[1].push(key);\r\n  }\r\n\r\n  /**\r\n   * 当一个图层加载完时，提交到界面渲染\r\n   */\r\n  layerCount[layerId].cal[3]++;\r\n  if (\r\n    layerCount[layerId].cal[3] >= layerCount[layerId].cal[2] &&\r\n    layerCount[layerId].cal[0] != 0\r\n  ) {\r\n    let postMesh: { [key: string]: DbMesh[] } = {};\r\n    layerCount[layerId].keys[1].forEach((mesh_key) => {\r\n      postMesh[mesh_key] = meshs[mesh_key];\r\n      delete meshs[mesh_key];\r\n    });\r\n    layerCount[layerId].keys[1] = [];\r\n    pushData(undefined, postMesh, undefined, undefined);\r\n  }\r\n}\r\n\r\nfunction addBlocks(\r\n  blocks: { [key: string]: DbBlockRecord },\r\n  blockTableRecord: Block\r\n) {\r\n  if (blockTableRecord.id) {\r\n    let blockRecord = new DbBlockRecord();\r\n    blockRecord.instances = [];\r\n    blockRecord.Name = stringUtils.BytesToString(\r\n      blockTableRecord.name ?? new Uint8Array()\r\n    );\r\n    blockRecord.Id = blockTableRecord.id;\r\n    blockTableRecord.lines?.forEach((line) => {\r\n      addLine(blockRecord.lines, line);\r\n    });\r\n    blockTableRecord.meshs?.forEach((line) => {\r\n      addMesh(blockRecord.meshs, line);\r\n    });\r\n    blocks[blockTableRecord.id] = blockRecord;\r\n  }\r\n}\r\n\r\nfunction addInstance(\r\n  blocks: { [key: string]: DbBlockRecord },\r\n  instacnces: { [key: string]: DbBlockInstance[] },\r\n  block: BlockReference\r\n) {\r\n  let key = `${block.layer_id}`;\r\n  if (block.block_table_id && block.layer_id && block.matrix && block.id) {\r\n    let ms = block.matrix;\r\n    let matrix = new THREE.Matrix4();\r\n    matrix.set(...(ms as THREE.Matrix4Tuple))\r\n    let blockRecord = blocks[block.block_table_id];\r\n    let instance: DbBlockInstance = new DbBlockInstance({\r\n      id: block.id,\r\n      blockId: block.block_id ?? \"\",\r\n      layerId: block.layer_id,\r\n      blockRecord: blockRecord,\r\n      matrix: matrix,\r\n    });\r\n    if (!instacnces[key]) instacnces[key] = [];\r\n    instacnces[key].push(instance);\r\n    blockRecord.instances.push(instance);\r\n  }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [306], () => (__webpack_require__(593)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".CadEngine.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t593: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkCadEngine\"] = self[\"webpackChunkCadEngine\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","next","decodePacket2d","binary","bb","message","end_of_message","isAtEnd","tag","readVarint32","index","count","limit","pushTemporaryLength","layers","push","_decodeLayer","blocks","_decodeBlockReference","block_table","_decodeBlock","lines","_decodeLine","meshs","_decodeMesh","line_types","_decodeLineType","skipUnknownField","_decodePacket2d","wrapByteBuffer","id","readString","name","readBytes","point_count","readVarint64","layer_id","values","matrix","outerLimit","readFloat","block_id","block_table_id","color","color_index","raw_layer_id","line_count","mesh_count","_decodePoint","x","readDouble","y","z","line_type_id","points","indexes","line_type_scale","root_reference_id","root_block_id","block_path","vertexs","scale","description","deash","labels","_decodeLineTypeLabel","label","postion","angle","offset_x","offset_y","length","offset","type","readByte","skip","Error","f32","Float32Array","f32_u8","Uint8Array","buffer","f64","Float64Array","f64_u8","bytes","advance","subarray","fromCharCode","String","invalid","text","i","c2","c3","c4","c","c1","b","value","unsigned","part0","part1","part2","low","high","stringUtils","StringToByte","str","len","Array","charCodeAt","BytesToString","isUtf8","canUseUTF8","_arr","one","toString","v","match","bytesLength","store","slice","st","parseInt","TextDecoder","decode","DBEntity","constructor","params","this","blockId","layerId","forEach","item","md5","replace","appendAsciiStr","end","DbLine","super","V3Points","Lines","startIndex","endIndex","static","line","newLine","sphere","box","DbMesh","mesh","newMesh","DbLayer","Enabled","Visible","Objects","Name","Id","DbBlockRecord","m_lineGeos","m_meshGeos","instances","DbBlockInstance","blockRecord","loadProtobuf","url","callback","fetch","then","response","arrayBuffer","decompressed","p2d","e","onComplete","isComplete","self","postMessage","complete","pushData","layerCount","LoadBodyData","instacnces","addLine","addMesh","blockTable","blockTableRecord","addBlocks","block","key","ms","set","instance","addInstance","position","point","linegeo","Int32Array","setFromArray","getBoundingSphere","keys","cal","postLines","undefined","last","splice","mesGeo","postMesh","mesh_key","onmessage","data","command","sum","layer","dbLayer","Color","ColorIndex","LineCount","MeshCount","pushLayers","urlPre","substring","lastIndexOf","path","loadproc","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","__webpack_exports__","O","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","every","r","d","definition","o","defineProperty","enumerable","get","f","chunkId","Promise","all","reduce","promises","u","g","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","call","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","p","installedChunks","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop"],"sourceRoot":""}