/*! For license information please see CadEngine.js.LICENSE.txt */
var CadEngine;
(() => {
  'use strict';
  var e = {
    m: {},
    d: (t, i) => {
      for (var n in i) e.o(i, n) && !e.o(t, n) && Object.defineProperty(t, n, { enumerable: !0, get: i[n] });
    },
    u: (e) => e + '.CadEngine.js',
  };
  (e.g = (function () {
    if ('object' == typeof globalThis) return globalThis;
    try {
      return this || new Function('return this')();
    } catch (e) {
      if ('object' == typeof window) return window;
    }
  })()),
    (e.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
    (e.r = (e) => {
      'undefined' != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }),
        Object.defineProperty(e, '__esModule', { value: !0 });
    }),
    (() => {
      var t;
      e.g.importScripts && (t = e.g.location + '');
      var i = e.g.document;
      if (!t && i && (i.currentScript && (t = i.currentScript.src), !t)) {
        var n = i.getElementsByTagName('script');
        n.length && (t = n[n.length - 1].src);
      }
      if (!t) throw new Error('Automatic publicPath is not supported in this browser');
      (t = t
        .replace(/#.*$/, '')
        .replace(/\?.*$/, '')
        .replace(/\/[^\/]+$/, '/')),
        (e.p = t);
    })(),
    (e.b = document.baseURI || self.location.href);
  var t = {};
  (() => {
    e.r(t),
      e.d(t, {
        Box3: () => Re,
        Box3Helper: () => Rl,
        BufferAttribute: () => Zt,
        BufferGeometry: () => ai,
        CadEngine: () => yu,
        CameraControls: () => qh,
        Color: () => ve,
        DBEntity: () => fc,
        DbLayer: () => vu,
        DbLine: () => gc,
        DbMesh: () => _c,
        DrawManager: () => gu,
        DrawOperateState: () => nu,
        DrawOperationLine: () => pu,
        IBPCad3DEngined: () => Mu,
        LoadManager: () => Xh,
        Material: () => Wt,
        MaterialManager: () => bc,
        Matrix4: () => ot,
        Mesh: () => wi,
        MeshPhongMaterial: () => Lo,
        ModelManager: () => Mc,
        SceneManager: () => dc,
        SelectionManager: () => su,
        Sphere: () => $e,
        SpriteMaterial: () => Cr,
        TextureLoader: () => $o,
        Uint32BufferAttribute: () => Kt,
        Vector2: () => se,
        Vector3: () => Pe,
        ViewManager: () => hc,
        generateUUID: () => yc,
      });
    class i {
      constructor(e) {
        this.m_context = e;
      }
    }
    const n = '142',
      s = 100,
      r = 301,
      a = 302,
      o = 303,
      l = 304,
      h = 306,
      c = 1e3,
      u = 1001,
      d = 1002,
      m = 1003,
      p = 1004,
      f = 1005,
      g = 1006,
      _ = 1007,
      v = 1008,
      x = 1009,
      y = 1014,
      M = 1015,
      b = 1016,
      S = 1020,
      w = 1023,
      A = 1026,
      T = 1027,
      E = 33776,
      L = 33777,
      C = 33778,
      P = 33779,
      D = 2300,
      I = 2301,
      R = 2302,
      O = 2400,
      N = 2401,
      z = 2402,
      F = 3e3,
      k = 3001,
      U = 'srgb',
      B = 'srgb-linear',
      G = 7680,
      V = 35044,
      H = '300 es',
      j = 1035;
    class W {
      addEventListener(e, t) {
        void 0 === this._listeners && (this._listeners = {});
        const i = this._listeners;
        void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t);
      }
      hasEventListener(e, t) {
        if (void 0 === this._listeners) return !1;
        const i = this._listeners;
        return void 0 !== i[e] && -1 !== i[e].indexOf(t);
      }
      removeEventListener(e, t) {
        if (void 0 === this._listeners) return;
        const i = this._listeners[e];
        if (void 0 !== i) {
          const e = i.indexOf(t);
          -1 !== e && i.splice(e, 1);
        }
      }
      dispatchEvent(e) {
        if (void 0 === this._listeners) return;
        const t = this._listeners[e.type];
        if (void 0 !== t) {
          e.target = this;
          const i = t.slice(0);
          for (let t = 0, n = i.length; t < n; t++) i[t].call(this, e);
          e.target = null;
        }
      }
    }
    const X = [
      '00',
      '01',
      '02',
      '03',
      '04',
      '05',
      '06',
      '07',
      '08',
      '09',
      '0a',
      '0b',
      '0c',
      '0d',
      '0e',
      '0f',
      '10',
      '11',
      '12',
      '13',
      '14',
      '15',
      '16',
      '17',
      '18',
      '19',
      '1a',
      '1b',
      '1c',
      '1d',
      '1e',
      '1f',
      '20',
      '21',
      '22',
      '23',
      '24',
      '25',
      '26',
      '27',
      '28',
      '29',
      '2a',
      '2b',
      '2c',
      '2d',
      '2e',
      '2f',
      '30',
      '31',
      '32',
      '33',
      '34',
      '35',
      '36',
      '37',
      '38',
      '39',
      '3a',
      '3b',
      '3c',
      '3d',
      '3e',
      '3f',
      '40',
      '41',
      '42',
      '43',
      '44',
      '45',
      '46',
      '47',
      '48',
      '49',
      '4a',
      '4b',
      '4c',
      '4d',
      '4e',
      '4f',
      '50',
      '51',
      '52',
      '53',
      '54',
      '55',
      '56',
      '57',
      '58',
      '59',
      '5a',
      '5b',
      '5c',
      '5d',
      '5e',
      '5f',
      '60',
      '61',
      '62',
      '63',
      '64',
      '65',
      '66',
      '67',
      '68',
      '69',
      '6a',
      '6b',
      '6c',
      '6d',
      '6e',
      '6f',
      '70',
      '71',
      '72',
      '73',
      '74',
      '75',
      '76',
      '77',
      '78',
      '79',
      '7a',
      '7b',
      '7c',
      '7d',
      '7e',
      '7f',
      '80',
      '81',
      '82',
      '83',
      '84',
      '85',
      '86',
      '87',
      '88',
      '89',
      '8a',
      '8b',
      '8c',
      '8d',
      '8e',
      '8f',
      '90',
      '91',
      '92',
      '93',
      '94',
      '95',
      '96',
      '97',
      '98',
      '99',
      '9a',
      '9b',
      '9c',
      '9d',
      '9e',
      '9f',
      'a0',
      'a1',
      'a2',
      'a3',
      'a4',
      'a5',
      'a6',
      'a7',
      'a8',
      'a9',
      'aa',
      'ab',
      'ac',
      'ad',
      'ae',
      'af',
      'b0',
      'b1',
      'b2',
      'b3',
      'b4',
      'b5',
      'b6',
      'b7',
      'b8',
      'b9',
      'ba',
      'bb',
      'bc',
      'bd',
      'be',
      'bf',
      'c0',
      'c1',
      'c2',
      'c3',
      'c4',
      'c5',
      'c6',
      'c7',
      'c8',
      'c9',
      'ca',
      'cb',
      'cc',
      'cd',
      'ce',
      'cf',
      'd0',
      'd1',
      'd2',
      'd3',
      'd4',
      'd5',
      'd6',
      'd7',
      'd8',
      'd9',
      'da',
      'db',
      'dc',
      'dd',
      'de',
      'df',
      'e0',
      'e1',
      'e2',
      'e3',
      'e4',
      'e5',
      'e6',
      'e7',
      'e8',
      'e9',
      'ea',
      'eb',
      'ec',
      'ed',
      'ee',
      'ef',
      'f0',
      'f1',
      'f2',
      'f3',
      'f4',
      'f5',
      'f6',
      'f7',
      'f8',
      'f9',
      'fa',
      'fb',
      'fc',
      'fd',
      'fe',
      'ff',
    ];
    let q = 1234567;
    const Y = Math.PI / 180,
      Z = 180 / Math.PI;
    function J() {
      const e = (4294967295 * Math.random()) | 0,
        t = (4294967295 * Math.random()) | 0,
        i = (4294967295 * Math.random()) | 0,
        n = (4294967295 * Math.random()) | 0;
      return (
        X[255 & e] +
        X[(e >> 8) & 255] +
        X[(e >> 16) & 255] +
        X[(e >> 24) & 255] +
        '-' +
        X[255 & t] +
        X[(t >> 8) & 255] +
        '-' +
        X[((t >> 16) & 15) | 64] +
        X[(t >> 24) & 255] +
        '-' +
        X[(63 & i) | 128] +
        X[(i >> 8) & 255] +
        '-' +
        X[(i >> 16) & 255] +
        X[(i >> 24) & 255] +
        X[255 & n] +
        X[(n >> 8) & 255] +
        X[(n >> 16) & 255] +
        X[(n >> 24) & 255]
      ).toLowerCase();
    }
    function K(e, t, i) {
      return Math.max(t, Math.min(i, e));
    }
    function $(e, t) {
      return ((e % t) + t) % t;
    }
    function Q(e, t, i) {
      return (1 - i) * e + i * t;
    }
    function ee(e) {
      return 0 == (e & (e - 1)) && 0 !== e;
    }
    function te(e) {
      return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
    }
    function ie(e) {
      return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
    }
    var ne = Object.freeze({
      __proto__: null,
      DEG2RAD: Y,
      RAD2DEG: Z,
      generateUUID: J,
      clamp: K,
      euclideanModulo: $,
      mapLinear: function (e, t, i, n, s) {
        return n + ((e - t) * (s - n)) / (i - t);
      },
      inverseLerp: function (e, t, i) {
        return e !== t ? (i - e) / (t - e) : 0;
      },
      lerp: Q,
      damp: function (e, t, i, n) {
        return Q(e, t, 1 - Math.exp(-i * n));
      },
      pingpong: function (e, t = 1) {
        return t - Math.abs($(e, 2 * t) - t);
      },
      smoothstep: function (e, t, i) {
        return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e);
      },
      smootherstep: function (e, t, i) {
        return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10);
      },
      randInt: function (e, t) {
        return e + Math.floor(Math.random() * (t - e + 1));
      },
      randFloat: function (e, t) {
        return e + Math.random() * (t - e);
      },
      randFloatSpread: function (e) {
        return e * (0.5 - Math.random());
      },
      seededRandom: function (e) {
        void 0 !== e && (q = e);
        let t = (q += 1831565813);
        return (
          (t = Math.imul(t ^ (t >>> 15), 1 | t)),
          (t ^= t + Math.imul(t ^ (t >>> 7), 61 | t)),
          ((t ^ (t >>> 14)) >>> 0) / 4294967296
        );
      },
      degToRad: function (e) {
        return e * Y;
      },
      radToDeg: function (e) {
        return e * Z;
      },
      isPowerOfTwo: ee,
      ceilPowerOfTwo: te,
      floorPowerOfTwo: ie,
      setQuaternionFromProperEuler: function (e, t, i, n, s) {
        const r = Math.cos,
          a = Math.sin,
          o = r(i / 2),
          l = a(i / 2),
          h = r((t + n) / 2),
          c = a((t + n) / 2),
          u = r((t - n) / 2),
          d = a((t - n) / 2),
          m = r((n - t) / 2),
          p = a((n - t) / 2);
        switch (s) {
          case 'XYX':
            e.set(o * c, l * u, l * d, o * h);
            break;
          case 'YZY':
            e.set(l * d, o * c, l * u, o * h);
            break;
          case 'ZXZ':
            e.set(l * u, l * d, o * c, o * h);
            break;
          case 'XZX':
            e.set(o * c, l * p, l * m, o * h);
            break;
          case 'YXY':
            e.set(l * m, o * c, l * p, o * h);
            break;
          case 'ZYZ':
            e.set(l * p, l * m, o * c, o * h);
        }
      },
      normalize: function (e, t) {
        switch (t.constructor) {
          case Float32Array:
            return e;
          case Uint16Array:
            return Math.round(65535 * e);
          case Uint8Array:
            return Math.round(255 * e);
          case Int16Array:
            return Math.round(32767 * e);
          case Int8Array:
            return Math.round(127 * e);
          default:
            throw new Error('Invalid component type.');
        }
      },
      denormalize: function (e, t) {
        switch (t.constructor) {
          case Float32Array:
            return e;
          case Uint16Array:
            return e / 65535;
          case Uint8Array:
            return e / 255;
          case Int16Array:
            return Math.max(e / 32767, -1);
          case Int8Array:
            return Math.max(e / 127, -1);
          default:
            throw new Error('Invalid component type.');
        }
      },
    });
    class se {
      constructor(e = 0, t = 0) {
        (se.prototype.isVector2 = !0), (this.x = e), (this.y = t);
      }
      get width() {
        return this.x;
      }
      set width(e) {
        this.x = e;
      }
      get height() {
        return this.y;
      }
      set height(e) {
        this.y = e;
      }
      set(e, t) {
        return (this.x = e), (this.y = t), this;
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          default:
            throw new Error('index is out of range: ' + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error('index is out of range: ' + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(e) {
        return (this.x = e.x), (this.y = e.y), this;
      }
      add(e, t) {
        return void 0 !== t ? this.addVectors(e, t) : ((this.x += e.x), (this.y += e.y), this);
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), this;
      }
      addVectors(e, t) {
        return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
      }
      addScaledVector(e, t) {
        return (this.x += e.x * t), (this.y += e.y * t), this;
      }
      sub(e, t) {
        return void 0 !== t ? this.subVectors(e, t) : ((this.x -= e.x), (this.y -= e.y), this);
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), this;
      }
      subVectors(e, t) {
        return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
      }
      multiply(e) {
        return (this.x *= e.x), (this.y *= e.y), this;
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), this;
      }
      divide(e) {
        return (this.x /= e.x), (this.y /= e.y), this;
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      applyMatrix3(e) {
        const t = this.x,
          i = this.y,
          n = e.elements;
        return (this.x = n[0] * t + n[3] * i + n[6]), (this.y = n[1] * t + n[4] * i + n[7]), this;
      }
      min(e) {
        return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this;
      }
      max(e) {
        return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this;
      }
      clamp(e, t) {
        return (this.x = Math.max(e.x, Math.min(t.x, this.x))), (this.y = Math.max(e.y, Math.min(t.y, this.y))), this;
      }
      clampScalar(e, t) {
        return (this.x = Math.max(e, Math.min(t, this.x))), (this.y = Math.max(e, Math.min(t, this.y))), this;
      }
      clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
      }
      floor() {
        return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
      }
      ceil() {
        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
      }
      round() {
        return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), this;
      }
      dot(e) {
        return this.x * e.x + this.y * e.y;
      }
      cross(e) {
        return this.x * e.y - this.y * e.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }
      distanceToSquared(e) {
        const t = this.x - e.x,
          i = this.y - e.y;
        return t * t + i * i;
      }
      manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
      }
      lerpVectors(e, t, i) {
        return (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this;
      }
      equals(e) {
        return e.x === this.x && e.y === this.y;
      }
      fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), e;
      }
      fromBufferAttribute(e, t, i) {
        return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
      }
      rotateAround(e, t) {
        const i = Math.cos(t),
          n = Math.sin(t),
          s = this.x - e.x,
          r = this.y - e.y;
        return (this.x = s * i - r * n + e.x), (this.y = s * n + r * i + e.y), this;
      }
      random() {
        return (this.x = Math.random()), (this.y = Math.random()), this;
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y;
      }
    }
    class re {
      constructor() {
        (re.prototype.isMatrix3 = !0), (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
      }
      set(e, t, i, n, s, r, a, o, l) {
        const h = this.elements;
        return (
          (h[0] = e),
          (h[1] = n),
          (h[2] = a),
          (h[3] = t),
          (h[4] = s),
          (h[5] = o),
          (h[6] = i),
          (h[7] = r),
          (h[8] = l),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      }
      copy(e) {
        const t = this.elements,
          i = e.elements;
        return (
          (t[0] = i[0]),
          (t[1] = i[1]),
          (t[2] = i[2]),
          (t[3] = i[3]),
          (t[4] = i[4]),
          (t[5] = i[5]),
          (t[6] = i[6]),
          (t[7] = i[7]),
          (t[8] = i[8]),
          this
        );
      }
      extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
      }
      setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
      }
      multiply(e) {
        return this.multiplyMatrices(this, e);
      }
      premultiply(e) {
        return this.multiplyMatrices(e, this);
      }
      multiplyMatrices(e, t) {
        const i = e.elements,
          n = t.elements,
          s = this.elements,
          r = i[0],
          a = i[3],
          o = i[6],
          l = i[1],
          h = i[4],
          c = i[7],
          u = i[2],
          d = i[5],
          m = i[8],
          p = n[0],
          f = n[3],
          g = n[6],
          _ = n[1],
          v = n[4],
          x = n[7],
          y = n[2],
          M = n[5],
          b = n[8];
        return (
          (s[0] = r * p + a * _ + o * y),
          (s[3] = r * f + a * v + o * M),
          (s[6] = r * g + a * x + o * b),
          (s[1] = l * p + h * _ + c * y),
          (s[4] = l * f + h * v + c * M),
          (s[7] = l * g + h * x + c * b),
          (s[2] = u * p + d * _ + m * y),
          (s[5] = u * f + d * v + m * M),
          (s[8] = u * g + d * x + m * b),
          this
        );
      }
      multiplyScalar(e) {
        const t = this.elements;
        return (
          (t[0] *= e),
          (t[3] *= e),
          (t[6] *= e),
          (t[1] *= e),
          (t[4] *= e),
          (t[7] *= e),
          (t[2] *= e),
          (t[5] *= e),
          (t[8] *= e),
          this
        );
      }
      determinant() {
        const e = this.elements,
          t = e[0],
          i = e[1],
          n = e[2],
          s = e[3],
          r = e[4],
          a = e[5],
          o = e[6],
          l = e[7],
          h = e[8];
        return t * r * h - t * a * l - i * s * h + i * a * o + n * s * l - n * r * o;
      }
      invert() {
        const e = this.elements,
          t = e[0],
          i = e[1],
          n = e[2],
          s = e[3],
          r = e[4],
          a = e[5],
          o = e[6],
          l = e[7],
          h = e[8],
          c = h * r - a * l,
          u = a * o - h * s,
          d = l * s - r * o,
          m = t * c + i * u + n * d;
        if (0 === m) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const p = 1 / m;
        return (
          (e[0] = c * p),
          (e[1] = (n * l - h * i) * p),
          (e[2] = (a * i - n * r) * p),
          (e[3] = u * p),
          (e[4] = (h * t - n * o) * p),
          (e[5] = (n * s - a * t) * p),
          (e[6] = d * p),
          (e[7] = (i * o - l * t) * p),
          (e[8] = (r * t - i * s) * p),
          this
        );
      }
      transpose() {
        let e;
        const t = this.elements;
        return (
          (e = t[1]),
          (t[1] = t[3]),
          (t[3] = e),
          (e = t[2]),
          (t[2] = t[6]),
          (t[6] = e),
          (e = t[5]),
          (t[5] = t[7]),
          (t[7] = e),
          this
        );
      }
      getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose();
      }
      transposeIntoArray(e) {
        const t = this.elements;
        return (
          (e[0] = t[0]),
          (e[1] = t[3]),
          (e[2] = t[6]),
          (e[3] = t[1]),
          (e[4] = t[4]),
          (e[5] = t[7]),
          (e[6] = t[2]),
          (e[7] = t[5]),
          (e[8] = t[8]),
          this
        );
      }
      setUvTransform(e, t, i, n, s, r, a) {
        const o = Math.cos(s),
          l = Math.sin(s);
        return (
          this.set(i * o, i * l, -i * (o * r + l * a) + r + e, -n * l, n * o, -n * (-l * r + o * a) + a + t, 0, 0, 1),
          this
        );
      }
      scale(e, t) {
        const i = this.elements;
        return (i[0] *= e), (i[3] *= e), (i[6] *= e), (i[1] *= t), (i[4] *= t), (i[7] *= t), this;
      }
      rotate(e) {
        const t = Math.cos(e),
          i = Math.sin(e),
          n = this.elements,
          s = n[0],
          r = n[3],
          a = n[6],
          o = n[1],
          l = n[4],
          h = n[7];
        return (
          (n[0] = t * s + i * o),
          (n[3] = t * r + i * l),
          (n[6] = t * a + i * h),
          (n[1] = -i * s + t * o),
          (n[4] = -i * r + t * l),
          (n[7] = -i * a + t * h),
          this
        );
      }
      translate(e, t) {
        const i = this.elements;
        return (
          (i[0] += e * i[2]),
          (i[3] += e * i[5]),
          (i[6] += e * i[8]),
          (i[1] += t * i[2]),
          (i[4] += t * i[5]),
          (i[7] += t * i[8]),
          this
        );
      }
      equals(e) {
        const t = this.elements,
          i = e.elements;
        for (let e = 0; e < 9; e++) if (t[e] !== i[e]) return !1;
        return !0;
      }
      fromArray(e, t = 0) {
        for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
        return this;
      }
      toArray(e = [], t = 0) {
        const i = this.elements;
        return (
          (e[t] = i[0]),
          (e[t + 1] = i[1]),
          (e[t + 2] = i[2]),
          (e[t + 3] = i[3]),
          (e[t + 4] = i[4]),
          (e[t + 5] = i[5]),
          (e[t + 6] = i[6]),
          (e[t + 7] = i[7]),
          (e[t + 8] = i[8]),
          e
        );
      }
      clone() {
        return new this.constructor().fromArray(this.elements);
      }
    }
    function ae(e) {
      for (let t = e.length - 1; t >= 0; --t) if (e[t] > 65535) return !0;
      return !1;
    }
    Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array;
    function oe(e) {
      return document.createElementNS('http://www.w3.org/1999/xhtml', e);
    }
    function le(e) {
      return e < 0.04045 ? 0.0773993808 * e : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
    }
    function he(e) {
      return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
    }
    const ce = { [U]: { [B]: le }, [B]: { [U]: he } },
      ue = {
        legacyMode: !0,
        get workingColorSpace() {
          return B;
        },
        set workingColorSpace(e) {},
        convert: function (e, t, i) {
          if (this.legacyMode || t === i || !t || !i) return e;
          if (ce[t] && void 0 !== ce[t][i]) {
            const n = ce[t][i];
            return (e.r = n(e.r)), (e.g = n(e.g)), (e.b = n(e.b)), e;
          }
          throw new Error('Unsupported color space conversion.');
        },
        fromWorkingColorSpace: function (e, t) {
          return this.convert(e, this.workingColorSpace, t);
        },
        toWorkingColorSpace: function (e, t) {
          return this.convert(e, t, this.workingColorSpace);
        },
      },
      de = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
      },
      me = { r: 0, g: 0, b: 0 },
      pe = { h: 0, s: 0, l: 0 },
      fe = { h: 0, s: 0, l: 0 };
    function ge(e, t, i) {
      return (
        i < 0 && (i += 1),
        i > 1 && (i -= 1),
        i < 1 / 6 ? e + 6 * (t - e) * i : i < 0.5 ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e
      );
    }
    function _e(e, t) {
      return (t.r = e.r), (t.g = e.g), (t.b = e.b), t;
    }
    class ve {
      constructor(e, t, i) {
        return (
          (this.isColor = !0),
          (this.r = 1),
          (this.g = 1),
          (this.b = 1),
          void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i)
        );
      }
      set(e) {
        return (
          e && e.isColor
            ? this.copy(e)
            : 'number' == typeof e
            ? this.setHex(e)
            : 'string' == typeof e && this.setStyle(e),
          this
        );
      }
      setScalar(e) {
        return (this.r = e), (this.g = e), (this.b = e), this;
      }
      setHex(e, t = 'srgb') {
        return (
          (e = Math.floor(e)),
          (this.r = ((e >> 16) & 255) / 255),
          (this.g = ((e >> 8) & 255) / 255),
          (this.b = (255 & e) / 255),
          ue.toWorkingColorSpace(this, t),
          this
        );
      }
      setRGB(e, t, i, n = 'srgb-linear') {
        return (this.r = e), (this.g = t), (this.b = i), ue.toWorkingColorSpace(this, n), this;
      }
      setHSL(e, t, i, n = 'srgb-linear') {
        if (((e = $(e, 1)), (t = K(t, 0, 1)), (i = K(i, 0, 1)), 0 === t)) this.r = this.g = this.b = i;
        else {
          const n = i <= 0.5 ? i * (1 + t) : i + t - i * t,
            s = 2 * i - n;
          (this.r = ge(s, n, e + 1 / 3)), (this.g = ge(s, n, e)), (this.b = ge(s, n, e - 1 / 3));
        }
        return ue.toWorkingColorSpace(this, n), this;
      }
      setStyle(e, t = 'srgb') {
        function i(e) {
          void 0 !== e && parseFloat(e);
        }
        let n;
        if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
          let e;
          const s = n[1],
            r = n[2];
          switch (s) {
            case 'rgb':
            case 'rgba':
              if ((e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)))
                return (
                  (this.r = Math.min(255, parseInt(e[1], 10)) / 255),
                  (this.g = Math.min(255, parseInt(e[2], 10)) / 255),
                  (this.b = Math.min(255, parseInt(e[3], 10)) / 255),
                  ue.toWorkingColorSpace(this, t),
                  i(e[4]),
                  this
                );
              if ((e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)))
                return (
                  (this.r = Math.min(100, parseInt(e[1], 10)) / 100),
                  (this.g = Math.min(100, parseInt(e[2], 10)) / 100),
                  (this.b = Math.min(100, parseInt(e[3], 10)) / 100),
                  ue.toWorkingColorSpace(this, t),
                  i(e[4]),
                  this
                );
              break;
            case 'hsl':
            case 'hsla':
              if ((e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))) {
                const n = parseFloat(e[1]) / 360,
                  s = parseInt(e[2], 10) / 100,
                  r = parseInt(e[3], 10) / 100;
                return i(e[4]), this.setHSL(n, s, r, t);
              }
          }
        } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
          const e = n[1],
            i = e.length;
          if (3 === i)
            return (
              (this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255),
              (this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255),
              (this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255),
              ue.toWorkingColorSpace(this, t),
              this
            );
          if (6 === i)
            return (
              (this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255),
              (this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255),
              (this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255),
              ue.toWorkingColorSpace(this, t),
              this
            );
        }
        return e && e.length > 0 ? this.setColorName(e, t) : this;
      }
      setColorName(e, t = 'srgb') {
        const i = de[e.toLowerCase()];
        return void 0 !== i && this.setHex(i, t), this;
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(e) {
        return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
      }
      copySRGBToLinear(e) {
        return (this.r = le(e.r)), (this.g = le(e.g)), (this.b = le(e.b)), this;
      }
      copyLinearToSRGB(e) {
        return (this.r = he(e.r)), (this.g = he(e.g)), (this.b = he(e.b)), this;
      }
      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }
      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }
      getHex(e = 'srgb') {
        return (
          ue.fromWorkingColorSpace(_e(this, me), e),
          (K(255 * me.r, 0, 255) << 16) ^ (K(255 * me.g, 0, 255) << 8) ^ (K(255 * me.b, 0, 255) << 0)
        );
      }
      getHexString(e = 'srgb') {
        return ('000000' + this.getHex(e).toString(16)).slice(-6);
      }
      getHSL(e, t = 'srgb-linear') {
        ue.fromWorkingColorSpace(_e(this, me), t);
        const i = me.r,
          n = me.g,
          s = me.b,
          r = Math.max(i, n, s),
          a = Math.min(i, n, s);
        let o, l;
        const h = (a + r) / 2;
        if (a === r) (o = 0), (l = 0);
        else {
          const e = r - a;
          switch (((l = h <= 0.5 ? e / (r + a) : e / (2 - r - a)), r)) {
            case i:
              o = (n - s) / e + (n < s ? 6 : 0);
              break;
            case n:
              o = (s - i) / e + 2;
              break;
            case s:
              o = (i - n) / e + 4;
          }
          o /= 6;
        }
        return (e.h = o), (e.s = l), (e.l = h), e;
      }
      getRGB(e, t = 'srgb-linear') {
        return ue.fromWorkingColorSpace(_e(this, me), t), (e.r = me.r), (e.g = me.g), (e.b = me.b), e;
      }
      getStyle(e = 'srgb') {
        return (
          ue.fromWorkingColorSpace(_e(this, me), e),
          e !== U
            ? `color(${e} ${me.r} ${me.g} ${me.b})`
            : `rgb(${(255 * me.r) | 0},${(255 * me.g) | 0},${(255 * me.b) | 0})`
        );
      }
      offsetHSL(e, t, i) {
        return this.getHSL(pe), (pe.h += e), (pe.s += t), (pe.l += i), this.setHSL(pe.h, pe.s, pe.l), this;
      }
      add(e) {
        return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
      }
      addColors(e, t) {
        return (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this;
      }
      addScalar(e) {
        return (this.r += e), (this.g += e), (this.b += e), this;
      }
      sub(e) {
        return (
          (this.r = Math.max(0, this.r - e.r)),
          (this.g = Math.max(0, this.g - e.g)),
          (this.b = Math.max(0, this.b - e.b)),
          this
        );
      }
      multiply(e) {
        return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
      }
      multiplyScalar(e) {
        return (this.r *= e), (this.g *= e), (this.b *= e), this;
      }
      lerp(e, t) {
        return (this.r += (e.r - this.r) * t), (this.g += (e.g - this.g) * t), (this.b += (e.b - this.b) * t), this;
      }
      lerpColors(e, t, i) {
        return (
          (this.r = e.r + (t.r - e.r) * i), (this.g = e.g + (t.g - e.g) * i), (this.b = e.b + (t.b - e.b) * i), this
        );
      }
      lerpHSL(e, t) {
        this.getHSL(pe), e.getHSL(fe);
        const i = Q(pe.h, fe.h, t),
          n = Q(pe.s, fe.s, t),
          s = Q(pe.l, fe.l, t);
        return this.setHSL(i, n, s), this;
      }
      equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b;
      }
      fromArray(e, t = 0) {
        return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
      }
      fromBufferAttribute(e, t) {
        return (
          (this.r = e.getX(t)),
          (this.g = e.getY(t)),
          (this.b = e.getZ(t)),
          !0 === e.normalized && ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
          this
        );
      }
      toJSON() {
        return this.getHex();
      }
      *[Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b;
      }
    }
    let xe;
    ve.NAMES = de;
    class ye {
      static getDataURL(e) {
        if (/^data:/i.test(e.src)) return e.src;
        if ('undefined' == typeof HTMLCanvasElement) return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;
        else {
          void 0 === xe && (xe = oe('canvas')), (xe.width = e.width), (xe.height = e.height);
          const i = xe.getContext('2d');
          e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), (t = xe);
        }
        return t.width > 2048 || t.height > 2048 ? t.toDataURL('image/jpeg', 0.6) : t.toDataURL('image/png');
      }
      static sRGBToLinear(e) {
        if (
          ('undefined' != typeof HTMLImageElement && e instanceof HTMLImageElement) ||
          ('undefined' != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement) ||
          ('undefined' != typeof ImageBitmap && e instanceof ImageBitmap)
        ) {
          const t = oe('canvas');
          (t.width = e.width), (t.height = e.height);
          const i = t.getContext('2d');
          i.drawImage(e, 0, 0, e.width, e.height);
          const n = i.getImageData(0, 0, e.width, e.height),
            s = n.data;
          for (let e = 0; e < s.length; e++) s[e] = 255 * le(s[e] / 255);
          return i.putImageData(n, 0, 0), t;
        }
        if (e.data) {
          const t = e.data.slice(0);
          for (let e = 0; e < t.length; e++)
            t instanceof Uint8Array || t instanceof Uint8ClampedArray
              ? (t[e] = Math.floor(255 * le(t[e] / 255)))
              : (t[e] = le(t[e]));
          return { data: t, width: e.width, height: e.height };
        }
        return e;
      }
    }
    class Me {
      constructor(e = null) {
        (this.isSource = !0), (this.uuid = J()), (this.data = e), (this.version = 0);
      }
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
      toJSON(e) {
        const t = void 0 === e || 'string' == typeof e;
        if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
        const i = { uuid: this.uuid, url: '' },
          n = this.data;
        if (null !== n) {
          let e;
          if (Array.isArray(n)) {
            e = [];
            for (let t = 0, i = n.length; t < i; t++) n[t].isDataTexture ? e.push(be(n[t].image)) : e.push(be(n[t]));
          } else e = be(n);
          i.url = e;
        }
        return t || (e.images[this.uuid] = i), i;
      }
    }
    function be(e) {
      return ('undefined' != typeof HTMLImageElement && e instanceof HTMLImageElement) ||
        ('undefined' != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement) ||
        ('undefined' != typeof ImageBitmap && e instanceof ImageBitmap)
        ? ye.getDataURL(e)
        : e.data
        ? { data: Array.from(e.data), width: e.width, height: e.height, type: e.data.constructor.name }
        : {};
    }
    let Se = 0;
    class we extends W {
      constructor(
        e = we.DEFAULT_IMAGE,
        t = we.DEFAULT_MAPPING,
        i = 1001,
        n = 1001,
        s = 1006,
        r = 1008,
        a = 1023,
        o = 1009,
        l = 1,
        h = 3e3,
      ) {
        super(),
          (this.isTexture = !0),
          Object.defineProperty(this, 'id', { value: Se++ }),
          (this.uuid = J()),
          (this.name = ''),
          (this.source = new Me(e)),
          (this.mipmaps = []),
          (this.mapping = t),
          (this.wrapS = i),
          (this.wrapT = n),
          (this.magFilter = s),
          (this.minFilter = r),
          (this.anisotropy = l),
          (this.format = a),
          (this.internalFormat = null),
          (this.type = o),
          (this.offset = new se(0, 0)),
          (this.repeat = new se(1, 1)),
          (this.center = new se(0, 0)),
          (this.rotation = 0),
          (this.matrixAutoUpdate = !0),
          (this.matrix = new re()),
          (this.generateMipmaps = !0),
          (this.premultiplyAlpha = !1),
          (this.flipY = !0),
          (this.unpackAlignment = 4),
          (this.encoding = h),
          (this.userData = {}),
          (this.version = 0),
          (this.onUpdate = null),
          (this.isRenderTargetTexture = !1),
          (this.needsPMREMUpdate = !1);
      }
      get image() {
        return this.source.data;
      }
      set image(e) {
        this.source.data = e;
      }
      updateMatrix() {
        this.matrix.setUvTransform(
          this.offset.x,
          this.offset.y,
          this.repeat.x,
          this.repeat.y,
          this.rotation,
          this.center.x,
          this.center.y,
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return (
          (this.name = e.name),
          (this.source = e.source),
          (this.mipmaps = e.mipmaps.slice(0)),
          (this.mapping = e.mapping),
          (this.wrapS = e.wrapS),
          (this.wrapT = e.wrapT),
          (this.magFilter = e.magFilter),
          (this.minFilter = e.minFilter),
          (this.anisotropy = e.anisotropy),
          (this.format = e.format),
          (this.internalFormat = e.internalFormat),
          (this.type = e.type),
          this.offset.copy(e.offset),
          this.repeat.copy(e.repeat),
          this.center.copy(e.center),
          (this.rotation = e.rotation),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          this.matrix.copy(e.matrix),
          (this.generateMipmaps = e.generateMipmaps),
          (this.premultiplyAlpha = e.premultiplyAlpha),
          (this.flipY = e.flipY),
          (this.unpackAlignment = e.unpackAlignment),
          (this.encoding = e.encoding),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          (this.needsUpdate = !0),
          this
        );
      }
      toJSON(e) {
        const t = void 0 === e || 'string' == typeof e;
        if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
        const i = {
          metadata: { version: 4.5, type: 'Texture', generator: 'Texture.toJSON' },
          uuid: this.uuid,
          name: this.name,
          image: this.source.toJSON(e).uuid,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment,
        };
        return (
          '{}' !== JSON.stringify(this.userData) && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i
        );
      }
      dispose() {
        this.dispatchEvent({ type: 'dispose' });
      }
      transformUv(e) {
        if (300 !== this.mapping) return e;
        if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
          switch (this.wrapS) {
            case c:
              e.x = e.x - Math.floor(e.x);
              break;
            case u:
              e.x = e.x < 0 ? 0 : 1;
              break;
            case d:
              1 === Math.abs(Math.floor(e.x) % 2) ? (e.x = Math.ceil(e.x) - e.x) : (e.x = e.x - Math.floor(e.x));
          }
        if (e.y < 0 || e.y > 1)
          switch (this.wrapT) {
            case c:
              e.y = e.y - Math.floor(e.y);
              break;
            case u:
              e.y = e.y < 0 ? 0 : 1;
              break;
            case d:
              1 === Math.abs(Math.floor(e.y) % 2) ? (e.y = Math.ceil(e.y) - e.y) : (e.y = e.y - Math.floor(e.y));
          }
        return this.flipY && (e.y = 1 - e.y), e;
      }
      set needsUpdate(e) {
        !0 === e && (this.version++, (this.source.needsUpdate = !0));
      }
    }
    (we.DEFAULT_IMAGE = null), (we.DEFAULT_MAPPING = 300);
    class Ae {
      constructor(e = 0, t = 0, i = 0, n = 1) {
        (Ae.prototype.isVector4 = !0), (this.x = e), (this.y = t), (this.z = i), (this.w = n);
      }
      get width() {
        return this.z;
      }
      set width(e) {
        this.z = e;
      }
      get height() {
        return this.w;
      }
      set height(e) {
        this.w = e;
      }
      set(e, t, i, n) {
        return (this.x = e), (this.y = t), (this.z = i), (this.w = n), this;
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setZ(e) {
        return (this.z = e), this;
      }
      setW(e) {
        return (this.w = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          case 2:
            this.z = t;
            break;
          case 3:
            this.w = t;
            break;
          default:
            throw new Error('index is out of range: ' + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error('index is out of range: ' + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(e) {
        return (this.x = e.x), (this.y = e.y), (this.z = e.z), (this.w = void 0 !== e.w ? e.w : 1), this;
      }
      add(e, t) {
        return void 0 !== t
          ? this.addVectors(e, t)
          : ((this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this);
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
      }
      addVectors(e, t) {
        return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), (this.w = e.w + t.w), this;
      }
      addScaledVector(e, t) {
        return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), (this.w += e.w * t), this;
      }
      sub(e, t) {
        return void 0 !== t
          ? this.subVectors(e, t)
          : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this);
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
      }
      subVectors(e, t) {
        return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), (this.w = e.w - t.w), this;
      }
      multiply(e) {
        return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this;
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
      }
      applyMatrix4(e) {
        const t = this.x,
          i = this.y,
          n = this.z,
          s = this.w,
          r = e.elements;
        return (
          (this.x = r[0] * t + r[4] * i + r[8] * n + r[12] * s),
          (this.y = r[1] * t + r[5] * i + r[9] * n + r[13] * s),
          (this.z = r[2] * t + r[6] * i + r[10] * n + r[14] * s),
          (this.w = r[3] * t + r[7] * i + r[11] * n + r[15] * s),
          this
        );
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return (
          t < 1e-4
            ? ((this.x = 1), (this.y = 0), (this.z = 0))
            : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
          this
        );
      }
      setAxisAngleFromRotationMatrix(e) {
        let t, i, n, s;
        const r = 0.01,
          a = 0.1,
          o = e.elements,
          l = o[0],
          h = o[4],
          c = o[8],
          u = o[1],
          d = o[5],
          m = o[9],
          p = o[2],
          f = o[6],
          g = o[10];
        if (Math.abs(h - u) < r && Math.abs(c - p) < r && Math.abs(m - f) < r) {
          if (Math.abs(h + u) < a && Math.abs(c + p) < a && Math.abs(m + f) < a && Math.abs(l + d + g - 3) < a)
            return this.set(1, 0, 0, 0), this;
          t = Math.PI;
          const e = (l + 1) / 2,
            o = (d + 1) / 2,
            _ = (g + 1) / 2,
            v = (h + u) / 4,
            x = (c + p) / 4,
            y = (m + f) / 4;
          return (
            e > o && e > _
              ? e < r
                ? ((i = 0), (n = 0.707106781), (s = 0.707106781))
                : ((i = Math.sqrt(e)), (n = v / i), (s = x / i))
              : o > _
              ? o < r
                ? ((i = 0.707106781), (n = 0), (s = 0.707106781))
                : ((n = Math.sqrt(o)), (i = v / n), (s = y / n))
              : _ < r
              ? ((i = 0.707106781), (n = 0.707106781), (s = 0))
              : ((s = Math.sqrt(_)), (i = x / s), (n = y / s)),
            this.set(i, n, s, t),
            this
          );
        }
        let _ = Math.sqrt((f - m) * (f - m) + (c - p) * (c - p) + (u - h) * (u - h));
        return (
          Math.abs(_) < 0.001 && (_ = 1),
          (this.x = (f - m) / _),
          (this.y = (c - p) / _),
          (this.z = (u - h) / _),
          (this.w = Math.acos((l + d + g - 1) / 2)),
          this
        );
      }
      min(e) {
        return (
          (this.x = Math.min(this.x, e.x)),
          (this.y = Math.min(this.y, e.y)),
          (this.z = Math.min(this.z, e.z)),
          (this.w = Math.min(this.w, e.w)),
          this
        );
      }
      max(e) {
        return (
          (this.x = Math.max(this.x, e.x)),
          (this.y = Math.max(this.y, e.y)),
          (this.z = Math.max(this.z, e.z)),
          (this.w = Math.max(this.w, e.w)),
          this
        );
      }
      clamp(e, t) {
        return (
          (this.x = Math.max(e.x, Math.min(t.x, this.x))),
          (this.y = Math.max(e.y, Math.min(t.y, this.y))),
          (this.z = Math.max(e.z, Math.min(t.z, this.z))),
          (this.w = Math.max(e.w, Math.min(t.w, this.w))),
          this
        );
      }
      clampScalar(e, t) {
        return (
          (this.x = Math.max(e, Math.min(t, this.x))),
          (this.y = Math.max(e, Math.min(t, this.y))),
          (this.z = Math.max(e, Math.min(t, this.z))),
          (this.w = Math.max(e, Math.min(t, this.w))),
          this
        );
      }
      clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          (this.w = Math.floor(this.w)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          (this.w = Math.ceil(this.w)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          (this.w = Math.round(this.w)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this;
      }
      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (
          (this.x += (e.x - this.x) * t),
          (this.y += (e.y - this.y) * t),
          (this.z += (e.z - this.z) * t),
          (this.w += (e.w - this.w) * t),
          this
        );
      }
      lerpVectors(e, t, i) {
        return (
          (this.x = e.x + (t.x - e.x) * i),
          (this.y = e.y + (t.y - e.y) * i),
          (this.z = e.z + (t.z - e.z) * i),
          (this.w = e.w + (t.w - e.w) * i),
          this
        );
      }
      equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
      }
      fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), (this.w = e[t + 3]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), (e[t + 3] = this.w), e;
      }
      fromBufferAttribute(e, t, i) {
        return (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), (this.w = e.getW(t)), this;
      }
      random() {
        return (
          (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), (this.w = Math.random()), this
        );
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w;
      }
    }
    class Te extends W {
      constructor(e, t, i = {}) {
        super(),
          (this.isWebGLRenderTarget = !0),
          (this.width = e),
          (this.height = t),
          (this.depth = 1),
          (this.scissor = new Ae(0, 0, e, t)),
          (this.scissorTest = !1),
          (this.viewport = new Ae(0, 0, e, t));
        const n = { width: e, height: t, depth: 1 };
        (this.texture = new we(
          n,
          i.mapping,
          i.wrapS,
          i.wrapT,
          i.magFilter,
          i.minFilter,
          i.format,
          i.type,
          i.anisotropy,
          i.encoding,
        )),
          (this.texture.isRenderTargetTexture = !0),
          (this.texture.flipY = !1),
          (this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps),
          (this.texture.internalFormat = void 0 !== i.internalFormat ? i.internalFormat : null),
          (this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : g),
          (this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer),
          (this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer),
          (this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null),
          (this.samples = void 0 !== i.samples ? i.samples : 0);
      }
      setSize(e, t, i = 1) {
        (this.width === e && this.height === t && this.depth === i) ||
          ((this.width = e),
          (this.height = t),
          (this.depth = i),
          (this.texture.image.width = e),
          (this.texture.image.height = t),
          (this.texture.image.depth = i),
          this.dispose()),
          this.viewport.set(0, 0, e, t),
          this.scissor.set(0, 0, e, t);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        (this.width = e.width),
          (this.height = e.height),
          (this.depth = e.depth),
          this.viewport.copy(e.viewport),
          (this.texture = e.texture.clone()),
          (this.texture.isRenderTargetTexture = !0);
        const t = Object.assign({}, e.texture.image);
        return (
          (this.texture.source = new Me(t)),
          (this.depthBuffer = e.depthBuffer),
          (this.stencilBuffer = e.stencilBuffer),
          null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
          (this.samples = e.samples),
          this
        );
      }
      dispose() {
        this.dispatchEvent({ type: 'dispose' });
      }
    }
    class Ee extends we {
      constructor(e = null, t = 1, i = 1, n = 1) {
        super(null),
          (this.isDataArrayTexture = !0),
          (this.image = { data: e, width: t, height: i, depth: n }),
          (this.magFilter = m),
          (this.minFilter = m),
          (this.wrapR = u),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1);
      }
    }
    class Le extends we {
      constructor(e = null, t = 1, i = 1, n = 1) {
        super(null),
          (this.isData3DTexture = !0),
          (this.image = { data: e, width: t, height: i, depth: n }),
          (this.magFilter = m),
          (this.minFilter = m),
          (this.wrapR = u),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1);
      }
    }
    class Ce {
      constructor(e = 0, t = 0, i = 0, n = 1) {
        (this.isQuaternion = !0), (this._x = e), (this._y = t), (this._z = i), (this._w = n);
      }
      static slerp(e, t, i, n) {
        return i.slerpQuaternions(e, t, n);
      }
      static slerpFlat(e, t, i, n, s, r, a) {
        let o = i[n + 0],
          l = i[n + 1],
          h = i[n + 2],
          c = i[n + 3];
        const u = s[r + 0],
          d = s[r + 1],
          m = s[r + 2],
          p = s[r + 3];
        if (0 === a) return (e[t + 0] = o), (e[t + 1] = l), (e[t + 2] = h), void (e[t + 3] = c);
        if (1 === a) return (e[t + 0] = u), (e[t + 1] = d), (e[t + 2] = m), void (e[t + 3] = p);
        if (c !== p || o !== u || l !== d || h !== m) {
          let e = 1 - a;
          const t = o * u + l * d + h * m + c * p,
            i = t >= 0 ? 1 : -1,
            n = 1 - t * t;
          if (n > Number.EPSILON) {
            const s = Math.sqrt(n),
              r = Math.atan2(s, t * i);
            (e = Math.sin(e * r) / s), (a = Math.sin(a * r) / s);
          }
          const s = a * i;
          if (((o = o * e + u * s), (l = l * e + d * s), (h = h * e + m * s), (c = c * e + p * s), e === 1 - a)) {
            const e = 1 / Math.sqrt(o * o + l * l + h * h + c * c);
            (o *= e), (l *= e), (h *= e), (c *= e);
          }
        }
        (e[t] = o), (e[t + 1] = l), (e[t + 2] = h), (e[t + 3] = c);
      }
      static multiplyQuaternionsFlat(e, t, i, n, s, r) {
        const a = i[n],
          o = i[n + 1],
          l = i[n + 2],
          h = i[n + 3],
          c = s[r],
          u = s[r + 1],
          d = s[r + 2],
          m = s[r + 3];
        return (
          (e[t] = a * m + h * c + o * d - l * u),
          (e[t + 1] = o * m + h * u + l * c - a * d),
          (e[t + 2] = l * m + h * d + a * u - o * c),
          (e[t + 3] = h * m - a * c - o * u - l * d),
          e
        );
      }
      get x() {
        return this._x;
      }
      set x(e) {
        (this._x = e), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(e) {
        (this._y = e), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(e) {
        (this._z = e), this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w(e) {
        (this._w = e), this._onChangeCallback();
      }
      set(e, t, i, n) {
        return (this._x = e), (this._y = t), (this._z = i), (this._w = n), this._onChangeCallback(), this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(e) {
        return (this._x = e.x), (this._y = e.y), (this._z = e.z), (this._w = e.w), this._onChangeCallback(), this;
      }
      setFromEuler(e, t) {
        if (!e || !e.isEuler)
          throw new Error(
            'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.',
          );
        const i = e._x,
          n = e._y,
          s = e._z,
          r = e._order,
          a = Math.cos,
          o = Math.sin,
          l = a(i / 2),
          h = a(n / 2),
          c = a(s / 2),
          u = o(i / 2),
          d = o(n / 2),
          m = o(s / 2);
        switch (r) {
          case 'XYZ':
            (this._x = u * h * c + l * d * m),
              (this._y = l * d * c - u * h * m),
              (this._z = l * h * m + u * d * c),
              (this._w = l * h * c - u * d * m);
            break;
          case 'YXZ':
            (this._x = u * h * c + l * d * m),
              (this._y = l * d * c - u * h * m),
              (this._z = l * h * m - u * d * c),
              (this._w = l * h * c + u * d * m);
            break;
          case 'ZXY':
            (this._x = u * h * c - l * d * m),
              (this._y = l * d * c + u * h * m),
              (this._z = l * h * m + u * d * c),
              (this._w = l * h * c - u * d * m);
            break;
          case 'ZYX':
            (this._x = u * h * c - l * d * m),
              (this._y = l * d * c + u * h * m),
              (this._z = l * h * m - u * d * c),
              (this._w = l * h * c + u * d * m);
            break;
          case 'YZX':
            (this._x = u * h * c + l * d * m),
              (this._y = l * d * c + u * h * m),
              (this._z = l * h * m - u * d * c),
              (this._w = l * h * c - u * d * m);
            break;
          case 'XZY':
            (this._x = u * h * c - l * d * m),
              (this._y = l * d * c - u * h * m),
              (this._z = l * h * m + u * d * c),
              (this._w = l * h * c + u * d * m);
        }
        return !1 !== t && this._onChangeCallback(), this;
      }
      setFromAxisAngle(e, t) {
        const i = t / 2,
          n = Math.sin(i);
        return (
          (this._x = e.x * n),
          (this._y = e.y * n),
          (this._z = e.z * n),
          (this._w = Math.cos(i)),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(e) {
        const t = e.elements,
          i = t[0],
          n = t[4],
          s = t[8],
          r = t[1],
          a = t[5],
          o = t[9],
          l = t[2],
          h = t[6],
          c = t[10],
          u = i + a + c;
        if (u > 0) {
          const e = 0.5 / Math.sqrt(u + 1);
          (this._w = 0.25 / e), (this._x = (h - o) * e), (this._y = (s - l) * e), (this._z = (r - n) * e);
        } else if (i > a && i > c) {
          const e = 2 * Math.sqrt(1 + i - a - c);
          (this._w = (h - o) / e), (this._x = 0.25 * e), (this._y = (n + r) / e), (this._z = (s + l) / e);
        } else if (a > c) {
          const e = 2 * Math.sqrt(1 + a - i - c);
          (this._w = (s - l) / e), (this._x = (n + r) / e), (this._y = 0.25 * e), (this._z = (o + h) / e);
        } else {
          const e = 2 * Math.sqrt(1 + c - i - a);
          (this._w = (r - n) / e), (this._x = (s + l) / e), (this._y = (o + h) / e), (this._z = 0.25 * e);
        }
        return this._onChangeCallback(), this;
      }
      setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return (
          i < Number.EPSILON
            ? ((i = 0),
              Math.abs(e.x) > Math.abs(e.z)
                ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
                : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
            : ((this._x = e.y * t.z - e.z * t.y),
              (this._y = e.z * t.x - e.x * t.z),
              (this._z = e.x * t.y - e.y * t.x),
              (this._w = i)),
          this.normalize()
        );
      }
      angleTo(e) {
        return 2 * Math.acos(Math.abs(K(this.dot(e), -1, 1)));
      }
      rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (0 === i) return this;
        const n = Math.min(1, t / i);
        return this.slerp(e, n), this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      invert() {
        return this.conjugate();
      }
      conjugate() {
        return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this;
      }
      dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
      }
      lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      }
      length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      }
      normalize() {
        let e = this.length();
        return (
          0 === e
            ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
            : ((e = 1 / e),
              (this._x = this._x * e),
              (this._y = this._y * e),
              (this._z = this._z * e),
              (this._w = this._w * e)),
          this._onChangeCallback(),
          this
        );
      }
      multiply(e, t) {
        return void 0 !== t ? this.multiplyQuaternions(e, t) : this.multiplyQuaternions(this, e);
      }
      premultiply(e) {
        return this.multiplyQuaternions(e, this);
      }
      multiplyQuaternions(e, t) {
        const i = e._x,
          n = e._y,
          s = e._z,
          r = e._w,
          a = t._x,
          o = t._y,
          l = t._z,
          h = t._w;
        return (
          (this._x = i * h + r * a + n * l - s * o),
          (this._y = n * h + r * o + s * a - i * l),
          (this._z = s * h + r * l + i * o - n * a),
          (this._w = r * h - i * a - n * o - s * l),
          this._onChangeCallback(),
          this
        );
      }
      slerp(e, t) {
        if (0 === t) return this;
        if (1 === t) return this.copy(e);
        const i = this._x,
          n = this._y,
          s = this._z,
          r = this._w;
        let a = r * e._w + i * e._x + n * e._y + s * e._z;
        if (
          (a < 0
            ? ((this._w = -e._w), (this._x = -e._x), (this._y = -e._y), (this._z = -e._z), (a = -a))
            : this.copy(e),
          a >= 1)
        )
          return (this._w = r), (this._x = i), (this._y = n), (this._z = s), this;
        const o = 1 - a * a;
        if (o <= Number.EPSILON) {
          const e = 1 - t;
          return (
            (this._w = e * r + t * this._w),
            (this._x = e * i + t * this._x),
            (this._y = e * n + t * this._y),
            (this._z = e * s + t * this._z),
            this.normalize(),
            this._onChangeCallback(),
            this
          );
        }
        const l = Math.sqrt(o),
          h = Math.atan2(l, a),
          c = Math.sin((1 - t) * h) / l,
          u = Math.sin(t * h) / l;
        return (
          (this._w = r * c + this._w * u),
          (this._x = i * c + this._x * u),
          (this._y = n * c + this._y * u),
          (this._z = s * c + this._z * u),
          this._onChangeCallback(),
          this
        );
      }
      slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i);
      }
      random() {
        const e = Math.random(),
          t = Math.sqrt(1 - e),
          i = Math.sqrt(e),
          n = 2 * Math.PI * Math.random(),
          s = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(n), i * Math.sin(s), i * Math.cos(s), t * Math.sin(n));
      }
      equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
      }
      fromArray(e, t = 0) {
        return (
          (this._x = e[t]),
          (this._y = e[t + 1]),
          (this._z = e[t + 2]),
          (this._w = e[t + 3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(e = [], t = 0) {
        return (e[t] = this._x), (e[t + 1] = this._y), (e[t + 2] = this._z), (e[t + 3] = this._w), e;
      }
      fromBufferAttribute(e, t) {
        return (this._x = e.getX(t)), (this._y = e.getY(t)), (this._z = e.getZ(t)), (this._w = e.getW(t)), this;
      }
      _onChange(e) {
        return (this._onChangeCallback = e), this;
      }
      _onChangeCallback() {}
      *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w;
      }
    }
    class Pe {
      constructor(e = 0, t = 0, i = 0) {
        (Pe.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
      }
      set(e, t, i) {
        return void 0 === i && (i = this.z), (this.x = e), (this.y = t), (this.z = i), this;
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setZ(e) {
        return (this.z = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          case 2:
            this.z = t;
            break;
          default:
            throw new Error('index is out of range: ' + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error('index is out of range: ' + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(e) {
        return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
      }
      add(e, t) {
        return void 0 !== t ? this.addVectors(e, t) : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), this;
      }
      addVectors(e, t) {
        return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this;
      }
      addScaledVector(e, t) {
        return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
      }
      sub(e, t) {
        return void 0 !== t ? this.subVectors(e, t) : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), this;
      }
      subVectors(e, t) {
        return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this;
      }
      multiply(e, t) {
        return void 0 !== t ? this.multiplyVectors(e, t) : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), this;
      }
      multiplyVectors(e, t) {
        return (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this;
      }
      applyEuler(e) {
        return !e || e.isEuler, this.applyQuaternion(Ie.setFromEuler(e));
      }
      applyAxisAngle(e, t) {
        return this.applyQuaternion(Ie.setFromAxisAngle(e, t));
      }
      applyMatrix3(e) {
        const t = this.x,
          i = this.y,
          n = this.z,
          s = e.elements;
        return (
          (this.x = s[0] * t + s[3] * i + s[6] * n),
          (this.y = s[1] * t + s[4] * i + s[7] * n),
          (this.z = s[2] * t + s[5] * i + s[8] * n),
          this
        );
      }
      applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize();
      }
      applyMatrix4(e) {
        const t = this.x,
          i = this.y,
          n = this.z,
          s = e.elements,
          r = 1 / (s[3] * t + s[7] * i + s[11] * n + s[15]);
        return (
          (this.x = (s[0] * t + s[4] * i + s[8] * n + s[12]) * r),
          (this.y = (s[1] * t + s[5] * i + s[9] * n + s[13]) * r),
          (this.z = (s[2] * t + s[6] * i + s[10] * n + s[14]) * r),
          this
        );
      }
      applyQuaternion(e) {
        const t = this.x,
          i = this.y,
          n = this.z,
          s = e.x,
          r = e.y,
          a = e.z,
          o = e.w,
          l = o * t + r * n - a * i,
          h = o * i + a * t - s * n,
          c = o * n + s * i - r * t,
          u = -s * t - r * i - a * n;
        return (
          (this.x = l * o + u * -s + h * -a - c * -r),
          (this.y = h * o + u * -r + c * -s - l * -a),
          (this.z = c * o + u * -a + l * -r - h * -s),
          this
        );
      }
      project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
      }
      unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
      }
      transformDirection(e) {
        const t = this.x,
          i = this.y,
          n = this.z,
          s = e.elements;
        return (
          (this.x = s[0] * t + s[4] * i + s[8] * n),
          (this.y = s[1] * t + s[5] * i + s[9] * n),
          (this.z = s[2] * t + s[6] * i + s[10] * n),
          this.normalize()
        );
      }
      divide(e) {
        return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      min(e) {
        return (
          (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), (this.z = Math.min(this.z, e.z)), this
        );
      }
      max(e) {
        return (
          (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), (this.z = Math.max(this.z, e.z)), this
        );
      }
      clamp(e, t) {
        return (
          (this.x = Math.max(e.x, Math.min(t.x, this.x))),
          (this.y = Math.max(e.y, Math.min(t.y, this.y))),
          (this.z = Math.max(e.z, Math.min(t.z, this.z))),
          this
        );
      }
      clampScalar(e, t) {
        return (
          (this.x = Math.max(e, Math.min(t, this.x))),
          (this.y = Math.max(e, Math.min(t, this.y))),
          (this.z = Math.max(e, Math.min(t, this.z))),
          this
        );
      }
      clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
      }
      floor() {
        return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), this;
      }
      ceil() {
        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this;
      }
      round() {
        return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), this;
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
      }
      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), (this.z += (e.z - this.z) * t), this;
      }
      lerpVectors(e, t, i) {
        return (
          (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), (this.z = e.z + (t.z - e.z) * i), this
        );
      }
      cross(e, t) {
        return void 0 !== t ? this.crossVectors(e, t) : this.crossVectors(this, e);
      }
      crossVectors(e, t) {
        const i = e.x,
          n = e.y,
          s = e.z,
          r = t.x,
          a = t.y,
          o = t.z;
        return (this.x = n * o - s * a), (this.y = s * r - i * o), (this.z = i * a - n * r), this;
      }
      projectOnVector(e) {
        const t = e.lengthSq();
        if (0 === t) return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i);
      }
      projectOnPlane(e) {
        return De.copy(this).projectOnVector(e), this.sub(De);
      }
      reflect(e) {
        return this.sub(De.copy(e).multiplyScalar(2 * this.dot(e)));
      }
      angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (0 === t) return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(K(i, -1, 1));
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }
      distanceToSquared(e) {
        const t = this.x - e.x,
          i = this.y - e.y,
          n = this.z - e.z;
        return t * t + i * i + n * n;
      }
      manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
      }
      setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
      }
      setFromSphericalCoords(e, t, i) {
        const n = Math.sin(t) * e;
        return (this.x = n * Math.sin(i)), (this.y = Math.cos(t) * e), (this.z = n * Math.cos(i)), this;
      }
      setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
      }
      setFromCylindricalCoords(e, t, i) {
        return (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this;
      }
      setFromMatrixPosition(e) {
        const t = e.elements;
        return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
      }
      setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length(),
          i = this.setFromMatrixColumn(e, 1).length(),
          n = this.setFromMatrixColumn(e, 2).length();
        return (this.x = t), (this.y = i), (this.z = n), this;
      }
      setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, 4 * t);
      }
      setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, 3 * t);
      }
      setFromEuler(e) {
        return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
      }
      equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z;
      }
      fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
      }
      fromBufferAttribute(e, t, i) {
        return (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this;
      }
      random() {
        return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this;
      }
      randomDirection() {
        const e = 2 * (Math.random() - 0.5),
          t = Math.random() * Math.PI * 2,
          i = Math.sqrt(1 - e ** 2);
        return (this.x = i * Math.cos(t)), (this.y = i * Math.sin(t)), (this.z = e), this;
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z;
      }
    }
    const De = new Pe(),
      Ie = new Ce();
    class Re {
      constructor(e = new Pe(1 / 0, 1 / 0, 1 / 0), t = new Pe(-1 / 0, -1 / 0, -1 / 0)) {
        (this.isBox3 = !0), (this.min = e), (this.max = t);
      }
      set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
      }
      setFromArray(e) {
        let t = 1 / 0,
          i = 1 / 0,
          n = 1 / 0,
          s = -1 / 0,
          r = -1 / 0,
          a = -1 / 0;
        for (let o = 0, l = e.length; o < l; o += 3) {
          const l = e[o],
            h = e[o + 1],
            c = e[o + 2];
          l < t && (t = l), h < i && (i = h), c < n && (n = c), l > s && (s = l), h > r && (r = h), c > a && (a = c);
        }
        return this.min.set(t, i, n), this.max.set(s, r, a), this;
      }
      setFromBufferAttribute(e) {
        let t = 1 / 0,
          i = 1 / 0,
          n = 1 / 0,
          s = -1 / 0,
          r = -1 / 0,
          a = -1 / 0;
        for (let o = 0, l = e.count; o < l; o++) {
          const l = e.getX(o),
            h = e.getY(o),
            c = e.getZ(o);
          l < t && (t = l), h < i && (i = h), c < n && (n = c), l > s && (s = l), h > r && (r = h), c > a && (a = c);
        }
        return this.min.set(t, i, n), this.max.set(s, r, a), this;
      }
      setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
        return this;
      }
      setFromCenterAndSize(e, t) {
        const i = Ne.copy(t).multiplyScalar(0.5);
        return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
      }
      setFromObject(e, t = !1) {
        return this.makeEmpty(), this.expandByObject(e, t);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
      }
      makeEmpty() {
        return (this.min.x = this.min.y = this.min.z = 1 / 0), (this.max.x = this.max.y = this.max.z = -1 / 0), this;
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      }
      getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
      }
      expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
      }
      expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
      }
      expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
      }
      expandByObject(e, t = !1) {
        e.updateWorldMatrix(!1, !1);
        const i = e.geometry;
        if (void 0 !== i)
          if (t && null != i.attributes && void 0 !== i.attributes.position) {
            const t = i.attributes.position;
            for (let i = 0, n = t.count; i < n; i++)
              Ne.fromBufferAttribute(t, i).applyMatrix4(e.matrixWorld), this.expandByPoint(Ne);
          } else
            null === i.boundingBox && i.computeBoundingBox(),
              ze.copy(i.boundingBox),
              ze.applyMatrix4(e.matrixWorld),
              this.union(ze);
        const n = e.children;
        for (let e = 0, i = n.length; e < i; e++) this.expandByObject(n[e], t);
        return this;
      }
      containsPoint(e) {
        return !(
          e.x < this.min.x ||
          e.x > this.max.x ||
          e.y < this.min.y ||
          e.y > this.max.y ||
          e.z < this.min.z ||
          e.z > this.max.z
        );
      }
      containsBox(e) {
        return (
          this.min.x <= e.min.x &&
          e.max.x <= this.max.x &&
          this.min.y <= e.min.y &&
          e.max.y <= this.max.y &&
          this.min.z <= e.min.z &&
          e.max.z <= this.max.z
        );
      }
      getParameter(e, t) {
        return t.set(
          (e.x - this.min.x) / (this.max.x - this.min.x),
          (e.y - this.min.y) / (this.max.y - this.min.y),
          (e.z - this.min.z) / (this.max.z - this.min.z),
        );
      }
      intersectsBox(e) {
        return !(
          e.max.x < this.min.x ||
          e.min.x > this.max.x ||
          e.max.y < this.min.y ||
          e.min.y > this.max.y ||
          e.max.z < this.min.z ||
          e.min.z > this.max.z
        );
      }
      intersectsSphere(e) {
        return this.clampPoint(e.center, Ne), Ne.distanceToSquared(e.center) <= e.radius * e.radius;
      }
      intersectsPlane(e) {
        let t, i;
        return (
          e.normal.x > 0
            ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
            : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
          e.normal.y > 0
            ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
            : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
          e.normal.z > 0
            ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
            : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
          t <= -e.constant && i >= -e.constant
        );
      }
      intersectsTriangle(e) {
        if (this.isEmpty()) return !1;
        this.getCenter(He),
          je.subVectors(this.max, He),
          Fe.subVectors(e.a, He),
          ke.subVectors(e.b, He),
          Ue.subVectors(e.c, He),
          Be.subVectors(ke, Fe),
          Ge.subVectors(Ue, ke),
          Ve.subVectors(Fe, Ue);
        let t = [
          0,
          -Be.z,
          Be.y,
          0,
          -Ge.z,
          Ge.y,
          0,
          -Ve.z,
          Ve.y,
          Be.z,
          0,
          -Be.x,
          Ge.z,
          0,
          -Ge.x,
          Ve.z,
          0,
          -Ve.x,
          -Be.y,
          Be.x,
          0,
          -Ge.y,
          Ge.x,
          0,
          -Ve.y,
          Ve.x,
          0,
        ];
        return (
          !!qe(t, Fe, ke, Ue, je) &&
          ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          !!qe(t, Fe, ke, Ue, je) && (We.crossVectors(Be, Ge), (t = [We.x, We.y, We.z]), qe(t, Fe, ke, Ue, je)))
        );
      }
      clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
      }
      distanceToPoint(e) {
        return Ne.copy(e).clamp(this.min, this.max).sub(e).length();
      }
      getBoundingSphere(e) {
        return this.getCenter(e.center), (e.radius = 0.5 * this.getSize(Ne).length()), e;
      }
      intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
      }
      union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
      }
      applyMatrix4(e) {
        return (
          this.isEmpty() ||
            (Oe[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
            Oe[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
            Oe[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
            Oe[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
            Oe[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
            Oe[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
            Oe[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
            Oe[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
            this.setFromPoints(Oe)),
          this
        );
      }
      translate(e) {
        return this.min.add(e), this.max.add(e), this;
      }
      equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
      }
    }
    const Oe = [new Pe(), new Pe(), new Pe(), new Pe(), new Pe(), new Pe(), new Pe(), new Pe()],
      Ne = new Pe(),
      ze = new Re(),
      Fe = new Pe(),
      ke = new Pe(),
      Ue = new Pe(),
      Be = new Pe(),
      Ge = new Pe(),
      Ve = new Pe(),
      He = new Pe(),
      je = new Pe(),
      We = new Pe(),
      Xe = new Pe();
    function qe(e, t, i, n, s) {
      for (let r = 0, a = e.length - 3; r <= a; r += 3) {
        Xe.fromArray(e, r);
        const a = s.x * Math.abs(Xe.x) + s.y * Math.abs(Xe.y) + s.z * Math.abs(Xe.z),
          o = t.dot(Xe),
          l = i.dot(Xe),
          h = n.dot(Xe);
        if (Math.max(-Math.max(o, l, h), Math.min(o, l, h)) > a) return !1;
      }
      return !0;
    }
    const Ye = new Re(),
      Ze = new Pe(),
      Je = new Pe(),
      Ke = new Pe();
    class $e {
      constructor(e = new Pe(), t = -1) {
        (this.center = e), (this.radius = t);
      }
      set(e, t) {
        return this.center.copy(e), (this.radius = t), this;
      }
      setFromPoints(e, t) {
        const i = this.center;
        void 0 !== t ? i.copy(t) : Ye.setFromPoints(e).getCenter(i);
        let n = 0;
        for (let t = 0, s = e.length; t < s; t++) n = Math.max(n, i.distanceToSquared(e[t]));
        return (this.radius = Math.sqrt(n)), this;
      }
      copy(e) {
        return this.center.copy(e.center), (this.radius = e.radius), this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        return this.center.set(0, 0, 0), (this.radius = -1), this;
      }
      containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t;
      }
      intersectsBox(e) {
        return e.intersectsSphere(this);
      }
      intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return (
          t.copy(e),
          i > this.radius * this.radius &&
            (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)),
          t
        );
      }
      getBoundingBox(e) {
        return this.isEmpty()
          ? (e.makeEmpty(), e)
          : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
      }
      applyMatrix4(e) {
        return this.center.applyMatrix4(e), (this.radius = this.radius * e.getMaxScaleOnAxis()), this;
      }
      translate(e) {
        return this.center.add(e), this;
      }
      expandByPoint(e) {
        Ke.subVectors(e, this.center);
        const t = Ke.lengthSq();
        if (t > this.radius * this.radius) {
          const e = Math.sqrt(t),
            i = 0.5 * (e - this.radius);
          this.center.add(Ke.multiplyScalar(i / e)), (this.radius += i);
        }
        return this;
      }
      union(e) {
        return (
          !0 === this.center.equals(e.center)
            ? Je.set(0, 0, 1).multiplyScalar(e.radius)
            : Je.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius),
          this.expandByPoint(Ze.copy(e.center).add(Je)),
          this.expandByPoint(Ze.copy(e.center).sub(Je)),
          this
        );
      }
      equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    const Qe = new Pe(),
      et = new Pe(),
      tt = new Pe(),
      it = new Pe(),
      nt = new Pe(),
      st = new Pe(),
      rt = new Pe();
    class at {
      constructor(e = new Pe(), t = new Pe(0, 0, -1)) {
        (this.origin = e), (this.direction = t);
      }
      set(e, t) {
        return this.origin.copy(e), this.direction.copy(t), this;
      }
      copy(e) {
        return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
      }
      at(e, t) {
        return t.copy(this.direction).multiplyScalar(e).add(this.origin);
      }
      lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this;
      }
      recast(e) {
        return this.origin.copy(this.at(e, Qe)), this;
      }
      closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin);
      }
      distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e));
      }
      distanceSqToPoint(e) {
        const t = Qe.subVectors(e, this.origin).dot(this.direction);
        return t < 0
          ? this.origin.distanceToSquared(e)
          : (Qe.copy(this.direction).multiplyScalar(t).add(this.origin), Qe.distanceToSquared(e));
      }
      distanceSqToSegment(e, t, i, n) {
        et.copy(e).add(t).multiplyScalar(0.5), tt.copy(t).sub(e).normalize(), it.copy(this.origin).sub(et);
        const s = 0.5 * e.distanceTo(t),
          r = -this.direction.dot(tt),
          a = it.dot(this.direction),
          o = -it.dot(tt),
          l = it.lengthSq(),
          h = Math.abs(1 - r * r);
        let c, u, d, m;
        if (h > 0)
          if (((c = r * o - a), (u = r * a - o), (m = s * h), c >= 0))
            if (u >= -m)
              if (u <= m) {
                const e = 1 / h;
                (c *= e), (u *= e), (d = c * (c + r * u + 2 * a) + u * (r * c + u + 2 * o) + l);
              } else (u = s), (c = Math.max(0, -(r * u + a))), (d = -c * c + u * (u + 2 * o) + l);
            else (u = -s), (c = Math.max(0, -(r * u + a))), (d = -c * c + u * (u + 2 * o) + l);
          else
            u <= -m
              ? ((c = Math.max(0, -(-r * s + a))),
                (u = c > 0 ? -s : Math.min(Math.max(-s, -o), s)),
                (d = -c * c + u * (u + 2 * o) + l))
              : u <= m
              ? ((c = 0), (u = Math.min(Math.max(-s, -o), s)), (d = u * (u + 2 * o) + l))
              : ((c = Math.max(0, -(r * s + a))),
                (u = c > 0 ? s : Math.min(Math.max(-s, -o), s)),
                (d = -c * c + u * (u + 2 * o) + l));
        else (u = r > 0 ? -s : s), (c = Math.max(0, -(r * u + a))), (d = -c * c + u * (u + 2 * o) + l);
        return (
          i && i.copy(this.direction).multiplyScalar(c).add(this.origin), n && n.copy(tt).multiplyScalar(u).add(et), d
        );
      }
      intersectSphere(e, t) {
        Qe.subVectors(e.center, this.origin);
        const i = Qe.dot(this.direction),
          n = Qe.dot(Qe) - i * i,
          s = e.radius * e.radius;
        if (n > s) return null;
        const r = Math.sqrt(s - n),
          a = i - r,
          o = i + r;
        return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t);
      }
      intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
      }
      distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null;
      }
      intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return null === i ? null : this.at(i, t);
      }
      intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        if (0 === t) return !0;
        return e.normal.dot(this.direction) * t < 0;
      }
      intersectBox(e, t) {
        let i, n, s, r, a, o;
        const l = 1 / this.direction.x,
          h = 1 / this.direction.y,
          c = 1 / this.direction.z,
          u = this.origin;
        return (
          l >= 0
            ? ((i = (e.min.x - u.x) * l), (n = (e.max.x - u.x) * l))
            : ((i = (e.max.x - u.x) * l), (n = (e.min.x - u.x) * l)),
          h >= 0
            ? ((s = (e.min.y - u.y) * h), (r = (e.max.y - u.y) * h))
            : ((s = (e.max.y - u.y) * h), (r = (e.min.y - u.y) * h)),
          i > r || s > n
            ? null
            : ((s > i || i != i) && (i = s),
              (r < n || n != n) && (n = r),
              c >= 0
                ? ((a = (e.min.z - u.z) * c), (o = (e.max.z - u.z) * c))
                : ((a = (e.max.z - u.z) * c), (o = (e.min.z - u.z) * c)),
              i > o || a > n
                ? null
                : ((a > i || i != i) && (i = a),
                  (o < n || n != n) && (n = o),
                  n < 0 ? null : this.at(i >= 0 ? i : n, t)))
        );
      }
      intersectsBox(e) {
        return null !== this.intersectBox(e, Qe);
      }
      intersectTriangle(e, t, i, n, s) {
        nt.subVectors(t, e), st.subVectors(i, e), rt.crossVectors(nt, st);
        let r,
          a = this.direction.dot(rt);
        if (a > 0) {
          if (n) return null;
          r = 1;
        } else {
          if (!(a < 0)) return null;
          (r = -1), (a = -a);
        }
        it.subVectors(this.origin, e);
        const o = r * this.direction.dot(st.crossVectors(it, st));
        if (o < 0) return null;
        const l = r * this.direction.dot(nt.cross(it));
        if (l < 0) return null;
        if (o + l > a) return null;
        const h = -r * it.dot(rt);
        return h < 0 ? null : this.at(h / a, s);
      }
      applyMatrix4(e) {
        return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
      }
      equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction);
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    class ot {
      constructor() {
        (ot.prototype.isMatrix4 = !0), (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      }
      set(e, t, i, n, s, r, a, o, l, h, c, u, d, m, p, f) {
        const g = this.elements;
        return (
          (g[0] = e),
          (g[4] = t),
          (g[8] = i),
          (g[12] = n),
          (g[1] = s),
          (g[5] = r),
          (g[9] = a),
          (g[13] = o),
          (g[2] = l),
          (g[6] = h),
          (g[10] = c),
          (g[14] = u),
          (g[3] = d),
          (g[7] = m),
          (g[11] = p),
          (g[15] = f),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      clone() {
        return new ot().fromArray(this.elements);
      }
      copy(e) {
        const t = this.elements,
          i = e.elements;
        return (
          (t[0] = i[0]),
          (t[1] = i[1]),
          (t[2] = i[2]),
          (t[3] = i[3]),
          (t[4] = i[4]),
          (t[5] = i[5]),
          (t[6] = i[6]),
          (t[7] = i[7]),
          (t[8] = i[8]),
          (t[9] = i[9]),
          (t[10] = i[10]),
          (t[11] = i[11]),
          (t[12] = i[12]),
          (t[13] = i[13]),
          (t[14] = i[14]),
          (t[15] = i[15]),
          this
        );
      }
      copyPosition(e) {
        const t = this.elements,
          i = e.elements;
        return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
      }
      setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
      }
      extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
      }
      makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this;
      }
      extractRotation(e) {
        const t = this.elements,
          i = e.elements,
          n = 1 / lt.setFromMatrixColumn(e, 0).length(),
          s = 1 / lt.setFromMatrixColumn(e, 1).length(),
          r = 1 / lt.setFromMatrixColumn(e, 2).length();
        return (
          (t[0] = i[0] * n),
          (t[1] = i[1] * n),
          (t[2] = i[2] * n),
          (t[3] = 0),
          (t[4] = i[4] * s),
          (t[5] = i[5] * s),
          (t[6] = i[6] * s),
          (t[7] = 0),
          (t[8] = i[8] * r),
          (t[9] = i[9] * r),
          (t[10] = i[10] * r),
          (t[11] = 0),
          (t[12] = 0),
          (t[13] = 0),
          (t[14] = 0),
          (t[15] = 1),
          this
        );
      }
      makeRotationFromEuler(e) {
        !e || e.isEuler;
        const t = this.elements,
          i = e.x,
          n = e.y,
          s = e.z,
          r = Math.cos(i),
          a = Math.sin(i),
          o = Math.cos(n),
          l = Math.sin(n),
          h = Math.cos(s),
          c = Math.sin(s);
        if ('XYZ' === e.order) {
          const e = r * h,
            i = r * c,
            n = a * h,
            s = a * c;
          (t[0] = o * h),
            (t[4] = -o * c),
            (t[8] = l),
            (t[1] = i + n * l),
            (t[5] = e - s * l),
            (t[9] = -a * o),
            (t[2] = s - e * l),
            (t[6] = n + i * l),
            (t[10] = r * o);
        } else if ('YXZ' === e.order) {
          const e = o * h,
            i = o * c,
            n = l * h,
            s = l * c;
          (t[0] = e + s * a),
            (t[4] = n * a - i),
            (t[8] = r * l),
            (t[1] = r * c),
            (t[5] = r * h),
            (t[9] = -a),
            (t[2] = i * a - n),
            (t[6] = s + e * a),
            (t[10] = r * o);
        } else if ('ZXY' === e.order) {
          const e = o * h,
            i = o * c,
            n = l * h,
            s = l * c;
          (t[0] = e - s * a),
            (t[4] = -r * c),
            (t[8] = n + i * a),
            (t[1] = i + n * a),
            (t[5] = r * h),
            (t[9] = s - e * a),
            (t[2] = -r * l),
            (t[6] = a),
            (t[10] = r * o);
        } else if ('ZYX' === e.order) {
          const e = r * h,
            i = r * c,
            n = a * h,
            s = a * c;
          (t[0] = o * h),
            (t[4] = n * l - i),
            (t[8] = e * l + s),
            (t[1] = o * c),
            (t[5] = s * l + e),
            (t[9] = i * l - n),
            (t[2] = -l),
            (t[6] = a * o),
            (t[10] = r * o);
        } else if ('YZX' === e.order) {
          const e = r * o,
            i = r * l,
            n = a * o,
            s = a * l;
          (t[0] = o * h),
            (t[4] = s - e * c),
            (t[8] = n * c + i),
            (t[1] = c),
            (t[5] = r * h),
            (t[9] = -a * h),
            (t[2] = -l * h),
            (t[6] = i * c + n),
            (t[10] = e - s * c);
        } else if ('XZY' === e.order) {
          const e = r * o,
            i = r * l,
            n = a * o,
            s = a * l;
          (t[0] = o * h),
            (t[4] = -c),
            (t[8] = l * h),
            (t[1] = e * c + s),
            (t[5] = r * h),
            (t[9] = i * c - n),
            (t[2] = n * c - i),
            (t[6] = a * h),
            (t[10] = s * c + e);
        }
        return (t[3] = 0), (t[7] = 0), (t[11] = 0), (t[12] = 0), (t[13] = 0), (t[14] = 0), (t[15] = 1), this;
      }
      makeRotationFromQuaternion(e) {
        return this.compose(ct, e, ut);
      }
      lookAt(e, t, i) {
        const n = this.elements;
        return (
          pt.subVectors(e, t),
          0 === pt.lengthSq() && (pt.z = 1),
          pt.normalize(),
          dt.crossVectors(i, pt),
          0 === dt.lengthSq() &&
            (1 === Math.abs(i.z) ? (pt.x += 1e-4) : (pt.z += 1e-4), pt.normalize(), dt.crossVectors(i, pt)),
          dt.normalize(),
          mt.crossVectors(pt, dt),
          (n[0] = dt.x),
          (n[4] = mt.x),
          (n[8] = pt.x),
          (n[1] = dt.y),
          (n[5] = mt.y),
          (n[9] = pt.y),
          (n[2] = dt.z),
          (n[6] = mt.z),
          (n[10] = pt.z),
          this
        );
      }
      multiply(e, t) {
        return void 0 !== t ? this.multiplyMatrices(e, t) : this.multiplyMatrices(this, e);
      }
      premultiply(e) {
        return this.multiplyMatrices(e, this);
      }
      multiplyMatrices(e, t) {
        const i = e.elements,
          n = t.elements,
          s = this.elements,
          r = i[0],
          a = i[4],
          o = i[8],
          l = i[12],
          h = i[1],
          c = i[5],
          u = i[9],
          d = i[13],
          m = i[2],
          p = i[6],
          f = i[10],
          g = i[14],
          _ = i[3],
          v = i[7],
          x = i[11],
          y = i[15],
          M = n[0],
          b = n[4],
          S = n[8],
          w = n[12],
          A = n[1],
          T = n[5],
          E = n[9],
          L = n[13],
          C = n[2],
          P = n[6],
          D = n[10],
          I = n[14],
          R = n[3],
          O = n[7],
          N = n[11],
          z = n[15];
        return (
          (s[0] = r * M + a * A + o * C + l * R),
          (s[4] = r * b + a * T + o * P + l * O),
          (s[8] = r * S + a * E + o * D + l * N),
          (s[12] = r * w + a * L + o * I + l * z),
          (s[1] = h * M + c * A + u * C + d * R),
          (s[5] = h * b + c * T + u * P + d * O),
          (s[9] = h * S + c * E + u * D + d * N),
          (s[13] = h * w + c * L + u * I + d * z),
          (s[2] = m * M + p * A + f * C + g * R),
          (s[6] = m * b + p * T + f * P + g * O),
          (s[10] = m * S + p * E + f * D + g * N),
          (s[14] = m * w + p * L + f * I + g * z),
          (s[3] = _ * M + v * A + x * C + y * R),
          (s[7] = _ * b + v * T + x * P + y * O),
          (s[11] = _ * S + v * E + x * D + y * N),
          (s[15] = _ * w + v * L + x * I + y * z),
          this
        );
      }
      multiplyScalar(e) {
        const t = this.elements;
        return (
          (t[0] *= e),
          (t[4] *= e),
          (t[8] *= e),
          (t[12] *= e),
          (t[1] *= e),
          (t[5] *= e),
          (t[9] *= e),
          (t[13] *= e),
          (t[2] *= e),
          (t[6] *= e),
          (t[10] *= e),
          (t[14] *= e),
          (t[3] *= e),
          (t[7] *= e),
          (t[11] *= e),
          (t[15] *= e),
          this
        );
      }
      determinant() {
        const e = this.elements,
          t = e[0],
          i = e[4],
          n = e[8],
          s = e[12],
          r = e[1],
          a = e[5],
          o = e[9],
          l = e[13],
          h = e[2],
          c = e[6],
          u = e[10],
          d = e[14];
        return (
          e[3] * (+s * o * c - n * l * c - s * a * u + i * l * u + n * a * d - i * o * d) +
          e[7] * (+t * o * d - t * l * u + s * r * u - n * r * d + n * l * h - s * o * h) +
          e[11] * (+t * l * c - t * a * d - s * r * c + i * r * d + s * a * h - i * l * h) +
          e[15] * (-n * a * h - t * o * c + t * a * u + n * r * c - i * r * u + i * o * h)
        );
      }
      transpose() {
        const e = this.elements;
        let t;
        return (
          (t = e[1]),
          (e[1] = e[4]),
          (e[4] = t),
          (t = e[2]),
          (e[2] = e[8]),
          (e[8] = t),
          (t = e[6]),
          (e[6] = e[9]),
          (e[9] = t),
          (t = e[3]),
          (e[3] = e[12]),
          (e[12] = t),
          (t = e[7]),
          (e[7] = e[13]),
          (e[13] = t),
          (t = e[11]),
          (e[11] = e[14]),
          (e[14] = t),
          this
        );
      }
      setPosition(e, t, i) {
        const n = this.elements;
        return (
          e.isVector3 ? ((n[12] = e.x), (n[13] = e.y), (n[14] = e.z)) : ((n[12] = e), (n[13] = t), (n[14] = i)), this
        );
      }
      invert() {
        const e = this.elements,
          t = e[0],
          i = e[1],
          n = e[2],
          s = e[3],
          r = e[4],
          a = e[5],
          o = e[6],
          l = e[7],
          h = e[8],
          c = e[9],
          u = e[10],
          d = e[11],
          m = e[12],
          p = e[13],
          f = e[14],
          g = e[15],
          _ = c * f * l - p * u * l + p * o * d - a * f * d - c * o * g + a * u * g,
          v = m * u * l - h * f * l - m * o * d + r * f * d + h * o * g - r * u * g,
          x = h * p * l - m * c * l + m * a * d - r * p * d - h * a * g + r * c * g,
          y = m * c * o - h * p * o - m * a * u + r * p * u + h * a * f - r * c * f,
          M = t * _ + i * v + n * x + s * y;
        if (0 === M) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const b = 1 / M;
        return (
          (e[0] = _ * b),
          (e[1] = (p * u * s - c * f * s - p * n * d + i * f * d + c * n * g - i * u * g) * b),
          (e[2] = (a * f * s - p * o * s + p * n * l - i * f * l - a * n * g + i * o * g) * b),
          (e[3] = (c * o * s - a * u * s - c * n * l + i * u * l + a * n * d - i * o * d) * b),
          (e[4] = v * b),
          (e[5] = (h * f * s - m * u * s + m * n * d - t * f * d - h * n * g + t * u * g) * b),
          (e[6] = (m * o * s - r * f * s - m * n * l + t * f * l + r * n * g - t * o * g) * b),
          (e[7] = (r * u * s - h * o * s + h * n * l - t * u * l - r * n * d + t * o * d) * b),
          (e[8] = x * b),
          (e[9] = (m * c * s - h * p * s - m * i * d + t * p * d + h * i * g - t * c * g) * b),
          (e[10] = (r * p * s - m * a * s + m * i * l - t * p * l - r * i * g + t * a * g) * b),
          (e[11] = (h * a * s - r * c * s - h * i * l + t * c * l + r * i * d - t * a * d) * b),
          (e[12] = y * b),
          (e[13] = (h * p * n - m * c * n + m * i * u - t * p * u - h * i * f + t * c * f) * b),
          (e[14] = (m * a * n - r * p * n - m * i * o + t * p * o + r * i * f - t * a * f) * b),
          (e[15] = (r * c * n - h * a * n + h * i * o - t * c * o - r * i * u + t * a * u) * b),
          this
        );
      }
      scale(e) {
        const t = this.elements,
          i = e.x,
          n = e.y,
          s = e.z;
        return (
          (t[0] *= i),
          (t[4] *= n),
          (t[8] *= s),
          (t[1] *= i),
          (t[5] *= n),
          (t[9] *= s),
          (t[2] *= i),
          (t[6] *= n),
          (t[10] *= s),
          (t[3] *= i),
          (t[7] *= n),
          (t[11] *= s),
          this
        );
      }
      getMaxScaleOnAxis() {
        const e = this.elements,
          t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
          i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
          n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, n));
      }
      makeTranslation(e, t, i) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
      }
      makeRotationX(e) {
        const t = Math.cos(e),
          i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
      }
      makeRotationY(e) {
        const t = Math.cos(e),
          i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
      }
      makeRotationZ(e) {
        const t = Math.cos(e),
          i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      makeRotationAxis(e, t) {
        const i = Math.cos(t),
          n = Math.sin(t),
          s = 1 - i,
          r = e.x,
          a = e.y,
          o = e.z,
          l = s * r,
          h = s * a;
        return (
          this.set(
            l * r + i,
            l * a - n * o,
            l * o + n * a,
            0,
            l * a + n * o,
            h * a + i,
            h * o - n * r,
            0,
            l * o - n * a,
            h * o + n * r,
            s * o * o + i,
            0,
            0,
            0,
            0,
            1,
          ),
          this
        );
      }
      makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
      }
      makeShear(e, t, i, n, s, r) {
        return this.set(1, i, s, 0, e, 1, r, 0, t, n, 1, 0, 0, 0, 0, 1), this;
      }
      compose(e, t, i) {
        const n = this.elements,
          s = t._x,
          r = t._y,
          a = t._z,
          o = t._w,
          l = s + s,
          h = r + r,
          c = a + a,
          u = s * l,
          d = s * h,
          m = s * c,
          p = r * h,
          f = r * c,
          g = a * c,
          _ = o * l,
          v = o * h,
          x = o * c,
          y = i.x,
          M = i.y,
          b = i.z;
        return (
          (n[0] = (1 - (p + g)) * y),
          (n[1] = (d + x) * y),
          (n[2] = (m - v) * y),
          (n[3] = 0),
          (n[4] = (d - x) * M),
          (n[5] = (1 - (u + g)) * M),
          (n[6] = (f + _) * M),
          (n[7] = 0),
          (n[8] = (m + v) * b),
          (n[9] = (f - _) * b),
          (n[10] = (1 - (u + p)) * b),
          (n[11] = 0),
          (n[12] = e.x),
          (n[13] = e.y),
          (n[14] = e.z),
          (n[15] = 1),
          this
        );
      }
      decompose(e, t, i) {
        const n = this.elements;
        let s = lt.set(n[0], n[1], n[2]).length();
        const r = lt.set(n[4], n[5], n[6]).length(),
          a = lt.set(n[8], n[9], n[10]).length();
        this.determinant() < 0 && (s = -s), (e.x = n[12]), (e.y = n[13]), (e.z = n[14]), ht.copy(this);
        const o = 1 / s,
          l = 1 / r,
          h = 1 / a;
        return (
          (ht.elements[0] *= o),
          (ht.elements[1] *= o),
          (ht.elements[2] *= o),
          (ht.elements[4] *= l),
          (ht.elements[5] *= l),
          (ht.elements[6] *= l),
          (ht.elements[8] *= h),
          (ht.elements[9] *= h),
          (ht.elements[10] *= h),
          t.setFromRotationMatrix(ht),
          (i.x = s),
          (i.y = r),
          (i.z = a),
          this
        );
      }
      makePerspective(e, t, i, n, s, r) {
        const a = this.elements,
          o = (2 * s) / (t - e),
          l = (2 * s) / (i - n),
          h = (t + e) / (t - e),
          c = (i + n) / (i - n),
          u = -(r + s) / (r - s),
          d = (-2 * r * s) / (r - s);
        return (
          (a[0] = o),
          (a[4] = 0),
          (a[8] = h),
          (a[12] = 0),
          (a[1] = 0),
          (a[5] = l),
          (a[9] = c),
          (a[13] = 0),
          (a[2] = 0),
          (a[6] = 0),
          (a[10] = u),
          (a[14] = d),
          (a[3] = 0),
          (a[7] = 0),
          (a[11] = -1),
          (a[15] = 0),
          this
        );
      }
      makeOrthographic(e, t, i, n, s, r) {
        const a = this.elements,
          o = 1 / (t - e),
          l = 1 / (i - n),
          h = 1 / (r - s),
          c = (t + e) * o,
          u = (i + n) * l,
          d = (r + s) * h;
        return (
          (a[0] = 2 * o),
          (a[4] = 0),
          (a[8] = 0),
          (a[12] = -c),
          (a[1] = 0),
          (a[5] = 2 * l),
          (a[9] = 0),
          (a[13] = -u),
          (a[2] = 0),
          (a[6] = 0),
          (a[10] = -2 * h),
          (a[14] = -d),
          (a[3] = 0),
          (a[7] = 0),
          (a[11] = 0),
          (a[15] = 1),
          this
        );
      }
      equals(e) {
        const t = this.elements,
          i = e.elements;
        for (let e = 0; e < 16; e++) if (t[e] !== i[e]) return !1;
        return !0;
      }
      fromArray(e, t = 0) {
        for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
        return this;
      }
      toArray(e = [], t = 0) {
        const i = this.elements;
        return (
          (e[t] = i[0]),
          (e[t + 1] = i[1]),
          (e[t + 2] = i[2]),
          (e[t + 3] = i[3]),
          (e[t + 4] = i[4]),
          (e[t + 5] = i[5]),
          (e[t + 6] = i[6]),
          (e[t + 7] = i[7]),
          (e[t + 8] = i[8]),
          (e[t + 9] = i[9]),
          (e[t + 10] = i[10]),
          (e[t + 11] = i[11]),
          (e[t + 12] = i[12]),
          (e[t + 13] = i[13]),
          (e[t + 14] = i[14]),
          (e[t + 15] = i[15]),
          e
        );
      }
    }
    const lt = new Pe(),
      ht = new ot(),
      ct = new Pe(0, 0, 0),
      ut = new Pe(1, 1, 1),
      dt = new Pe(),
      mt = new Pe(),
      pt = new Pe(),
      ft = new ot(),
      gt = new Ce();
    class _t {
      constructor(e = 0, t = 0, i = 0, n = _t.DefaultOrder) {
        (this.isEuler = !0), (this._x = e), (this._y = t), (this._z = i), (this._order = n);
      }
      get x() {
        return this._x;
      }
      set x(e) {
        (this._x = e), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(e) {
        (this._y = e), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(e) {
        (this._z = e), this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order(e) {
        (this._order = e), this._onChangeCallback();
      }
      set(e, t, i, n = this._order) {
        return (this._x = e), (this._y = t), (this._z = i), (this._order = n), this._onChangeCallback(), this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(e) {
        return (
          (this._x = e._x), (this._y = e._y), (this._z = e._z), (this._order = e._order), this._onChangeCallback(), this
        );
      }
      setFromRotationMatrix(e, t = this._order, i = !0) {
        const n = e.elements,
          s = n[0],
          r = n[4],
          a = n[8],
          o = n[1],
          l = n[5],
          h = n[9],
          c = n[2],
          u = n[6],
          d = n[10];
        switch (t) {
          case 'XYZ':
            (this._y = Math.asin(K(a, -1, 1))),
              Math.abs(a) < 0.9999999
                ? ((this._x = Math.atan2(-h, d)), (this._z = Math.atan2(-r, s)))
                : ((this._x = Math.atan2(u, l)), (this._z = 0));
            break;
          case 'YXZ':
            (this._x = Math.asin(-K(h, -1, 1))),
              Math.abs(h) < 0.9999999
                ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
                : ((this._y = Math.atan2(-c, s)), (this._z = 0));
            break;
          case 'ZXY':
            (this._x = Math.asin(K(u, -1, 1))),
              Math.abs(u) < 0.9999999
                ? ((this._y = Math.atan2(-c, d)), (this._z = Math.atan2(-r, l)))
                : ((this._y = 0), (this._z = Math.atan2(o, s)));
            break;
          case 'ZYX':
            (this._y = Math.asin(-K(c, -1, 1))),
              Math.abs(c) < 0.9999999
                ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, s)))
                : ((this._x = 0), (this._z = Math.atan2(-r, l)));
            break;
          case 'YZX':
            (this._z = Math.asin(K(o, -1, 1))),
              Math.abs(o) < 0.9999999
                ? ((this._x = Math.atan2(-h, l)), (this._y = Math.atan2(-c, s)))
                : ((this._x = 0), (this._y = Math.atan2(a, d)));
            break;
          case 'XZY':
            (this._z = Math.asin(-K(r, -1, 1))),
              Math.abs(r) < 0.9999999
                ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, s)))
                : ((this._x = Math.atan2(-h, d)), (this._y = 0));
        }
        return (this._order = t), !0 === i && this._onChangeCallback(), this;
      }
      setFromQuaternion(e, t, i) {
        return ft.makeRotationFromQuaternion(e), this.setFromRotationMatrix(ft, t, i);
      }
      setFromVector3(e, t = this._order) {
        return this.set(e.x, e.y, e.z, t);
      }
      reorder(e) {
        return gt.setFromEuler(this), this.setFromQuaternion(gt, e);
      }
      equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
      }
      fromArray(e) {
        return (
          (this._x = e[0]),
          (this._y = e[1]),
          (this._z = e[2]),
          void 0 !== e[3] && (this._order = e[3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(e = [], t = 0) {
        return (e[t] = this._x), (e[t + 1] = this._y), (e[t + 2] = this._z), (e[t + 3] = this._order), e;
      }
      _onChange(e) {
        return (this._onChangeCallback = e), this;
      }
      _onChangeCallback() {}
      *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order;
      }
      toVector3() {}
    }
    (_t.DefaultOrder = 'XYZ'), (_t.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX']);
    class vt {
      constructor() {
        this.mask = 1;
      }
      set(e) {
        this.mask = ((1 << e) | 0) >>> 0;
      }
      enable(e) {
        this.mask |= (1 << e) | 0;
      }
      enableAll() {
        this.mask = -1;
      }
      toggle(e) {
        this.mask ^= (1 << e) | 0;
      }
      disable(e) {
        this.mask &= ~((1 << e) | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(e) {
        return 0 != (this.mask & e.mask);
      }
      isEnabled(e) {
        return 0 != (this.mask & ((1 << e) | 0));
      }
    }
    let xt = 0;
    const yt = new Pe(),
      Mt = new Ce(),
      bt = new ot(),
      St = new Pe(),
      wt = new Pe(),
      At = new Pe(),
      Tt = new Ce(),
      Et = new Pe(1, 0, 0),
      Lt = new Pe(0, 1, 0),
      Ct = new Pe(0, 0, 1),
      Pt = { type: 'added' },
      Dt = { type: 'removed' };
    class It extends W {
      constructor() {
        super(),
          (this.isObject3D = !0),
          Object.defineProperty(this, 'id', { value: xt++ }),
          (this.uuid = J()),
          (this.name = ''),
          (this.type = 'Object3D'),
          (this.parent = null),
          (this.children = []),
          (this.up = It.DefaultUp.clone());
        const e = new Pe(),
          t = new _t(),
          i = new Ce(),
          n = new Pe(1, 1, 1);
        t._onChange(function () {
          i.setFromEuler(t, !1);
        }),
          i._onChange(function () {
            t.setFromQuaternion(i, void 0, !1);
          }),
          Object.defineProperties(this, {
            position: { configurable: !0, enumerable: !0, value: e },
            rotation: { configurable: !0, enumerable: !0, value: t },
            quaternion: { configurable: !0, enumerable: !0, value: i },
            scale: { configurable: !0, enumerable: !0, value: n },
            modelViewMatrix: { value: new ot() },
            normalMatrix: { value: new re() },
          }),
          (this.matrix = new ot()),
          (this.matrixWorld = new ot()),
          (this.matrixAutoUpdate = It.DefaultMatrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = !1),
          (this.layers = new vt()),
          (this.visible = !0),
          (this.castShadow = !1),
          (this.receiveShadow = !1),
          (this.frustumCulled = !0),
          (this.renderOrder = 0),
          (this.animations = []),
          (this.userData = {});
      }
      onBeforeRender() {}
      onAfterRender() {}
      applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          this.matrix.premultiply(e),
          this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(e) {
        return this.quaternion.premultiply(e), this;
      }
      setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t);
      }
      setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0);
      }
      setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e);
      }
      setRotationFromQuaternion(e) {
        this.quaternion.copy(e);
      }
      rotateOnAxis(e, t) {
        return Mt.setFromAxisAngle(e, t), this.quaternion.multiply(Mt), this;
      }
      rotateOnWorldAxis(e, t) {
        return Mt.setFromAxisAngle(e, t), this.quaternion.premultiply(Mt), this;
      }
      rotateX(e) {
        return this.rotateOnAxis(Et, e);
      }
      rotateY(e) {
        return this.rotateOnAxis(Lt, e);
      }
      rotateZ(e) {
        return this.rotateOnAxis(Ct, e);
      }
      translateOnAxis(e, t) {
        return yt.copy(e).applyQuaternion(this.quaternion), this.position.add(yt.multiplyScalar(t)), this;
      }
      translateX(e) {
        return this.translateOnAxis(Et, e);
      }
      translateY(e) {
        return this.translateOnAxis(Lt, e);
      }
      translateZ(e) {
        return this.translateOnAxis(Ct, e);
      }
      localToWorld(e) {
        return e.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(e) {
        return e.applyMatrix4(bt.copy(this.matrixWorld).invert());
      }
      lookAt(e, t, i) {
        e.isVector3 ? St.copy(e) : St.set(e, t, i);
        const n = this.parent;
        this.updateWorldMatrix(!0, !1),
          wt.setFromMatrixPosition(this.matrixWorld),
          this.isCamera || this.isLight ? bt.lookAt(wt, St, this.up) : bt.lookAt(St, wt, this.up),
          this.quaternion.setFromRotationMatrix(bt),
          n &&
            (bt.extractRotation(n.matrixWorld), Mt.setFromRotationMatrix(bt), this.quaternion.premultiply(Mt.invert()));
      }
      add(e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
          return this;
        }
        return (
          e === this ||
            (e &&
              e.isObject3D &&
              (null !== e.parent && e.parent.remove(e), (e.parent = this), this.children.push(e), e.dispatchEvent(Pt))),
          this
        );
      }
      remove(e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
          return this;
        }
        const t = this.children.indexOf(e);
        return -1 !== t && ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(Dt)), this;
      }
      removeFromParent() {
        const e = this.parent;
        return null !== e && e.remove(this), this;
      }
      clear() {
        for (let e = 0; e < this.children.length; e++) {
          const t = this.children[e];
          (t.parent = null), t.dispatchEvent(Dt);
        }
        return (this.children.length = 0), this;
      }
      attach(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          bt.copy(this.matrixWorld).invert(),
          null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), bt.multiply(e.parent.matrixWorld)),
          e.applyMatrix4(bt),
          this.add(e),
          e.updateWorldMatrix(!1, !0),
          this
        );
      }
      getObjectById(e) {
        return this.getObjectByProperty('id', e);
      }
      getObjectByName(e) {
        return this.getObjectByProperty('name', e);
      }
      getObjectByProperty(e, t) {
        if (this[e] === t) return this;
        for (let i = 0, n = this.children.length; i < n; i++) {
          const n = this.children[i].getObjectByProperty(e, t);
          if (void 0 !== n) return n;
        }
      }
      getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
      }
      getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(wt, e, At), e;
      }
      getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(wt, Tt, e), e;
      }
      getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize();
      }
      raycast() {}
      traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++) t[i].traverse(e);
      }
      traverseVisible(e) {
        if (!1 === this.visible) return;
        e(this);
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e);
      }
      traverseAncestors(e) {
        const t = this.parent;
        null !== t && (e(t), t.traverseAncestors(e));
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0);
      }
      updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || e) &&
            (null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            (this.matrixWorldNeedsUpdate = !1),
            (e = !0));
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e);
      }
      updateWorldMatrix(e, t) {
        const i = this.parent;
        if (
          (!0 === e && null !== i && i.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
          !0 === t)
        ) {
          const e = this.children;
          for (let t = 0, i = e.length; t < i; t++) e[t].updateWorldMatrix(!1, !0);
        }
      }
      toJSON(e) {
        const t = void 0 === e || 'string' == typeof e,
          i = {};
        t &&
          ((e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {},
          }),
          (i.metadata = { version: 4.5, type: 'Object', generator: 'Object3D.toJSON' }));
        const n = {};
        function s(t, i) {
          return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)), i.uuid;
        }
        if (
          ((n.uuid = this.uuid),
          (n.type = this.type),
          '' !== this.name && (n.name = this.name),
          !0 === this.castShadow && (n.castShadow = !0),
          !0 === this.receiveShadow && (n.receiveShadow = !0),
          !1 === this.visible && (n.visible = !1),
          !1 === this.frustumCulled && (n.frustumCulled = !1),
          0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
          '{}' !== JSON.stringify(this.userData) && (n.userData = this.userData),
          (n.layers = this.layers.mask),
          (n.matrix = this.matrix.toArray()),
          !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
          this.isInstancedMesh &&
            ((n.type = 'InstancedMesh'),
            (n.count = this.count),
            (n.instanceMatrix = this.instanceMatrix.toJSON()),
            null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())),
          this.isScene)
        )
          this.background &&
            (this.background.isColor
              ? (n.background = this.background.toJSON())
              : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && (n.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
          n.geometry = s(e.geometries, this.geometry);
          const t = this.geometry.parameters;
          if (void 0 !== t && void 0 !== t.shapes) {
            const i = t.shapes;
            if (Array.isArray(i))
              for (let t = 0, n = i.length; t < n; t++) {
                const n = i[t];
                s(e.shapes, n);
              }
            else s(e.shapes, i);
          }
        }
        if (
          (this.isSkinnedMesh &&
            ((n.bindMode = this.bindMode),
            (n.bindMatrix = this.bindMatrix.toArray()),
            void 0 !== this.skeleton && (s(e.skeletons, this.skeleton), (n.skeleton = this.skeleton.uuid))),
          void 0 !== this.material)
        )
          if (Array.isArray(this.material)) {
            const t = [];
            for (let i = 0, n = this.material.length; i < n; i++) t.push(s(e.materials, this.material[i]));
            n.material = t;
          } else n.material = s(e.materials, this.material);
        if (this.children.length > 0) {
          n.children = [];
          for (let t = 0; t < this.children.length; t++) n.children.push(this.children[t].toJSON(e).object);
        }
        if (this.animations.length > 0) {
          n.animations = [];
          for (let t = 0; t < this.animations.length; t++) {
            const i = this.animations[t];
            n.animations.push(s(e.animations, i));
          }
        }
        if (t) {
          const t = r(e.geometries),
            n = r(e.materials),
            s = r(e.textures),
            a = r(e.images),
            o = r(e.shapes),
            l = r(e.skeletons),
            h = r(e.animations),
            c = r(e.nodes);
          t.length > 0 && (i.geometries = t),
            n.length > 0 && (i.materials = n),
            s.length > 0 && (i.textures = s),
            a.length > 0 && (i.images = a),
            o.length > 0 && (i.shapes = o),
            l.length > 0 && (i.skeletons = l),
            h.length > 0 && (i.animations = h),
            c.length > 0 && (i.nodes = c);
        }
        return (i.object = n), i;
        function r(e) {
          const t = [];
          for (const i in e) {
            const n = e[i];
            delete n.metadata, t.push(n);
          }
          return t;
        }
      }
      clone(e) {
        return new this.constructor().copy(this, e);
      }
      copy(e, t = !0) {
        if (
          ((this.name = e.name),
          this.up.copy(e.up),
          this.position.copy(e.position),
          (this.rotation.order = e.rotation.order),
          this.quaternion.copy(e.quaternion),
          this.scale.copy(e.scale),
          this.matrix.copy(e.matrix),
          this.matrixWorld.copy(e.matrixWorld),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
          (this.layers.mask = e.layers.mask),
          (this.visible = e.visible),
          (this.castShadow = e.castShadow),
          (this.receiveShadow = e.receiveShadow),
          (this.frustumCulled = e.frustumCulled),
          (this.renderOrder = e.renderOrder),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          !0 === t)
        )
          for (let t = 0; t < e.children.length; t++) {
            const i = e.children[t];
            this.add(i.clone());
          }
        return this;
      }
    }
    (It.DefaultUp = new Pe(0, 1, 0)), (It.DefaultMatrixAutoUpdate = !0);
    const Rt = new Pe(),
      Ot = new Pe(),
      Nt = new Pe(),
      zt = new Pe(),
      Ft = new Pe(),
      kt = new Pe(),
      Ut = new Pe(),
      Bt = new Pe(),
      Gt = new Pe(),
      Vt = new Pe();
    class Ht {
      constructor(e = new Pe(), t = new Pe(), i = new Pe()) {
        (this.a = e), (this.b = t), (this.c = i);
      }
      static getNormal(e, t, i, n) {
        n.subVectors(i, t), Rt.subVectors(e, t), n.cross(Rt);
        const s = n.lengthSq();
        return s > 0 ? n.multiplyScalar(1 / Math.sqrt(s)) : n.set(0, 0, 0);
      }
      static getBarycoord(e, t, i, n, s) {
        Rt.subVectors(n, t), Ot.subVectors(i, t), Nt.subVectors(e, t);
        const r = Rt.dot(Rt),
          a = Rt.dot(Ot),
          o = Rt.dot(Nt),
          l = Ot.dot(Ot),
          h = Ot.dot(Nt),
          c = r * l - a * a;
        if (0 === c) return s.set(-2, -1, -1);
        const u = 1 / c,
          d = (l * o - a * h) * u,
          m = (r * h - a * o) * u;
        return s.set(1 - d - m, m, d);
      }
      static containsPoint(e, t, i, n) {
        return this.getBarycoord(e, t, i, n, zt), zt.x >= 0 && zt.y >= 0 && zt.x + zt.y <= 1;
      }
      static getUV(e, t, i, n, s, r, a, o) {
        return (
          this.getBarycoord(e, t, i, n, zt),
          o.set(0, 0),
          o.addScaledVector(s, zt.x),
          o.addScaledVector(r, zt.y),
          o.addScaledVector(a, zt.z),
          o
        );
      }
      static isFrontFacing(e, t, i, n) {
        return Rt.subVectors(i, t), Ot.subVectors(e, t), Rt.cross(Ot).dot(n) < 0;
      }
      set(e, t, i) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
      }
      setFromPointsAndIndices(e, t, i, n) {
        return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this;
      }
      setFromAttributeAndIndices(e, t, i, n) {
        return (
          this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, n), this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
      }
      getArea() {
        return Rt.subVectors(this.c, this.b), Ot.subVectors(this.a, this.b), 0.5 * Rt.cross(Ot).length();
      }
      getMidpoint(e) {
        return e
          .addVectors(this.a, this.b)
          .add(this.c)
          .multiplyScalar(1 / 3);
      }
      getNormal(e) {
        return Ht.getNormal(this.a, this.b, this.c, e);
      }
      getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c);
      }
      getBarycoord(e, t) {
        return Ht.getBarycoord(e, this.a, this.b, this.c, t);
      }
      getUV(e, t, i, n, s) {
        return Ht.getUV(e, this.a, this.b, this.c, t, i, n, s);
      }
      containsPoint(e) {
        return Ht.containsPoint(e, this.a, this.b, this.c);
      }
      isFrontFacing(e) {
        return Ht.isFrontFacing(this.a, this.b, this.c, e);
      }
      intersectsBox(e) {
        return e.intersectsTriangle(this);
      }
      closestPointToPoint(e, t) {
        const i = this.a,
          n = this.b,
          s = this.c;
        let r, a;
        Ft.subVectors(n, i), kt.subVectors(s, i), Bt.subVectors(e, i);
        const o = Ft.dot(Bt),
          l = kt.dot(Bt);
        if (o <= 0 && l <= 0) return t.copy(i);
        Gt.subVectors(e, n);
        const h = Ft.dot(Gt),
          c = kt.dot(Gt);
        if (h >= 0 && c <= h) return t.copy(n);
        const u = o * c - h * l;
        if (u <= 0 && o >= 0 && h <= 0) return (r = o / (o - h)), t.copy(i).addScaledVector(Ft, r);
        Vt.subVectors(e, s);
        const d = Ft.dot(Vt),
          m = kt.dot(Vt);
        if (m >= 0 && d <= m) return t.copy(s);
        const p = d * l - o * m;
        if (p <= 0 && l >= 0 && m <= 0) return (a = l / (l - m)), t.copy(i).addScaledVector(kt, a);
        const f = h * m - d * c;
        if (f <= 0 && c - h >= 0 && d - m >= 0)
          return Ut.subVectors(s, n), (a = (c - h) / (c - h + (d - m))), t.copy(n).addScaledVector(Ut, a);
        const g = 1 / (f + p + u);
        return (r = p * g), (a = u * g), t.copy(i).addScaledVector(Ft, r).addScaledVector(kt, a);
      }
      equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
      }
    }
    let jt = 0;
    class Wt extends W {
      constructor() {
        super(),
          (this.isMaterial = !0),
          Object.defineProperty(this, 'id', { value: jt++ }),
          (this.uuid = J()),
          (this.name = ''),
          (this.type = 'Material'),
          (this.blending = 1),
          (this.side = 0),
          (this.vertexColors = !1),
          (this.opacity = 1),
          (this.transparent = !1),
          (this.blendSrc = 204),
          (this.blendDst = 205),
          (this.blendEquation = s),
          (this.blendSrcAlpha = null),
          (this.blendDstAlpha = null),
          (this.blendEquationAlpha = null),
          (this.depthFunc = 3),
          (this.depthTest = !0),
          (this.depthWrite = !0),
          (this.stencilWriteMask = 255),
          (this.stencilFunc = 519),
          (this.stencilRef = 0),
          (this.stencilFuncMask = 255),
          (this.stencilFail = G),
          (this.stencilZFail = G),
          (this.stencilZPass = G),
          (this.stencilWrite = !1),
          (this.clippingPlanes = null),
          (this.clipIntersection = !1),
          (this.clipShadows = !1),
          (this.shadowSide = null),
          (this.colorWrite = !0),
          (this.precision = null),
          (this.polygonOffset = !1),
          (this.polygonOffsetFactor = 0),
          (this.polygonOffsetUnits = 0),
          (this.dithering = !1),
          (this.alphaToCoverage = !1),
          (this.premultipliedAlpha = !1),
          (this.visible = !0),
          (this.toneMapped = !0),
          (this.userData = {}),
          (this.version = 0),
          (this._alphaTest = 0);
      }
      get alphaTest() {
        return this._alphaTest;
      }
      set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
      }
      onBuild() {}
      onBeforeRender() {}
      onBeforeCompile() {}
      customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }
      setValues(e) {
        if (void 0 !== e)
          for (const t in e) {
            const i = e[t];
            if (void 0 === i) continue;
            if ('shading' === t) {
              this.flatShading = 1 === i;
              continue;
            }
            const n = this[t];
            void 0 !== n &&
              (n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : (this[t] = i));
          }
      }
      toJSON(e) {
        const t = void 0 === e || 'string' == typeof e;
        t && (e = { textures: {}, images: {} });
        const i = { metadata: { version: 4.5, type: 'Material', generator: 'Material.toJSON' } };
        function n(e) {
          const t = [];
          for (const i in e) {
            const n = e[i];
            delete n.metadata, t.push(n);
          }
          return t;
        }
        if (
          ((i.uuid = this.uuid),
          (i.type = this.type),
          '' !== this.name && (i.name = this.name),
          this.color && this.color.isColor && (i.color = this.color.getHex()),
          void 0 !== this.roughness && (i.roughness = this.roughness),
          void 0 !== this.metalness && (i.metalness = this.metalness),
          void 0 !== this.sheen && (i.sheen = this.sheen),
          this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
          void 0 !== this.sheenRoughness && (i.sheenRoughness = this.sheenRoughness),
          this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
          this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity),
          this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
          void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity),
          this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
          void 0 !== this.shininess && (i.shininess = this.shininess),
          void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
          void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness),
          this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
          this.clearcoatRoughnessMap &&
            this.clearcoatRoughnessMap.isTexture &&
            (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
          this.clearcoatNormalMap &&
            this.clearcoatNormalMap.isTexture &&
            ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
            (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
          void 0 !== this.iridescence && (i.iridescence = this.iridescence),
          void 0 !== this.iridescenceIOR && (i.iridescenceIOR = this.iridescenceIOR),
          void 0 !== this.iridescenceThicknessRange && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
          this.iridescenceMap &&
            this.iridescenceMap.isTexture &&
            (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
          this.iridescenceThicknessMap &&
            this.iridescenceThicknessMap.isTexture &&
            (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
          this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
          this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
          this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
          this.lightMap &&
            this.lightMap.isTexture &&
            ((i.lightMap = this.lightMap.toJSON(e).uuid), (i.lightMapIntensity = this.lightMapIntensity)),
          this.aoMap &&
            this.aoMap.isTexture &&
            ((i.aoMap = this.aoMap.toJSON(e).uuid), (i.aoMapIntensity = this.aoMapIntensity)),
          this.bumpMap &&
            this.bumpMap.isTexture &&
            ((i.bumpMap = this.bumpMap.toJSON(e).uuid), (i.bumpScale = this.bumpScale)),
          this.normalMap &&
            this.normalMap.isTexture &&
            ((i.normalMap = this.normalMap.toJSON(e).uuid),
            (i.normalMapType = this.normalMapType),
            (i.normalScale = this.normalScale.toArray())),
          this.displacementMap &&
            this.displacementMap.isTexture &&
            ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
            (i.displacementScale = this.displacementScale),
            (i.displacementBias = this.displacementBias)),
          this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
          this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
          this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
          this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
          this.specularIntensityMap &&
            this.specularIntensityMap.isTexture &&
            (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
          this.specularColorMap &&
            this.specularColorMap.isTexture &&
            (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
          this.envMap &&
            this.envMap.isTexture &&
            ((i.envMap = this.envMap.toJSON(e).uuid), void 0 !== this.combine && (i.combine = this.combine)),
          void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity),
          void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity),
          void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio),
          this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
          void 0 !== this.transmission && (i.transmission = this.transmission),
          this.transmissionMap &&
            this.transmissionMap.isTexture &&
            (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
          void 0 !== this.thickness && (i.thickness = this.thickness),
          this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
          void 0 !== this.attenuationDistance && (i.attenuationDistance = this.attenuationDistance),
          void 0 !== this.attenuationColor && (i.attenuationColor = this.attenuationColor.getHex()),
          void 0 !== this.size && (i.size = this.size),
          null !== this.shadowSide && (i.shadowSide = this.shadowSide),
          void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation),
          1 !== this.blending && (i.blending = this.blending),
          0 !== this.side && (i.side = this.side),
          this.vertexColors && (i.vertexColors = !0),
          this.opacity < 1 && (i.opacity = this.opacity),
          !0 === this.transparent && (i.transparent = this.transparent),
          (i.depthFunc = this.depthFunc),
          (i.depthTest = this.depthTest),
          (i.depthWrite = this.depthWrite),
          (i.colorWrite = this.colorWrite),
          (i.stencilWrite = this.stencilWrite),
          (i.stencilWriteMask = this.stencilWriteMask),
          (i.stencilFunc = this.stencilFunc),
          (i.stencilRef = this.stencilRef),
          (i.stencilFuncMask = this.stencilFuncMask),
          (i.stencilFail = this.stencilFail),
          (i.stencilZFail = this.stencilZFail),
          (i.stencilZPass = this.stencilZPass),
          void 0 !== this.rotation && 0 !== this.rotation && (i.rotation = this.rotation),
          !0 === this.polygonOffset && (i.polygonOffset = !0),
          0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor),
          0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits),
          void 0 !== this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth),
          void 0 !== this.dashSize && (i.dashSize = this.dashSize),
          void 0 !== this.gapSize && (i.gapSize = this.gapSize),
          void 0 !== this.scale && (i.scale = this.scale),
          !0 === this.dithering && (i.dithering = !0),
          this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
          !0 === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage),
          !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha),
          !0 === this.wireframe && (i.wireframe = this.wireframe),
          this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
          'round' !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap),
          'round' !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin),
          !0 === this.flatShading && (i.flatShading = this.flatShading),
          !1 === this.visible && (i.visible = !1),
          !1 === this.toneMapped && (i.toneMapped = !1),
          !1 === this.fog && (i.fog = !1),
          '{}' !== JSON.stringify(this.userData) && (i.userData = this.userData),
          t)
        ) {
          const t = n(e.textures),
            s = n(e.images);
          t.length > 0 && (i.textures = t), s.length > 0 && (i.images = s);
        }
        return i;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        (this.name = e.name),
          (this.blending = e.blending),
          (this.side = e.side),
          (this.vertexColors = e.vertexColors),
          (this.opacity = e.opacity),
          (this.transparent = e.transparent),
          (this.blendSrc = e.blendSrc),
          (this.blendDst = e.blendDst),
          (this.blendEquation = e.blendEquation),
          (this.blendSrcAlpha = e.blendSrcAlpha),
          (this.blendDstAlpha = e.blendDstAlpha),
          (this.blendEquationAlpha = e.blendEquationAlpha),
          (this.depthFunc = e.depthFunc),
          (this.depthTest = e.depthTest),
          (this.depthWrite = e.depthWrite),
          (this.stencilWriteMask = e.stencilWriteMask),
          (this.stencilFunc = e.stencilFunc),
          (this.stencilRef = e.stencilRef),
          (this.stencilFuncMask = e.stencilFuncMask),
          (this.stencilFail = e.stencilFail),
          (this.stencilZFail = e.stencilZFail),
          (this.stencilZPass = e.stencilZPass),
          (this.stencilWrite = e.stencilWrite);
        const t = e.clippingPlanes;
        let i = null;
        if (null !== t) {
          const e = t.length;
          i = new Array(e);
          for (let n = 0; n !== e; ++n) i[n] = t[n].clone();
        }
        return (
          (this.clippingPlanes = i),
          (this.clipIntersection = e.clipIntersection),
          (this.clipShadows = e.clipShadows),
          (this.shadowSide = e.shadowSide),
          (this.colorWrite = e.colorWrite),
          (this.precision = e.precision),
          (this.polygonOffset = e.polygonOffset),
          (this.polygonOffsetFactor = e.polygonOffsetFactor),
          (this.polygonOffsetUnits = e.polygonOffsetUnits),
          (this.dithering = e.dithering),
          (this.alphaTest = e.alphaTest),
          (this.alphaToCoverage = e.alphaToCoverage),
          (this.premultipliedAlpha = e.premultipliedAlpha),
          (this.visible = e.visible),
          (this.toneMapped = e.toneMapped),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          this
        );
      }
      dispose() {
        this.dispatchEvent({ type: 'dispose' });
      }
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
    }
    class Xt extends Wt {
      constructor(e) {
        super(),
          (this.isMeshBasicMaterial = !0),
          (this.type = 'MeshBasicMaterial'),
          (this.color = new ve(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = 0),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = 'round'),
          (this.wireframeLinejoin = 'round'),
          (this.fog = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          (this.specularMap = e.specularMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.combine = e.combine),
          (this.reflectivity = e.reflectivity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.fog = e.fog),
          this
        );
      }
    }
    const qt = new Pe(),
      Yt = new se();
    class Zt {
      constructor(e, t, i) {
        if (Array.isArray(e)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        (this.isBufferAttribute = !0),
          (this.name = ''),
          (this.array = e),
          (this.itemSize = t),
          (this.count = void 0 !== e ? e.length / t : 0),
          (this.normalized = !0 === i),
          (this.usage = V),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0);
      }
      onUploadCallback() {}
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
      setUsage(e) {
        return (this.usage = e), this;
      }
      copy(e) {
        return (
          (this.name = e.name),
          (this.array = new e.array.constructor(e.array)),
          (this.itemSize = e.itemSize),
          (this.count = e.count),
          (this.normalized = e.normalized),
          (this.usage = e.usage),
          this
        );
      }
      copyAt(e, t, i) {
        (e *= this.itemSize), (i *= t.itemSize);
        for (let n = 0, s = this.itemSize; n < s; n++) this.array[e + n] = t.array[i + n];
        return this;
      }
      copyArray(e) {
        return this.array.set(e), this;
      }
      copyColorsArray(e) {
        const t = this.array;
        let i = 0;
        for (let n = 0, s = e.length; n < s; n++) {
          let s = e[n];
          void 0 === s && (s = new ve()), (t[i++] = s.r), (t[i++] = s.g), (t[i++] = s.b);
        }
        return this;
      }
      copyVector2sArray(e) {
        const t = this.array;
        let i = 0;
        for (let n = 0, s = e.length; n < s; n++) {
          let s = e[n];
          void 0 === s && (s = new se()), (t[i++] = s.x), (t[i++] = s.y);
        }
        return this;
      }
      copyVector3sArray(e) {
        const t = this.array;
        let i = 0;
        for (let n = 0, s = e.length; n < s; n++) {
          let s = e[n];
          void 0 === s && (s = new Pe()), (t[i++] = s.x), (t[i++] = s.y), (t[i++] = s.z);
        }
        return this;
      }
      copyVector4sArray(e) {
        const t = this.array;
        let i = 0;
        for (let n = 0, s = e.length; n < s; n++) {
          let s = e[n];
          void 0 === s && (s = new Ae()), (t[i++] = s.x), (t[i++] = s.y), (t[i++] = s.z), (t[i++] = s.w);
        }
        return this;
      }
      applyMatrix3(e) {
        if (2 === this.itemSize)
          for (let t = 0, i = this.count; t < i; t++)
            Yt.fromBufferAttribute(this, t), Yt.applyMatrix3(e), this.setXY(t, Yt.x, Yt.y);
        else if (3 === this.itemSize)
          for (let t = 0, i = this.count; t < i; t++)
            qt.fromBufferAttribute(this, t), qt.applyMatrix3(e), this.setXYZ(t, qt.x, qt.y, qt.z);
        return this;
      }
      applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++)
          qt.fromBufferAttribute(this, t), qt.applyMatrix4(e), this.setXYZ(t, qt.x, qt.y, qt.z);
        return this;
      }
      applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
          qt.fromBufferAttribute(this, t), qt.applyNormalMatrix(e), this.setXYZ(t, qt.x, qt.y, qt.z);
        return this;
      }
      transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
          qt.fromBufferAttribute(this, t), qt.transformDirection(e), this.setXYZ(t, qt.x, qt.y, qt.z);
        return this;
      }
      set(e, t = 0) {
        return this.array.set(e, t), this;
      }
      getX(e) {
        return this.array[e * this.itemSize];
      }
      setX(e, t) {
        return (this.array[e * this.itemSize] = t), this;
      }
      getY(e) {
        return this.array[e * this.itemSize + 1];
      }
      setY(e, t) {
        return (this.array[e * this.itemSize + 1] = t), this;
      }
      getZ(e) {
        return this.array[e * this.itemSize + 2];
      }
      setZ(e, t) {
        return (this.array[e * this.itemSize + 2] = t), this;
      }
      getW(e) {
        return this.array[e * this.itemSize + 3];
      }
      setW(e, t) {
        return (this.array[e * this.itemSize + 3] = t), this;
      }
      setXY(e, t, i) {
        return (e *= this.itemSize), (this.array[e + 0] = t), (this.array[e + 1] = i), this;
      }
      setXYZ(e, t, i, n) {
        return (e *= this.itemSize), (this.array[e + 0] = t), (this.array[e + 1] = i), (this.array[e + 2] = n), this;
      }
      setXYZW(e, t, i, n, s) {
        return (
          (e *= this.itemSize),
          (this.array[e + 0] = t),
          (this.array[e + 1] = i),
          (this.array[e + 2] = n),
          (this.array[e + 3] = s),
          this
        );
      }
      onUpload(e) {
        return (this.onUploadCallback = e), this;
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
      toJSON() {
        const e = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.from(this.array),
          normalized: this.normalized,
        };
        return (
          '' !== this.name && (e.name = this.name),
          this.usage !== V && (e.usage = this.usage),
          (0 === this.updateRange.offset && -1 === this.updateRange.count) || (e.updateRange = this.updateRange),
          e
        );
      }
    }
    class Jt extends Zt {
      constructor(e, t, i) {
        super(new Uint16Array(e), t, i);
      }
    }
    class Kt extends Zt {
      constructor(e, t, i) {
        super(new Uint32Array(e), t, i);
      }
    }
    class $t extends Zt {
      constructor(e, t, i) {
        super(new Float32Array(e), t, i);
      }
    }
    let Qt = 0;
    const ei = new ot(),
      ti = new It(),
      ii = new Pe(),
      ni = new Re(),
      si = new Re(),
      ri = new Pe();
    class ai extends W {
      constructor() {
        super(),
          (this.isBufferGeometry = !0),
          Object.defineProperty(this, 'id', { value: Qt++ }),
          (this.uuid = J()),
          (this.name = ''),
          (this.type = 'BufferGeometry'),
          (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.morphTargetsRelative = !1),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.drawRange = { start: 0, count: 1 / 0 }),
          (this.userData = {});
      }
      getIndex() {
        return this.index;
      }
      setIndex(e) {
        return Array.isArray(e) ? (this.index = new (ae(e) ? Kt : Jt)(e, 1)) : (this.index = e), this;
      }
      getAttribute(e) {
        return this.attributes[e];
      }
      setAttribute(e, t) {
        return (this.attributes[e] = t), this;
      }
      deleteAttribute(e) {
        return delete this.attributes[e], this;
      }
      hasAttribute(e) {
        return void 0 !== this.attributes[e];
      }
      addGroup(e, t, i = 0) {
        this.groups.push({ start: e, count: t, materialIndex: i });
      }
      clearGroups() {
        this.groups = [];
      }
      setDrawRange(e, t) {
        (this.drawRange.start = e), (this.drawRange.count = t);
      }
      applyMatrix4(e) {
        const t = this.attributes.position;
        void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
        const i = this.attributes.normal;
        if (void 0 !== i) {
          const t = new re().getNormalMatrix(e);
          i.applyNormalMatrix(t), (i.needsUpdate = !0);
        }
        const n = this.attributes.tangent;
        return (
          void 0 !== n && (n.transformDirection(e), (n.needsUpdate = !0)),
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          this
        );
      }
      applyQuaternion(e) {
        return ei.makeRotationFromQuaternion(e), this.applyMatrix4(ei), this;
      }
      rotateX(e) {
        return ei.makeRotationX(e), this.applyMatrix4(ei), this;
      }
      rotateY(e) {
        return ei.makeRotationY(e), this.applyMatrix4(ei), this;
      }
      rotateZ(e) {
        return ei.makeRotationZ(e), this.applyMatrix4(ei), this;
      }
      translate(e, t, i) {
        return ei.makeTranslation(e, t, i), this.applyMatrix4(ei), this;
      }
      scale(e, t, i) {
        return ei.makeScale(e, t, i), this.applyMatrix4(ei), this;
      }
      lookAt(e) {
        return ti.lookAt(e), ti.updateMatrix(), this.applyMatrix4(ti.matrix), this;
      }
      center() {
        return (
          this.computeBoundingBox(), this.boundingBox.getCenter(ii).negate(), this.translate(ii.x, ii.y, ii.z), this
        );
      }
      setFromPoints(e) {
        const t = [];
        for (let i = 0, n = e.length; i < n; i++) {
          const n = e[i];
          t.push(n.x, n.y, n.z || 0);
        }
        return this.setAttribute('position', new $t(t, 3)), this;
      }
      computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new Re());
        const e = this.attributes.position,
          t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute)
          this.boundingBox.set(new Pe(-1 / 0, -1 / 0, -1 / 0), new Pe(1 / 0, 1 / 0, 1 / 0));
        else {
          if (void 0 !== e) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e];
                ni.setFromBufferAttribute(i),
                  this.morphTargetsRelative
                    ? (ri.addVectors(this.boundingBox.min, ni.min),
                      this.boundingBox.expandByPoint(ri),
                      ri.addVectors(this.boundingBox.max, ni.max),
                      this.boundingBox.expandByPoint(ri))
                    : (this.boundingBox.expandByPoint(ni.min), this.boundingBox.expandByPoint(ni.max));
              }
          } else this.boundingBox.makeEmpty();
          isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z);
        }
      }
      computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new $e());
        const e = this.attributes.position,
          t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) this.boundingSphere.set(new Pe(), 1 / 0);
        else if (e) {
          const i = this.boundingSphere.center;
          if ((ni.setFromBufferAttribute(e), t))
            for (let e = 0, i = t.length; e < i; e++) {
              const i = t[e];
              si.setFromBufferAttribute(i),
                this.morphTargetsRelative
                  ? (ri.addVectors(ni.min, si.min),
                    ni.expandByPoint(ri),
                    ri.addVectors(ni.max, si.max),
                    ni.expandByPoint(ri))
                  : (ni.expandByPoint(si.min), ni.expandByPoint(si.max));
            }
          ni.getCenter(i);
          let n = 0;
          for (let t = 0, s = e.count; t < s; t++)
            ri.fromBufferAttribute(e, t), (n = Math.max(n, i.distanceToSquared(ri)));
          if (t)
            for (let s = 0, r = t.length; s < r; s++) {
              const r = t[s],
                a = this.morphTargetsRelative;
              for (let t = 0, s = r.count; t < s; t++)
                ri.fromBufferAttribute(r, t),
                  a && (ii.fromBufferAttribute(e, t), ri.add(ii)),
                  (n = Math.max(n, i.distanceToSquared(ri)));
            }
          (this.boundingSphere.radius = Math.sqrt(n)), isNaN(this.boundingSphere.radius);
        }
      }
      computeTangents() {
        const e = this.index,
          t = this.attributes;
        if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return;
        const i = e.array,
          n = t.position.array,
          s = t.normal.array,
          r = t.uv.array,
          a = n.length / 3;
        !1 === this.hasAttribute('tangent') && this.setAttribute('tangent', new Zt(new Float32Array(4 * a), 4));
        const o = this.getAttribute('tangent').array,
          l = [],
          h = [];
        for (let e = 0; e < a; e++) (l[e] = new Pe()), (h[e] = new Pe());
        const c = new Pe(),
          u = new Pe(),
          d = new Pe(),
          m = new se(),
          p = new se(),
          f = new se(),
          g = new Pe(),
          _ = new Pe();
        function v(e, t, i) {
          c.fromArray(n, 3 * e),
            u.fromArray(n, 3 * t),
            d.fromArray(n, 3 * i),
            m.fromArray(r, 2 * e),
            p.fromArray(r, 2 * t),
            f.fromArray(r, 2 * i),
            u.sub(c),
            d.sub(c),
            p.sub(m),
            f.sub(m);
          const s = 1 / (p.x * f.y - f.x * p.y);
          isFinite(s) &&
            (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -p.y).multiplyScalar(s),
            _.copy(d).multiplyScalar(p.x).addScaledVector(u, -f.x).multiplyScalar(s),
            l[e].add(g),
            l[t].add(g),
            l[i].add(g),
            h[e].add(_),
            h[t].add(_),
            h[i].add(_));
        }
        let x = this.groups;
        0 === x.length && (x = [{ start: 0, count: i.length }]);
        for (let e = 0, t = x.length; e < t; ++e) {
          const t = x[e],
            n = t.start;
          for (let e = n, s = n + t.count; e < s; e += 3) v(i[e + 0], i[e + 1], i[e + 2]);
        }
        const y = new Pe(),
          M = new Pe(),
          b = new Pe(),
          S = new Pe();
        function w(e) {
          b.fromArray(s, 3 * e), S.copy(b);
          const t = l[e];
          y.copy(t), y.sub(b.multiplyScalar(b.dot(t))).normalize(), M.crossVectors(S, t);
          const i = M.dot(h[e]) < 0 ? -1 : 1;
          (o[4 * e] = y.x), (o[4 * e + 1] = y.y), (o[4 * e + 2] = y.z), (o[4 * e + 3] = i);
        }
        for (let e = 0, t = x.length; e < t; ++e) {
          const t = x[e],
            n = t.start;
          for (let e = n, s = n + t.count; e < s; e += 3) w(i[e + 0]), w(i[e + 1]), w(i[e + 2]);
        }
      }
      computeVertexNormals() {
        const e = this.index,
          t = this.getAttribute('position');
        if (void 0 !== t) {
          let i = this.getAttribute('normal');
          if (void 0 === i) (i = new Zt(new Float32Array(3 * t.count), 3)), this.setAttribute('normal', i);
          else for (let e = 0, t = i.count; e < t; e++) i.setXYZ(e, 0, 0, 0);
          const n = new Pe(),
            s = new Pe(),
            r = new Pe(),
            a = new Pe(),
            o = new Pe(),
            l = new Pe(),
            h = new Pe(),
            c = new Pe();
          if (e)
            for (let u = 0, d = e.count; u < d; u += 3) {
              const d = e.getX(u + 0),
                m = e.getX(u + 1),
                p = e.getX(u + 2);
              n.fromBufferAttribute(t, d),
                s.fromBufferAttribute(t, m),
                r.fromBufferAttribute(t, p),
                h.subVectors(r, s),
                c.subVectors(n, s),
                h.cross(c),
                a.fromBufferAttribute(i, d),
                o.fromBufferAttribute(i, m),
                l.fromBufferAttribute(i, p),
                a.add(h),
                o.add(h),
                l.add(h),
                i.setXYZ(d, a.x, a.y, a.z),
                i.setXYZ(m, o.x, o.y, o.z),
                i.setXYZ(p, l.x, l.y, l.z);
            }
          else
            for (let e = 0, a = t.count; e < a; e += 3)
              n.fromBufferAttribute(t, e + 0),
                s.fromBufferAttribute(t, e + 1),
                r.fromBufferAttribute(t, e + 2),
                h.subVectors(r, s),
                c.subVectors(n, s),
                h.cross(c),
                i.setXYZ(e + 0, h.x, h.y, h.z),
                i.setXYZ(e + 1, h.x, h.y, h.z),
                i.setXYZ(e + 2, h.x, h.y, h.z);
          this.normalizeNormals(), (i.needsUpdate = !0);
        }
      }
      merge(e, t) {
        if (!e || !e.isBufferGeometry) return;
        void 0 === t && (t = 0);
        const i = this.attributes;
        for (const n in i) {
          if (void 0 === e.attributes[n]) continue;
          const s = i[n].array,
            r = e.attributes[n],
            a = r.array,
            o = r.itemSize * t,
            l = Math.min(a.length, s.length - o);
          for (let e = 0, t = o; e < l; e++, t++) s[t] = a[e];
        }
        return this;
      }
      normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++)
          ri.fromBufferAttribute(e, t), ri.normalize(), e.setXYZ(t, ri.x, ri.y, ri.z);
      }
      toNonIndexed() {
        function e(e, t) {
          const i = e.array,
            n = e.itemSize,
            s = e.normalized,
            r = new i.constructor(t.length * n);
          let a = 0,
            o = 0;
          for (let s = 0, l = t.length; s < l; s++) {
            a = e.isInterleavedBufferAttribute ? t[s] * e.data.stride + e.offset : t[s] * n;
            for (let e = 0; e < n; e++) r[o++] = i[a++];
          }
          return new Zt(r, n, s);
        }
        if (null === this.index) return this;
        const t = new ai(),
          i = this.index.array,
          n = this.attributes;
        for (const s in n) {
          const r = e(n[s], i);
          t.setAttribute(s, r);
        }
        const s = this.morphAttributes;
        for (const n in s) {
          const r = [],
            a = s[n];
          for (let t = 0, n = a.length; t < n; t++) {
            const n = e(a[t], i);
            r.push(n);
          }
          t.morphAttributes[n] = r;
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const r = this.groups;
        for (let e = 0, i = r.length; e < i; e++) {
          const i = r[e];
          t.addGroup(i.start, i.count, i.materialIndex);
        }
        return t;
      }
      toJSON() {
        const e = { metadata: { version: 4.5, type: 'BufferGeometry', generator: 'BufferGeometry.toJSON' } };
        if (
          ((e.uuid = this.uuid),
          (e.type = this.type),
          '' !== this.name && (e.name = this.name),
          Object.keys(this.userData).length > 0 && (e.userData = this.userData),
          void 0 !== this.parameters)
        ) {
          const t = this.parameters;
          for (const i in t) void 0 !== t[i] && (e[i] = t[i]);
          return e;
        }
        e.data = { attributes: {} };
        const t = this.index;
        null !== t && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) });
        const i = this.attributes;
        for (const t in i) {
          const n = i[t];
          e.data.attributes[t] = n.toJSON(e.data);
        }
        const n = {};
        let s = !1;
        for (const t in this.morphAttributes) {
          const i = this.morphAttributes[t],
            r = [];
          for (let t = 0, n = i.length; t < n; t++) {
            const n = i[t];
            r.push(n.toJSON(e.data));
          }
          r.length > 0 && ((n[t] = r), (s = !0));
        }
        s && ((e.data.morphAttributes = n), (e.data.morphTargetsRelative = this.morphTargetsRelative));
        const r = this.groups;
        r.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(r)));
        const a = this.boundingSphere;
        return null !== a && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null);
        const t = {};
        this.name = e.name;
        const i = e.index;
        null !== i && this.setIndex(i.clone(t));
        const n = e.attributes;
        for (const e in n) {
          const i = n[e];
          this.setAttribute(e, i.clone(t));
        }
        const s = e.morphAttributes;
        for (const e in s) {
          const i = [],
            n = s[e];
          for (let e = 0, s = n.length; e < s; e++) i.push(n[e].clone(t));
          this.morphAttributes[e] = i;
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const r = e.groups;
        for (let e = 0, t = r.length; e < t; e++) {
          const t = r[e];
          this.addGroup(t.start, t.count, t.materialIndex);
        }
        const a = e.boundingBox;
        null !== a && (this.boundingBox = a.clone());
        const o = e.boundingSphere;
        return (
          null !== o && (this.boundingSphere = o.clone()),
          (this.drawRange.start = e.drawRange.start),
          (this.drawRange.count = e.drawRange.count),
          (this.userData = e.userData),
          void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)),
          this
        );
      }
      dispose() {
        this.dispatchEvent({ type: 'dispose' });
      }
    }
    const oi = new ot(),
      li = new at(),
      hi = new $e(),
      ci = new Pe(),
      ui = new Pe(),
      di = new Pe(),
      mi = new Pe(),
      pi = new Pe(),
      fi = new Pe(),
      gi = new Pe(),
      _i = new Pe(),
      vi = new Pe(),
      xi = new se(),
      yi = new se(),
      Mi = new se(),
      bi = new Pe(),
      Si = new Pe();
    class wi extends It {
      constructor(e = new ai(), t = new Xt()) {
        super(),
          (this.isMesh = !0),
          (this.type = 'Mesh'),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
          void 0 !== e.morphTargetDictionary &&
            (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
          (this.material = e.material),
          (this.geometry = e.geometry),
          this
        );
      }
      updateMorphTargets() {
        const e = this.geometry.morphAttributes,
          t = Object.keys(e);
        if (t.length > 0) {
          const i = e[t[0]];
          if (void 0 !== i) {
            (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
            for (let e = 0, t = i.length; e < t; e++) {
              const t = i[e].name || String(e);
              this.morphTargetInfluences.push(0), (this.morphTargetDictionary[t] = e);
            }
          }
        }
      }
      raycast(e, t) {
        const i = this.geometry,
          n = this.material,
          s = this.matrixWorld;
        if (void 0 === n) return;
        if (
          (null === i.boundingSphere && i.computeBoundingSphere(),
          hi.copy(i.boundingSphere),
          hi.applyMatrix4(s),
          !1 === e.ray.intersectsSphere(hi))
        )
          return;
        if (
          (oi.copy(s).invert(),
          li.copy(e.ray).applyMatrix4(oi),
          null !== i.boundingBox && !1 === li.intersectsBox(i.boundingBox))
        )
          return;
        let r;
        const a = i.index,
          o = i.attributes.position,
          l = i.morphAttributes.position,
          h = i.morphTargetsRelative,
          c = i.attributes.uv,
          u = i.attributes.uv2,
          d = i.groups,
          m = i.drawRange;
        if (null !== a)
          if (Array.isArray(n))
            for (let i = 0, s = d.length; i < s; i++) {
              const s = d[i],
                p = n[s.materialIndex];
              for (
                let i = Math.max(s.start, m.start),
                  n = Math.min(a.count, Math.min(s.start + s.count, m.start + m.count));
                i < n;
                i += 3
              ) {
                const n = a.getX(i),
                  d = a.getX(i + 1),
                  m = a.getX(i + 2);
                (r = Ai(this, p, e, li, o, l, h, c, u, n, d, m)),
                  r && ((r.faceIndex = Math.floor(i / 3)), (r.face.materialIndex = s.materialIndex), t.push(r));
              }
            }
          else {
            for (let i = Math.max(0, m.start), s = Math.min(a.count, m.start + m.count); i < s; i += 3) {
              const s = a.getX(i),
                d = a.getX(i + 1),
                m = a.getX(i + 2);
              (r = Ai(this, n, e, li, o, l, h, c, u, s, d, m)), r && ((r.faceIndex = Math.floor(i / 3)), t.push(r));
            }
          }
        else if (void 0 !== o)
          if (Array.isArray(n))
            for (let i = 0, s = d.length; i < s; i++) {
              const s = d[i],
                a = n[s.materialIndex];
              for (
                let i = Math.max(s.start, m.start),
                  n = Math.min(o.count, Math.min(s.start + s.count, m.start + m.count));
                i < n;
                i += 3
              ) {
                (r = Ai(this, a, e, li, o, l, h, c, u, i, i + 1, i + 2)),
                  r && ((r.faceIndex = Math.floor(i / 3)), (r.face.materialIndex = s.materialIndex), t.push(r));
              }
            }
          else {
            for (let i = Math.max(0, m.start), s = Math.min(o.count, m.start + m.count); i < s; i += 3) {
              (r = Ai(this, n, e, li, o, l, h, c, u, i, i + 1, i + 2)),
                r && ((r.faceIndex = Math.floor(i / 3)), t.push(r));
            }
          }
      }
    }
    function Ai(e, t, i, n, s, r, a, o, l, h, c, u) {
      ci.fromBufferAttribute(s, h), ui.fromBufferAttribute(s, c), di.fromBufferAttribute(s, u);
      const d = e.morphTargetInfluences;
      if (r && d) {
        gi.set(0, 0, 0), _i.set(0, 0, 0), vi.set(0, 0, 0);
        for (let e = 0, t = r.length; e < t; e++) {
          const t = d[e],
            i = r[e];
          0 !== t &&
            (mi.fromBufferAttribute(i, h),
            pi.fromBufferAttribute(i, c),
            fi.fromBufferAttribute(i, u),
            a
              ? (gi.addScaledVector(mi, t), _i.addScaledVector(pi, t), vi.addScaledVector(fi, t))
              : (gi.addScaledVector(mi.sub(ci), t),
                _i.addScaledVector(pi.sub(ui), t),
                vi.addScaledVector(fi.sub(di), t)));
        }
        ci.add(gi), ui.add(_i), di.add(vi);
      }
      e.isSkinnedMesh && (e.boneTransform(h, ci), e.boneTransform(c, ui), e.boneTransform(u, di));
      const m = (function (e, t, i, n, s, r, a, o) {
        let l;
        if (
          ((l = 1 === t.side ? n.intersectTriangle(a, r, s, !0, o) : n.intersectTriangle(s, r, a, 2 !== t.side, o)),
          null === l)
        )
          return null;
        Si.copy(o), Si.applyMatrix4(e.matrixWorld);
        const h = i.ray.origin.distanceTo(Si);
        return h < i.near || h > i.far ? null : { distance: h, point: Si.clone(), object: e };
      })(e, t, i, n, ci, ui, di, bi);
      if (m) {
        o &&
          (xi.fromBufferAttribute(o, h),
          yi.fromBufferAttribute(o, c),
          Mi.fromBufferAttribute(o, u),
          (m.uv = Ht.getUV(bi, ci, ui, di, xi, yi, Mi, new se()))),
          l &&
            (xi.fromBufferAttribute(l, h),
            yi.fromBufferAttribute(l, c),
            Mi.fromBufferAttribute(l, u),
            (m.uv2 = Ht.getUV(bi, ci, ui, di, xi, yi, Mi, new se())));
        const e = { a: h, b: c, c: u, normal: new Pe(), materialIndex: 0 };
        Ht.getNormal(ci, ui, di, e.normal), (m.face = e);
      }
      return m;
    }
    class Ti extends ai {
      constructor(e = 1, t = 1, i = 1, n = 1, s = 1, r = 1) {
        super(),
          (this.type = 'BoxGeometry'),
          (this.parameters = { width: e, height: t, depth: i, widthSegments: n, heightSegments: s, depthSegments: r });
        const a = this;
        (n = Math.floor(n)), (s = Math.floor(s)), (r = Math.floor(r));
        const o = [],
          l = [],
          h = [],
          c = [];
        let u = 0,
          d = 0;
        function m(e, t, i, n, s, r, m, p, f, g, _) {
          const v = r / f,
            x = m / g,
            y = r / 2,
            M = m / 2,
            b = p / 2,
            S = f + 1,
            w = g + 1;
          let A = 0,
            T = 0;
          const E = new Pe();
          for (let r = 0; r < w; r++) {
            const a = r * x - M;
            for (let o = 0; o < S; o++) {
              const u = o * v - y;
              (E[e] = u * n),
                (E[t] = a * s),
                (E[i] = b),
                l.push(E.x, E.y, E.z),
                (E[e] = 0),
                (E[t] = 0),
                (E[i] = p > 0 ? 1 : -1),
                h.push(E.x, E.y, E.z),
                c.push(o / f),
                c.push(1 - r / g),
                (A += 1);
            }
          }
          for (let e = 0; e < g; e++)
            for (let t = 0; t < f; t++) {
              const i = u + t + S * e,
                n = u + t + S * (e + 1),
                s = u + (t + 1) + S * (e + 1),
                r = u + (t + 1) + S * e;
              o.push(i, n, r), o.push(n, s, r), (T += 6);
            }
          a.addGroup(d, T, _), (d += T), (u += A);
        }
        m('z', 'y', 'x', -1, -1, i, t, e, r, s, 0),
          m('z', 'y', 'x', 1, -1, i, t, -e, r, s, 1),
          m('x', 'z', 'y', 1, 1, e, i, t, n, r, 2),
          m('x', 'z', 'y', 1, -1, e, i, -t, n, r, 3),
          m('x', 'y', 'z', 1, -1, e, t, i, n, s, 4),
          m('x', 'y', 'z', -1, -1, e, t, -i, n, s, 5),
          this.setIndex(o),
          this.setAttribute('position', new $t(l, 3)),
          this.setAttribute('normal', new $t(h, 3)),
          this.setAttribute('uv', new $t(c, 2));
      }
      static fromJSON(e) {
        return new Ti(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
      }
    }
    function Ei(e) {
      const t = {};
      for (const i in e) {
        t[i] = {};
        for (const n in e[i]) {
          const s = e[i][n];
          s &&
          (s.isColor ||
            s.isMatrix3 ||
            s.isMatrix4 ||
            s.isVector2 ||
            s.isVector3 ||
            s.isVector4 ||
            s.isTexture ||
            s.isQuaternion)
            ? (t[i][n] = s.clone())
            : Array.isArray(s)
            ? (t[i][n] = s.slice())
            : (t[i][n] = s);
        }
      }
      return t;
    }
    function Li(e) {
      const t = {};
      for (let i = 0; i < e.length; i++) {
        const n = Ei(e[i]);
        for (const e in n) t[e] = n[e];
      }
      return t;
    }
    const Ci = { clone: Ei, merge: Li };
    class Pi extends Wt {
      constructor(e) {
        super(),
          (this.isShaderMaterial = !0),
          (this.type = 'ShaderMaterial'),
          (this.defines = {}),
          (this.uniforms = {}),
          (this.vertexShader =
            'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'),
          (this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'),
          (this.linewidth = 1),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          (this.clipping = !1),
          (this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }),
          (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }),
          (this.index0AttributeName = void 0),
          (this.uniformsNeedUpdate = !1),
          (this.glslVersion = null),
          void 0 !== e && (e.attributes, this.setValues(e));
      }
      copy(e) {
        return (
          super.copy(e),
          (this.fragmentShader = e.fragmentShader),
          (this.vertexShader = e.vertexShader),
          (this.uniforms = Ei(e.uniforms)),
          (this.defines = Object.assign({}, e.defines)),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.fog = e.fog),
          (this.lights = e.lights),
          (this.clipping = e.clipping),
          (this.extensions = Object.assign({}, e.extensions)),
          (this.glslVersion = e.glslVersion),
          this
        );
      }
      toJSON(e) {
        const t = super.toJSON(e);
        (t.glslVersion = this.glslVersion), (t.uniforms = {});
        for (const i in this.uniforms) {
          const n = this.uniforms[i].value;
          n && n.isTexture
            ? (t.uniforms[i] = { type: 't', value: n.toJSON(e).uuid })
            : n && n.isColor
            ? (t.uniforms[i] = { type: 'c', value: n.getHex() })
            : n && n.isVector2
            ? (t.uniforms[i] = { type: 'v2', value: n.toArray() })
            : n && n.isVector3
            ? (t.uniforms[i] = { type: 'v3', value: n.toArray() })
            : n && n.isVector4
            ? (t.uniforms[i] = { type: 'v4', value: n.toArray() })
            : n && n.isMatrix3
            ? (t.uniforms[i] = { type: 'm3', value: n.toArray() })
            : n && n.isMatrix4
            ? (t.uniforms[i] = { type: 'm4', value: n.toArray() })
            : (t.uniforms[i] = { value: n });
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
          (t.vertexShader = this.vertexShader),
          (t.fragmentShader = this.fragmentShader);
        const i = {};
        for (const e in this.extensions) !0 === this.extensions[e] && (i[e] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i), t;
      }
    }
    class Di extends It {
      constructor() {
        super(),
          (this.isCamera = !0),
          (this.type = 'Camera'),
          (this.matrixWorldInverse = new ot()),
          (this.projectionMatrix = new ot()),
          (this.projectionMatrixInverse = new ot());
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          this.matrixWorldInverse.copy(e.matrixWorldInverse),
          this.projectionMatrix.copy(e.projectionMatrix),
          this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
          this
        );
      }
      getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize();
      }
      updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    class Ii extends Di {
      constructor(e = 50, t = 1, i = 0.1, n = 2e3) {
        super(),
          (this.isPerspectiveCamera = !0),
          (this.type = 'PerspectiveCamera'),
          (this.fov = e),
          (this.zoom = 1),
          (this.near = i),
          (this.far = n),
          (this.focus = 10),
          (this.aspect = t),
          (this.view = null),
          (this.filmGauge = 35),
          (this.filmOffset = 0),
          this.updateProjectionMatrix();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.fov = e.fov),
          (this.zoom = e.zoom),
          (this.near = e.near),
          (this.far = e.far),
          (this.focus = e.focus),
          (this.aspect = e.aspect),
          (this.view = null === e.view ? null : Object.assign({}, e.view)),
          (this.filmGauge = e.filmGauge),
          (this.filmOffset = e.filmOffset),
          this
        );
      }
      setFocalLength(e) {
        const t = (0.5 * this.getFilmHeight()) / e;
        (this.fov = 2 * Z * Math.atan(t)), this.updateProjectionMatrix();
      }
      getFocalLength() {
        const e = Math.tan(0.5 * Y * this.fov);
        return (0.5 * this.getFilmHeight()) / e;
      }
      getEffectiveFOV() {
        return 2 * Z * Math.atan(Math.tan(0.5 * Y * this.fov) / this.zoom);
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      setViewOffset(e, t, i, n, s, r) {
        (this.aspect = e / t),
          null === this.view &&
            (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = t),
          (this.view.offsetX = i),
          (this.view.offsetY = n),
          (this.view.width = s),
          (this.view.height = r),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const e = this.near;
        let t = (e * Math.tan(0.5 * Y * this.fov)) / this.zoom,
          i = 2 * t,
          n = this.aspect * i,
          s = -0.5 * n;
        const r = this.view;
        if (null !== this.view && this.view.enabled) {
          const e = r.fullWidth,
            a = r.fullHeight;
          (s += (r.offsetX * n) / e), (t -= (r.offsetY * i) / a), (n *= r.width / e), (i *= r.height / a);
        }
        const a = this.filmOffset;
        0 !== a && (s += (e * a) / this.getFilmWidth()),
          this.projectionMatrix.makePerspective(s, s + n, t, t - i, e, this.far),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.fov = this.fov),
          (t.object.zoom = this.zoom),
          (t.object.near = this.near),
          (t.object.far = this.far),
          (t.object.focus = this.focus),
          (t.object.aspect = this.aspect),
          null !== this.view && (t.object.view = Object.assign({}, this.view)),
          (t.object.filmGauge = this.filmGauge),
          (t.object.filmOffset = this.filmOffset),
          t
        );
      }
    }
    const Ri = 90;
    class Oi extends It {
      constructor(e, t, i) {
        if ((super(), (this.type = 'CubeCamera'), !0 !== i.isWebGLCubeRenderTarget)) return;
        this.renderTarget = i;
        const n = new Ii(Ri, 1, e, t);
        (n.layers = this.layers), n.up.set(0, -1, 0), n.lookAt(new Pe(1, 0, 0)), this.add(n);
        const s = new Ii(Ri, 1, e, t);
        (s.layers = this.layers), s.up.set(0, -1, 0), s.lookAt(new Pe(-1, 0, 0)), this.add(s);
        const r = new Ii(Ri, 1, e, t);
        (r.layers = this.layers), r.up.set(0, 0, 1), r.lookAt(new Pe(0, 1, 0)), this.add(r);
        const a = new Ii(Ri, 1, e, t);
        (a.layers = this.layers), a.up.set(0, 0, -1), a.lookAt(new Pe(0, -1, 0)), this.add(a);
        const o = new Ii(Ri, 1, e, t);
        (o.layers = this.layers), o.up.set(0, -1, 0), o.lookAt(new Pe(0, 0, 1)), this.add(o);
        const l = new Ii(Ri, 1, e, t);
        (l.layers = this.layers), l.up.set(0, -1, 0), l.lookAt(new Pe(0, 0, -1)), this.add(l);
      }
      update(e, t) {
        null === this.parent && this.updateMatrixWorld();
        const i = this.renderTarget,
          [n, s, r, a, o, l] = this.children,
          h = e.getRenderTarget(),
          c = e.toneMapping,
          u = e.xr.enabled;
        (e.toneMapping = 0), (e.xr.enabled = !1);
        const d = i.texture.generateMipmaps;
        (i.texture.generateMipmaps = !1),
          e.setRenderTarget(i, 0),
          e.render(t, n),
          e.setRenderTarget(i, 1),
          e.render(t, s),
          e.setRenderTarget(i, 2),
          e.render(t, r),
          e.setRenderTarget(i, 3),
          e.render(t, a),
          e.setRenderTarget(i, 4),
          e.render(t, o),
          (i.texture.generateMipmaps = d),
          e.setRenderTarget(i, 5),
          e.render(t, l),
          e.setRenderTarget(h),
          (e.toneMapping = c),
          (e.xr.enabled = u),
          (i.texture.needsPMREMUpdate = !0);
      }
    }
    class Ni extends we {
      constructor(e, t, i, n, s, a, o, l, h, c) {
        super((e = void 0 !== e ? e : []), (t = void 0 !== t ? t : r), i, n, s, a, o, l, h, c),
          (this.isCubeTexture = !0),
          (this.flipY = !1);
      }
      get images() {
        return this.image;
      }
      set images(e) {
        this.image = e;
      }
    }
    class zi extends Te {
      constructor(e, t = {}) {
        super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
        const i = { width: e, height: e, depth: 1 },
          n = [i, i, i, i, i, i];
        (this.texture = new Ni(
          n,
          t.mapping,
          t.wrapS,
          t.wrapT,
          t.magFilter,
          t.minFilter,
          t.format,
          t.type,
          t.anisotropy,
          t.encoding,
        )),
          (this.texture.isRenderTargetTexture = !0),
          (this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps),
          (this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : g);
      }
      fromEquirectangularTexture(e, t) {
        (this.texture.type = t.type),
          (this.texture.encoding = t.encoding),
          (this.texture.generateMipmaps = t.generateMipmaps),
          (this.texture.minFilter = t.minFilter),
          (this.texture.magFilter = t.magFilter);
        const i = {
            uniforms: { tEquirect: { value: null } },
            vertexShader:
              '\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t',
            fragmentShader:
              '\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t',
          },
          n = new Ti(5, 5, 5),
          s = new Pi({
            name: 'CubemapFromEquirect',
            uniforms: Ei(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: 1,
            blending: 0,
          });
        s.uniforms.tEquirect.value = t;
        const r = new wi(n, s),
          a = t.minFilter;
        t.minFilter === v && (t.minFilter = g);
        return new Oi(1, 10, this).update(e, r), (t.minFilter = a), r.geometry.dispose(), r.material.dispose(), this;
      }
      clear(e, t, i, n) {
        const s = e.getRenderTarget();
        for (let s = 0; s < 6; s++) e.setRenderTarget(this, s), e.clear(t, i, n);
        e.setRenderTarget(s);
      }
    }
    const Fi = new Pe(),
      ki = new Pe(),
      Ui = new re();
    class Bi {
      constructor(e = new Pe(1, 0, 0), t = 0) {
        (this.isPlane = !0), (this.normal = e), (this.constant = t);
      }
      set(e, t) {
        return this.normal.copy(e), (this.constant = t), this;
      }
      setComponents(e, t, i, n) {
        return this.normal.set(e, t, i), (this.constant = n), this;
      }
      setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
      }
      setFromCoplanarPoints(e, t, i) {
        const n = Fi.subVectors(i, t).cross(ki.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(n, e), this;
      }
      copy(e) {
        return this.normal.copy(e.normal), (this.constant = e.constant), this;
      }
      normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), (this.constant *= e), this;
      }
      negate() {
        return (this.constant *= -1), this.normal.negate(), this;
      }
      distanceToPoint(e) {
        return this.normal.dot(e) + this.constant;
      }
      distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius;
      }
      projectPoint(e, t) {
        return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
      }
      intersectLine(e, t) {
        const i = e.delta(Fi),
          n = this.normal.dot(i);
        if (0 === n) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / n;
        return s < 0 || s > 1 ? null : t.copy(i).multiplyScalar(s).add(e.start);
      }
      intersectsLine(e) {
        const t = this.distanceToPoint(e.start),
          i = this.distanceToPoint(e.end);
        return (t < 0 && i > 0) || (i < 0 && t > 0);
      }
      intersectsBox(e) {
        return e.intersectsPlane(this);
      }
      intersectsSphere(e) {
        return e.intersectsPlane(this);
      }
      coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant);
      }
      applyMatrix4(e, t) {
        const i = t || Ui.getNormalMatrix(e),
          n = this.coplanarPoint(Fi).applyMatrix4(e),
          s = this.normal.applyMatrix3(i).normalize();
        return (this.constant = -n.dot(s)), this;
      }
      translate(e) {
        return (this.constant -= e.dot(this.normal)), this;
      }
      equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    const Gi = new $e(),
      Vi = new Pe();
    class Hi {
      constructor(e = new Bi(), t = new Bi(), i = new Bi(), n = new Bi(), s = new Bi(), r = new Bi()) {
        this.planes = [e, t, i, n, s, r];
      }
      set(e, t, i, n, s, r) {
        const a = this.planes;
        return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(n), a[4].copy(s), a[5].copy(r), this;
      }
      copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
        return this;
      }
      setFromProjectionMatrix(e) {
        const t = this.planes,
          i = e.elements,
          n = i[0],
          s = i[1],
          r = i[2],
          a = i[3],
          o = i[4],
          l = i[5],
          h = i[6],
          c = i[7],
          u = i[8],
          d = i[9],
          m = i[10],
          p = i[11],
          f = i[12],
          g = i[13],
          _ = i[14],
          v = i[15];
        return (
          t[0].setComponents(a - n, c - o, p - u, v - f).normalize(),
          t[1].setComponents(a + n, c + o, p + u, v + f).normalize(),
          t[2].setComponents(a + s, c + l, p + d, v + g).normalize(),
          t[3].setComponents(a - s, c - l, p - d, v - g).normalize(),
          t[4].setComponents(a - r, c - h, p - m, v - _).normalize(),
          t[5].setComponents(a + r, c + h, p + m, v + _).normalize(),
          this
        );
      }
      intersectsObject(e) {
        const t = e.geometry;
        return (
          null === t.boundingSphere && t.computeBoundingSphere(),
          Gi.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
          this.intersectsSphere(Gi)
        );
      }
      intersectsSprite(e) {
        return (
          Gi.center.set(0, 0, 0),
          (Gi.radius = 0.7071067811865476),
          Gi.applyMatrix4(e.matrixWorld),
          this.intersectsSphere(Gi)
        );
      }
      intersectsSphere(e) {
        const t = this.planes,
          i = e.center,
          n = -e.radius;
        for (let e = 0; e < 6; e++) {
          if (t[e].distanceToPoint(i) < n) return !1;
        }
        return !0;
      }
      intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
          const n = t[i];
          if (
            ((Vi.x = n.normal.x > 0 ? e.max.x : e.min.x),
            (Vi.y = n.normal.y > 0 ? e.max.y : e.min.y),
            (Vi.z = n.normal.z > 0 ? e.max.z : e.min.z),
            n.distanceToPoint(Vi) < 0)
          )
            return !1;
        }
        return !0;
      }
      containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
        return !0;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    function ji() {
      let e = null,
        t = !1,
        i = null,
        n = null;
      function s(t, r) {
        i(t, r), (n = e.requestAnimationFrame(s));
      }
      return {
        start: function () {
          !0 !== t && null !== i && ((n = e.requestAnimationFrame(s)), (t = !0));
        },
        stop: function () {
          e.cancelAnimationFrame(n), (t = !1);
        },
        setAnimationLoop: function (e) {
          i = e;
        },
        setContext: function (t) {
          e = t;
        },
      };
    }
    function Wi(e, t) {
      const i = t.isWebGL2,
        n = new WeakMap();
      return {
        get: function (e) {
          return e.isInterleavedBufferAttribute && (e = e.data), n.get(e);
        },
        remove: function (t) {
          t.isInterleavedBufferAttribute && (t = t.data);
          const i = n.get(t);
          i && (e.deleteBuffer(i.buffer), n.delete(t));
        },
        update: function (t, s) {
          if (t.isGLBufferAttribute) {
            const e = n.get(t);
            return void (
              (!e || e.version < t.version) &&
              n.set(t, { buffer: t.buffer, type: t.type, bytesPerElement: t.elementSize, version: t.version })
            );
          }
          t.isInterleavedBufferAttribute && (t = t.data);
          const r = n.get(t);
          void 0 === r
            ? n.set(
                t,
                (function (t, n) {
                  const s = t.array,
                    r = t.usage,
                    a = e.createBuffer();
                  let o;
                  if ((e.bindBuffer(n, a), e.bufferData(n, s, r), t.onUploadCallback(), s instanceof Float32Array))
                    o = 5126;
                  else if (s instanceof Uint16Array)
                    if (t.isFloat16BufferAttribute) {
                      if (!i)
                        throw new Error('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
                      o = 5131;
                    } else o = 5123;
                  else if (s instanceof Int16Array) o = 5122;
                  else if (s instanceof Uint32Array) o = 5125;
                  else if (s instanceof Int32Array) o = 5124;
                  else if (s instanceof Int8Array) o = 5120;
                  else if (s instanceof Uint8Array) o = 5121;
                  else {
                    if (!(s instanceof Uint8ClampedArray))
                      throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + s);
                    o = 5121;
                  }
                  return { buffer: a, type: o, bytesPerElement: s.BYTES_PER_ELEMENT, version: t.version };
                })(t, s),
              )
            : r.version < t.version &&
              (!(function (t, n, s) {
                const r = n.array,
                  a = n.updateRange;
                e.bindBuffer(s, t),
                  -1 === a.count
                    ? e.bufferSubData(s, 0, r)
                    : (i
                        ? e.bufferSubData(s, a.offset * r.BYTES_PER_ELEMENT, r, a.offset, a.count)
                        : e.bufferSubData(s, a.offset * r.BYTES_PER_ELEMENT, r.subarray(a.offset, a.offset + a.count)),
                      (a.count = -1));
              })(r.buffer, t, s),
              (r.version = t.version));
        },
      };
    }
    class Xi extends ai {
      constructor(e = 1, t = 1, i = 1, n = 1) {
        super(),
          (this.type = 'PlaneGeometry'),
          (this.parameters = { width: e, height: t, widthSegments: i, heightSegments: n });
        const s = e / 2,
          r = t / 2,
          a = Math.floor(i),
          o = Math.floor(n),
          l = a + 1,
          h = o + 1,
          c = e / a,
          u = t / o,
          d = [],
          m = [],
          p = [],
          f = [];
        for (let e = 0; e < h; e++) {
          const t = e * u - r;
          for (let i = 0; i < l; i++) {
            const n = i * c - s;
            m.push(n, -t, 0), p.push(0, 0, 1), f.push(i / a), f.push(1 - e / o);
          }
        }
        for (let e = 0; e < o; e++)
          for (let t = 0; t < a; t++) {
            const i = t + l * e,
              n = t + l * (e + 1),
              s = t + 1 + l * (e + 1),
              r = t + 1 + l * e;
            d.push(i, n, r), d.push(n, s, r);
          }
        this.setIndex(d),
          this.setAttribute('position', new $t(m, 3)),
          this.setAttribute('normal', new $t(p, 3)),
          this.setAttribute('uv', new $t(f, 2));
      }
      static fromJSON(e) {
        return new Xi(e.width, e.height, e.widthSegments, e.heightSegments);
      }
    }
    const qi = {
        alphamap_fragment: '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif',
        alphamap_pars_fragment: '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
        alphatest_fragment: '#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif',
        alphatest_pars_fragment: '#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif',
        aomap_fragment:
          '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif',
        aomap_pars_fragment: '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
        begin_vertex: 'vec3 transformed = vec3( position );',
        beginnormal_vertex:
          'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif',
        bsdfs:
          'vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif',
        iridescence_fragment:
          '#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif',
        bumpmap_pars_fragment:
          '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
        clipping_planes_fragment:
          '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif',
        clipping_planes_pars_fragment:
          '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
        clipping_planes_pars_vertex: '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif',
        clipping_planes_vertex: '#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif',
        color_fragment:
          '#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif',
        color_pars_fragment:
          '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif',
        color_pars_vertex:
          '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif',
        color_vertex:
          '#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif',
        common:
          '#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}',
        cube_uv_reflection_fragment:
          '#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif',
        defaultnormal_vertex:
          'vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif',
        displacementmap_pars_vertex:
          '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif',
        displacementmap_vertex:
          '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif',
        emissivemap_fragment:
          '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
        emissivemap_pars_fragment: '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif',
        encodings_fragment: 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
        encodings_pars_fragment:
          'vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}',
        envmap_fragment:
          '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif',
        envmap_common_pars_fragment:
          '#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif',
        envmap_pars_fragment:
          '#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
        envmap_pars_vertex:
          '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif',
        envmap_physical_pars_fragment:
          '#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif',
        envmap_vertex:
          '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif',
        fog_vertex: '#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif',
        fog_pars_vertex: '#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif',
        fog_fragment:
          '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
        fog_pars_fragment:
          '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
        gradientmap_pars_fragment:
          '#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}',
        lightmap_fragment:
          '#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif',
        lightmap_pars_fragment:
          '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
        lights_lambert_vertex:
          'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif',
        lights_pars_begin:
          'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif',
        lights_toon_fragment: 'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;',
        lights_toon_pars_fragment:
          'varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)',
        lights_phong_fragment:
          'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
        lights_phong_pars_fragment:
          'varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)',
        lights_physical_fragment:
          'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif',
        lights_physical_pars_fragment:
          'struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
        lights_fragment_begin:
          '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n\tmaterial.iridescence = 0.0;\n} else {\n\tmaterial.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
        lights_fragment_maps:
          '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif',
        lights_fragment_end:
          '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif',
        logdepthbuf_fragment:
          '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
        logdepthbuf_pars_fragment:
          '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
        logdepthbuf_pars_vertex:
          '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif',
        logdepthbuf_vertex:
          '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif',
        map_fragment:
          '#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif',
        map_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
        map_particle_fragment:
          '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
        map_particle_pars_fragment:
          '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
        metalnessmap_fragment:
          'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif',
        metalnessmap_pars_fragment: '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
        morphcolor_vertex:
          '#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif',
        morphnormal_vertex:
          '#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif',
        morphtarget_pars_vertex:
          '#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif',
        morphtarget_vertex:
          '#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif',
        normal_fragment_begin:
          'float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;',
        normal_fragment_maps:
          '#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif',
        normal_pars_fragment:
          '#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif',
        normal_pars_vertex:
          '#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif',
        normal_vertex:
          '#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif',
        normalmap_pars_fragment:
          '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif',
        clearcoat_normal_fragment_begin: '#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif',
        clearcoat_normal_fragment_maps:
          '#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif',
        clearcoat_pars_fragment:
          '#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif',
        iridescence_pars_fragment:
          '#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif',
        output_fragment:
          '#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );',
        packing:
          'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}',
        premultiplied_alpha_fragment: '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif',
        project_vertex:
          'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
        dithering_fragment: '#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
        dithering_pars_fragment:
          '#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif',
        roughnessmap_fragment:
          'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif',
        roughnessmap_pars_fragment: '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
        shadowmap_pars_fragment:
          '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif',
        shadowmap_pars_vertex:
          '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif',
        shadowmap_vertex:
          '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif',
        shadowmask_pars_fragment:
          'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}',
        skinbase_vertex:
          '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
        skinning_pars_vertex:
          '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif',
        skinning_vertex:
          '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
        skinnormal_vertex:
          '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif',
        specularmap_fragment:
          'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
        specularmap_pars_fragment: '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
        tonemapping_fragment:
          '#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
        tonemapping_pars_fragment:
          '#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }',
        transmission_fragment:
          '#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif',
        transmission_pars_fragment:
          '#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif',
        uv_pars_fragment: '#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif',
        uv_pars_vertex:
          '#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif',
        uv_vertex: '#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif',
        uv2_pars_fragment: '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',
        uv2_pars_vertex:
          '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif',
        uv2_vertex:
          '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif',
        worldpos_vertex:
          '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif',
        background_vert:
          'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
        background_frag:
          'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
        cube_vert:
          'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
        cube_frag:
          '#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
        depth_vert:
          '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}',
        depth_frag:
          '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}',
        distanceRGBA_vert:
          '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}',
        distanceRGBA_frag:
          '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}',
        equirect_vert:
          'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}',
        equirect_frag:
          'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
        linedashed_vert:
          'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
        linedashed_frag:
          'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
        meshbasic_vert:
          '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}',
        meshbasic_frag:
          'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
        meshlambert_vert:
          '#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
        meshlambert_frag:
          'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
        meshmatcap_vert:
          '#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}',
        meshmatcap_frag:
          '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
        meshnormal_vert:
          '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}',
        meshnormal_frag:
          '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}',
        meshphong_vert:
          '#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
        meshphong_frag:
          '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
        meshphysical_vert:
          '#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}',
        meshphysical_frag:
          '#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
        meshtoon_vert:
          '#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
        meshtoon_frag:
          '#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
        points_vert:
          'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}',
        points_frag:
          'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
        shadow_vert:
          '#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
        shadow_frag:
          'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
        sprite_vert:
          'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
        sprite_frag:
          'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
      },
      Yi = {
        common: {
          diffuse: { value: new ve(16777215) },
          opacity: { value: 1 },
          map: { value: null },
          uvTransform: { value: new re() },
          uv2Transform: { value: new re() },
          alphaMap: { value: null },
          alphaTest: { value: 0 },
        },
        specularmap: { specularMap: { value: null } },
        envmap: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          reflectivity: { value: 1 },
          ior: { value: 1.5 },
          refractionRatio: { value: 0.98 },
        },
        aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
        lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
        emissivemap: { emissiveMap: { value: null } },
        bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
        normalmap: { normalMap: { value: null }, normalScale: { value: new se(1, 1) } },
        displacementmap: {
          displacementMap: { value: null },
          displacementScale: { value: 1 },
          displacementBias: { value: 0 },
        },
        roughnessmap: { roughnessMap: { value: null } },
        metalnessmap: { metalnessMap: { value: null } },
        gradientmap: { gradientMap: { value: null } },
        fog: {
          fogDensity: { value: 25e-5 },
          fogNear: { value: 1 },
          fogFar: { value: 2e3 },
          fogColor: { value: new ve(16777215) },
        },
        lights: {
          ambientLightColor: { value: [] },
          lightProbe: { value: [] },
          directionalLights: { value: [], properties: { direction: {}, color: {} } },
          directionalLightShadows: {
            value: [],
            properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} },
          },
          directionalShadowMap: { value: [] },
          directionalShadowMatrix: { value: [] },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {},
            },
          },
          spotLightShadows: {
            value: [],
            properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} },
          },
          spotShadowMap: { value: [] },
          spotShadowMatrix: { value: [] },
          pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
          pointLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {},
            },
          },
          pointShadowMap: { value: [] },
          pointShadowMatrix: { value: [] },
          hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
          rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
          ltc_1: { value: null },
          ltc_2: { value: null },
        },
        points: {
          diffuse: { value: new ve(16777215) },
          opacity: { value: 1 },
          size: { value: 1 },
          scale: { value: 1 },
          map: { value: null },
          alphaMap: { value: null },
          alphaTest: { value: 0 },
          uvTransform: { value: new re() },
        },
        sprite: {
          diffuse: { value: new ve(16777215) },
          opacity: { value: 1 },
          center: { value: new se(0.5, 0.5) },
          rotation: { value: 0 },
          map: { value: null },
          alphaMap: { value: null },
          alphaTest: { value: 0 },
          uvTransform: { value: new re() },
        },
      },
      Zi = {
        basic: {
          uniforms: Li([Yi.common, Yi.specularmap, Yi.envmap, Yi.aomap, Yi.lightmap, Yi.fog]),
          vertexShader: qi.meshbasic_vert,
          fragmentShader: qi.meshbasic_frag,
        },
        lambert: {
          uniforms: Li([
            Yi.common,
            Yi.specularmap,
            Yi.envmap,
            Yi.aomap,
            Yi.lightmap,
            Yi.emissivemap,
            Yi.fog,
            Yi.lights,
            { emissive: { value: new ve(0) } },
          ]),
          vertexShader: qi.meshlambert_vert,
          fragmentShader: qi.meshlambert_frag,
        },
        phong: {
          uniforms: Li([
            Yi.common,
            Yi.specularmap,
            Yi.envmap,
            Yi.aomap,
            Yi.lightmap,
            Yi.emissivemap,
            Yi.bumpmap,
            Yi.normalmap,
            Yi.displacementmap,
            Yi.fog,
            Yi.lights,
            { emissive: { value: new ve(0) }, specular: { value: new ve(1118481) }, shininess: { value: 30 } },
          ]),
          vertexShader: qi.meshphong_vert,
          fragmentShader: qi.meshphong_frag,
        },
        standard: {
          uniforms: Li([
            Yi.common,
            Yi.envmap,
            Yi.aomap,
            Yi.lightmap,
            Yi.emissivemap,
            Yi.bumpmap,
            Yi.normalmap,
            Yi.displacementmap,
            Yi.roughnessmap,
            Yi.metalnessmap,
            Yi.fog,
            Yi.lights,
            {
              emissive: { value: new ve(0) },
              roughness: { value: 1 },
              metalness: { value: 0 },
              envMapIntensity: { value: 1 },
            },
          ]),
          vertexShader: qi.meshphysical_vert,
          fragmentShader: qi.meshphysical_frag,
        },
        toon: {
          uniforms: Li([
            Yi.common,
            Yi.aomap,
            Yi.lightmap,
            Yi.emissivemap,
            Yi.bumpmap,
            Yi.normalmap,
            Yi.displacementmap,
            Yi.gradientmap,
            Yi.fog,
            Yi.lights,
            { emissive: { value: new ve(0) } },
          ]),
          vertexShader: qi.meshtoon_vert,
          fragmentShader: qi.meshtoon_frag,
        },
        matcap: {
          uniforms: Li([Yi.common, Yi.bumpmap, Yi.normalmap, Yi.displacementmap, Yi.fog, { matcap: { value: null } }]),
          vertexShader: qi.meshmatcap_vert,
          fragmentShader: qi.meshmatcap_frag,
        },
        points: { uniforms: Li([Yi.points, Yi.fog]), vertexShader: qi.points_vert, fragmentShader: qi.points_frag },
        dashed: {
          uniforms: Li([Yi.common, Yi.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]),
          vertexShader: qi.linedashed_vert,
          fragmentShader: qi.linedashed_frag,
        },
        depth: {
          uniforms: Li([Yi.common, Yi.displacementmap]),
          vertexShader: qi.depth_vert,
          fragmentShader: qi.depth_frag,
        },
        normal: {
          uniforms: Li([Yi.common, Yi.bumpmap, Yi.normalmap, Yi.displacementmap, { opacity: { value: 1 } }]),
          vertexShader: qi.meshnormal_vert,
          fragmentShader: qi.meshnormal_frag,
        },
        sprite: { uniforms: Li([Yi.sprite, Yi.fog]), vertexShader: qi.sprite_vert, fragmentShader: qi.sprite_frag },
        background: {
          uniforms: { uvTransform: { value: new re() }, t2D: { value: null } },
          vertexShader: qi.background_vert,
          fragmentShader: qi.background_frag,
        },
        cube: {
          uniforms: Li([Yi.envmap, { opacity: { value: 1 } }]),
          vertexShader: qi.cube_vert,
          fragmentShader: qi.cube_frag,
        },
        equirect: {
          uniforms: { tEquirect: { value: null } },
          vertexShader: qi.equirect_vert,
          fragmentShader: qi.equirect_frag,
        },
        distanceRGBA: {
          uniforms: Li([
            Yi.common,
            Yi.displacementmap,
            { referencePosition: { value: new Pe() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } },
          ]),
          vertexShader: qi.distanceRGBA_vert,
          fragmentShader: qi.distanceRGBA_frag,
        },
        shadow: {
          uniforms: Li([Yi.lights, Yi.fog, { color: { value: new ve(0) }, opacity: { value: 1 } }]),
          vertexShader: qi.shadow_vert,
          fragmentShader: qi.shadow_frag,
        },
      };
    function Ji(e, t, i, n, s, r) {
      const a = new ve(0);
      let o,
        l,
        c = !0 === s ? 0 : 1,
        u = null,
        d = 0,
        m = null;
      function p(e, t) {
        i.buffers.color.setClear(e.r, e.g, e.b, t, r);
      }
      return {
        getClearColor: function () {
          return a;
        },
        setClearColor: function (e, t = 1) {
          a.set(e), (c = t), p(a, c);
        },
        getClearAlpha: function () {
          return c;
        },
        setClearAlpha: function (e) {
          (c = e), p(a, c);
        },
        render: function (i, s) {
          let r = !1,
            f = !0 === s.isScene ? s.background : null;
          f && f.isTexture && (f = t.get(f));
          const g = e.xr,
            _ = g.getSession && g.getSession();
          _ && 'additive' === _.environmentBlendMode && (f = null),
            null === f ? p(a, c) : f && f.isColor && (p(f, 1), (r = !0)),
            (e.autoClear || r) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
            f && (f.isCubeTexture || f.mapping === h)
              ? (void 0 === l &&
                  ((l = new wi(
                    new Ti(1, 1, 1),
                    new Pi({
                      name: 'BackgroundCubeMaterial',
                      uniforms: Ei(Zi.cube.uniforms),
                      vertexShader: Zi.cube.vertexShader,
                      fragmentShader: Zi.cube.fragmentShader,
                      side: 1,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    }),
                  )),
                  l.geometry.deleteAttribute('normal'),
                  l.geometry.deleteAttribute('uv'),
                  (l.onBeforeRender = function (e, t, i) {
                    this.matrixWorld.copyPosition(i.matrixWorld);
                  }),
                  Object.defineProperty(l.material, 'envMap', {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  n.update(l)),
                (l.material.uniforms.envMap.value = f),
                (l.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1),
                (u === f && d === f.version && m === e.toneMapping) ||
                  ((l.material.needsUpdate = !0), (u = f), (d = f.version), (m = e.toneMapping)),
                l.layers.enableAll(),
                i.unshift(l, l.geometry, l.material, 0, 0, null))
              : f &&
                f.isTexture &&
                (void 0 === o &&
                  ((o = new wi(
                    new Xi(2, 2),
                    new Pi({
                      name: 'BackgroundMaterial',
                      uniforms: Ei(Zi.background.uniforms),
                      vertexShader: Zi.background.vertexShader,
                      fragmentShader: Zi.background.fragmentShader,
                      side: 0,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    }),
                  )),
                  o.geometry.deleteAttribute('normal'),
                  Object.defineProperty(o.material, 'map', {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  n.update(o)),
                (o.material.uniforms.t2D.value = f),
                !0 === f.matrixAutoUpdate && f.updateMatrix(),
                o.material.uniforms.uvTransform.value.copy(f.matrix),
                (u === f && d === f.version && m === e.toneMapping) ||
                  ((o.material.needsUpdate = !0), (u = f), (d = f.version), (m = e.toneMapping)),
                o.layers.enableAll(),
                i.unshift(o, o.geometry, o.material, 0, 0, null));
        },
      };
    }
    function Ki(e, t, i, n) {
      const s = e.getParameter(34921),
        r = n.isWebGL2 ? null : t.get('OES_vertex_array_object'),
        a = n.isWebGL2 || null !== r,
        o = {},
        l = m(null);
      let h = l,
        c = !1;
      function u(t) {
        return n.isWebGL2 ? e.bindVertexArray(t) : r.bindVertexArrayOES(t);
      }
      function d(t) {
        return n.isWebGL2 ? e.deleteVertexArray(t) : r.deleteVertexArrayOES(t);
      }
      function m(e) {
        const t = [],
          i = [],
          n = [];
        for (let e = 0; e < s; e++) (t[e] = 0), (i[e] = 0), (n[e] = 0);
        return {
          geometry: null,
          program: null,
          wireframe: !1,
          newAttributes: t,
          enabledAttributes: i,
          attributeDivisors: n,
          object: e,
          attributes: {},
          index: null,
        };
      }
      function p() {
        const e = h.newAttributes;
        for (let t = 0, i = e.length; t < i; t++) e[t] = 0;
      }
      function f(e) {
        g(e, 0);
      }
      function g(i, s) {
        const r = h.newAttributes,
          a = h.enabledAttributes,
          o = h.attributeDivisors;
        if (((r[i] = 1), 0 === a[i] && (e.enableVertexAttribArray(i), (a[i] = 1)), o[i] !== s)) {
          (n.isWebGL2 ? e : t.get('ANGLE_instanced_arrays'))[
            n.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'
          ](i, s),
            (o[i] = s);
        }
      }
      function _() {
        const t = h.newAttributes,
          i = h.enabledAttributes;
        for (let n = 0, s = i.length; n < s; n++) i[n] !== t[n] && (e.disableVertexAttribArray(n), (i[n] = 0));
      }
      function v(t, i, s, r, a, o) {
        !0 !== n.isWebGL2 || (5124 !== s && 5125 !== s)
          ? e.vertexAttribPointer(t, i, s, r, a, o)
          : e.vertexAttribIPointer(t, i, s, a, o);
      }
      function x() {
        y(), (c = !0), h !== l && ((h = l), u(h.object));
      }
      function y() {
        (l.geometry = null), (l.program = null), (l.wireframe = !1);
      }
      return {
        setup: function (s, l, d, x, y) {
          let M = !1;
          if (a) {
            const t = (function (t, i, s) {
              const a = !0 === s.wireframe;
              let l = o[t.id];
              void 0 === l && ((l = {}), (o[t.id] = l));
              let h = l[i.id];
              void 0 === h && ((h = {}), (l[i.id] = h));
              let c = h[a];
              void 0 === c && ((c = m(n.isWebGL2 ? e.createVertexArray() : r.createVertexArrayOES())), (h[a] = c));
              return c;
            })(x, d, l);
            h !== t && ((h = t), u(h.object)),
              (M = (function (e, t, i, n) {
                const s = h.attributes,
                  r = t.attributes;
                let a = 0;
                const o = i.getAttributes();
                for (const t in o) {
                  if (o[t].location >= 0) {
                    const i = s[t];
                    let n = r[t];
                    if (
                      (void 0 === n &&
                        ('instanceMatrix' === t && e.instanceMatrix && (n = e.instanceMatrix),
                        'instanceColor' === t && e.instanceColor && (n = e.instanceColor)),
                      void 0 === i)
                    )
                      return !0;
                    if (i.attribute !== n) return !0;
                    if (n && i.data !== n.data) return !0;
                    a++;
                  }
                }
                return h.attributesNum !== a || h.index !== n;
              })(s, x, d, y)),
              M &&
                (function (e, t, i, n) {
                  const s = {},
                    r = t.attributes;
                  let a = 0;
                  const o = i.getAttributes();
                  for (const t in o) {
                    if (o[t].location >= 0) {
                      let i = r[t];
                      void 0 === i &&
                        ('instanceMatrix' === t && e.instanceMatrix && (i = e.instanceMatrix),
                        'instanceColor' === t && e.instanceColor && (i = e.instanceColor));
                      const n = {};
                      (n.attribute = i), i && i.data && (n.data = i.data), (s[t] = n), a++;
                    }
                  }
                  (h.attributes = s), (h.attributesNum = a), (h.index = n);
                })(s, x, d, y);
          } else {
            const e = !0 === l.wireframe;
            (h.geometry === x.id && h.program === d.id && h.wireframe === e) ||
              ((h.geometry = x.id), (h.program = d.id), (h.wireframe = e), (M = !0));
          }
          null !== y && i.update(y, 34963),
            (M || c) &&
              ((c = !1),
              (function (s, r, a, o) {
                if (
                  !1 === n.isWebGL2 &&
                  (s.isInstancedMesh || o.isInstancedBufferGeometry) &&
                  null === t.get('ANGLE_instanced_arrays')
                )
                  return;
                p();
                const l = o.attributes,
                  h = a.getAttributes(),
                  c = r.defaultAttributeValues;
                for (const t in h) {
                  const n = h[t];
                  if (n.location >= 0) {
                    let r = l[t];
                    if (
                      (void 0 === r &&
                        ('instanceMatrix' === t && s.instanceMatrix && (r = s.instanceMatrix),
                        'instanceColor' === t && s.instanceColor && (r = s.instanceColor)),
                      void 0 !== r)
                    ) {
                      const t = r.normalized,
                        a = r.itemSize,
                        l = i.get(r);
                      if (void 0 === l) continue;
                      const h = l.buffer,
                        c = l.type,
                        u = l.bytesPerElement;
                      if (r.isInterleavedBufferAttribute) {
                        const i = r.data,
                          l = i.stride,
                          d = r.offset;
                        if (i.isInstancedInterleavedBuffer) {
                          for (let e = 0; e < n.locationSize; e++) g(n.location + e, i.meshPerAttribute);
                          !0 !== s.isInstancedMesh &&
                            void 0 === o._maxInstanceCount &&
                            (o._maxInstanceCount = i.meshPerAttribute * i.count);
                        } else for (let e = 0; e < n.locationSize; e++) f(n.location + e);
                        e.bindBuffer(34962, h);
                        for (let e = 0; e < n.locationSize; e++)
                          v(n.location + e, a / n.locationSize, c, t, l * u, (d + (a / n.locationSize) * e) * u);
                      } else {
                        if (r.isInstancedBufferAttribute) {
                          for (let e = 0; e < n.locationSize; e++) g(n.location + e, r.meshPerAttribute);
                          !0 !== s.isInstancedMesh &&
                            void 0 === o._maxInstanceCount &&
                            (o._maxInstanceCount = r.meshPerAttribute * r.count);
                        } else for (let e = 0; e < n.locationSize; e++) f(n.location + e);
                        e.bindBuffer(34962, h);
                        for (let e = 0; e < n.locationSize; e++)
                          v(n.location + e, a / n.locationSize, c, t, a * u, (a / n.locationSize) * e * u);
                      }
                    } else if (void 0 !== c) {
                      const i = c[t];
                      if (void 0 !== i)
                        switch (i.length) {
                          case 2:
                            e.vertexAttrib2fv(n.location, i);
                            break;
                          case 3:
                            e.vertexAttrib3fv(n.location, i);
                            break;
                          case 4:
                            e.vertexAttrib4fv(n.location, i);
                            break;
                          default:
                            e.vertexAttrib1fv(n.location, i);
                        }
                    }
                  }
                }
                _();
              })(s, l, d, x),
              null !== y && e.bindBuffer(34963, i.get(y).buffer));
        },
        reset: x,
        resetDefaultState: y,
        dispose: function () {
          x();
          for (const e in o) {
            const t = o[e];
            for (const e in t) {
              const i = t[e];
              for (const e in i) d(i[e].object), delete i[e];
              delete t[e];
            }
            delete o[e];
          }
        },
        releaseStatesOfGeometry: function (e) {
          if (void 0 === o[e.id]) return;
          const t = o[e.id];
          for (const e in t) {
            const i = t[e];
            for (const e in i) d(i[e].object), delete i[e];
            delete t[e];
          }
          delete o[e.id];
        },
        releaseStatesOfProgram: function (e) {
          for (const t in o) {
            const i = o[t];
            if (void 0 === i[e.id]) continue;
            const n = i[e.id];
            for (const e in n) d(n[e].object), delete n[e];
            delete i[e.id];
          }
        },
        initAttributes: p,
        enableAttribute: f,
        disableUnusedAttributes: _,
      };
    }
    function $i(e, t, i, n) {
      const s = n.isWebGL2;
      let r;
      (this.setMode = function (e) {
        r = e;
      }),
        (this.render = function (t, n) {
          e.drawArrays(r, t, n), i.update(n, r, 1);
        }),
        (this.renderInstances = function (n, a, o) {
          if (0 === o) return;
          let l, h;
          if (s) (l = e), (h = 'drawArraysInstanced');
          else if (((l = t.get('ANGLE_instanced_arrays')), (h = 'drawArraysInstancedANGLE'), null === l)) return;
          l[h](r, n, a, o), i.update(a, r, o);
        });
    }
    function Qi(e, t, i) {
      let n;
      function s(t) {
        if ('highp' === t) {
          if (
            e.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
            e.getShaderPrecisionFormat(35632, 36338).precision > 0
          )
            return 'highp';
          t = 'mediump';
        }
        return 'mediump' === t &&
          e.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
          e.getShaderPrecisionFormat(35632, 36337).precision > 0
          ? 'mediump'
          : 'lowp';
      }
      const r =
        ('undefined' != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext) ||
        ('undefined' != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext);
      let a = void 0 !== i.precision ? i.precision : 'highp';
      const o = s(a);
      o !== a && (a = o);
      const l = r || t.has('WEBGL_draw_buffers'),
        h = !0 === i.logarithmicDepthBuffer,
        c = e.getParameter(34930),
        u = e.getParameter(35660),
        d = e.getParameter(3379),
        m = e.getParameter(34076),
        p = e.getParameter(34921),
        f = e.getParameter(36347),
        g = e.getParameter(36348),
        _ = e.getParameter(36349),
        v = u > 0,
        x = r || t.has('OES_texture_float');
      return {
        isWebGL2: r,
        drawBuffers: l,
        getMaxAnisotropy: function () {
          if (void 0 !== n) return n;
          if (!0 === t.has('EXT_texture_filter_anisotropic')) {
            const i = t.get('EXT_texture_filter_anisotropic');
            n = e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else n = 0;
          return n;
        },
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: h,
        maxTextures: c,
        maxVertexTextures: u,
        maxTextureSize: d,
        maxCubemapSize: m,
        maxAttributes: p,
        maxVertexUniforms: f,
        maxVaryings: g,
        maxFragmentUniforms: _,
        vertexTextures: v,
        floatFragmentTextures: x,
        floatVertexTextures: v && x,
        maxSamples: r ? e.getParameter(36183) : 0,
      };
    }
    function en(e) {
      const t = this;
      let i = null,
        n = 0,
        s = !1,
        r = !1;
      const a = new Bi(),
        o = new re(),
        l = { value: null, needsUpdate: !1 };
      function h() {
        l.value !== i && ((l.value = i), (l.needsUpdate = n > 0)), (t.numPlanes = n), (t.numIntersection = 0);
      }
      function c(e, i, n, s) {
        const r = null !== e ? e.length : 0;
        let h = null;
        if (0 !== r) {
          if (((h = l.value), !0 !== s || null === h)) {
            const t = n + 4 * r,
              s = i.matrixWorldInverse;
            o.getNormalMatrix(s), (null === h || h.length < t) && (h = new Float32Array(t));
            for (let t = 0, i = n; t !== r; ++t, i += 4)
              a.copy(e[t]).applyMatrix4(s, o), a.normal.toArray(h, i), (h[i + 3] = a.constant);
          }
          (l.value = h), (l.needsUpdate = !0);
        }
        return (t.numPlanes = r), (t.numIntersection = 0), h;
      }
      (this.uniform = l),
        (this.numPlanes = 0),
        (this.numIntersection = 0),
        (this.init = function (e, t, r) {
          const a = 0 !== e.length || t || 0 !== n || s;
          return (s = t), (i = c(e, r, 0)), (n = e.length), a;
        }),
        (this.beginShadows = function () {
          (r = !0), c(null);
        }),
        (this.endShadows = function () {
          (r = !1), h();
        }),
        (this.setState = function (t, a, o) {
          const u = t.clippingPlanes,
            d = t.clipIntersection,
            m = t.clipShadows,
            p = e.get(t);
          if (!s || null === u || 0 === u.length || (r && !m)) r ? c(null) : h();
          else {
            const e = r ? 0 : n,
              t = 4 * e;
            let s = p.clippingState || null;
            (l.value = s), (s = c(u, a, t, o));
            for (let e = 0; e !== t; ++e) s[e] = i[e];
            (p.clippingState = s), (this.numIntersection = d ? this.numPlanes : 0), (this.numPlanes += e);
          }
        });
    }
    function tn(e) {
      let t = new WeakMap();
      function i(e, t) {
        return t === o ? (e.mapping = r) : t === l && (e.mapping = a), e;
      }
      function n(e) {
        const i = e.target;
        i.removeEventListener('dispose', n);
        const s = t.get(i);
        void 0 !== s && (t.delete(i), s.dispose());
      }
      return {
        get: function (s) {
          if (s && s.isTexture && !1 === s.isRenderTargetTexture) {
            const r = s.mapping;
            if (r === o || r === l) {
              if (t.has(s)) {
                return i(t.get(s).texture, s.mapping);
              }
              {
                const r = s.image;
                if (r && r.height > 0) {
                  const a = new zi(r.height / 2);
                  return (
                    a.fromEquirectangularTexture(e, s),
                    t.set(s, a),
                    s.addEventListener('dispose', n),
                    i(a.texture, s.mapping)
                  );
                }
                return null;
              }
            }
          }
          return s;
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    Zi.physical = {
      uniforms: Li([
        Zi.standard.uniforms,
        {
          clearcoat: { value: 0 },
          clearcoatMap: { value: null },
          clearcoatRoughness: { value: 0 },
          clearcoatRoughnessMap: { value: null },
          clearcoatNormalScale: { value: new se(1, 1) },
          clearcoatNormalMap: { value: null },
          iridescence: { value: 0 },
          iridescenceMap: { value: null },
          iridescenceIOR: { value: 1.3 },
          iridescenceThicknessMinimum: { value: 100 },
          iridescenceThicknessMaximum: { value: 400 },
          iridescenceThicknessMap: { value: null },
          sheen: { value: 0 },
          sheenColor: { value: new ve(0) },
          sheenColorMap: { value: null },
          sheenRoughness: { value: 1 },
          sheenRoughnessMap: { value: null },
          transmission: { value: 0 },
          transmissionMap: { value: null },
          transmissionSamplerSize: { value: new se() },
          transmissionSamplerMap: { value: null },
          thickness: { value: 0 },
          thicknessMap: { value: null },
          attenuationDistance: { value: 0 },
          attenuationColor: { value: new ve(0) },
          specularIntensity: { value: 1 },
          specularIntensityMap: { value: null },
          specularColor: { value: new ve(1, 1, 1) },
          specularColorMap: { value: null },
        },
      ]),
      vertexShader: qi.meshphysical_vert,
      fragmentShader: qi.meshphysical_frag,
    };
    class nn extends Di {
      constructor(e = -1, t = 1, i = 1, n = -1, s = 0.1, r = 2e3) {
        super(),
          (this.isOrthographicCamera = !0),
          (this.type = 'OrthographicCamera'),
          (this.zoom = 1),
          (this.view = null),
          (this.left = e),
          (this.right = t),
          (this.top = i),
          (this.bottom = n),
          (this.near = s),
          (this.far = r),
          this.updateProjectionMatrix();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.left = e.left),
          (this.right = e.right),
          (this.top = e.top),
          (this.bottom = e.bottom),
          (this.near = e.near),
          (this.far = e.far),
          (this.zoom = e.zoom),
          (this.view = null === e.view ? null : Object.assign({}, e.view)),
          this
        );
      }
      setViewOffset(e, t, i, n, s, r) {
        null === this.view &&
          (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = t),
          (this.view.offsetX = i),
          (this.view.offsetY = n),
          (this.view.width = s),
          (this.view.height = r),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom),
          t = (this.top - this.bottom) / (2 * this.zoom),
          i = (this.right + this.left) / 2,
          n = (this.top + this.bottom) / 2;
        let s = i - e,
          r = i + e,
          a = n + t,
          o = n - t;
        if (null !== this.view && this.view.enabled) {
          const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
            t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          (s += e * this.view.offsetX),
            (r = s + e * this.view.width),
            (a -= t * this.view.offsetY),
            (o = a - t * this.view.height);
        }
        this.projectionMatrix.makeOrthographic(s, r, a, o, this.near, this.far),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.zoom = this.zoom),
          (t.object.left = this.left),
          (t.object.right = this.right),
          (t.object.top = this.top),
          (t.object.bottom = this.bottom),
          (t.object.near = this.near),
          (t.object.far = this.far),
          null !== this.view && (t.object.view = Object.assign({}, this.view)),
          t
        );
      }
    }
    const sn = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
      rn = 20,
      an = new nn(),
      on = new ve();
    let ln = null;
    const hn = (1 + Math.sqrt(5)) / 2,
      cn = 1 / hn,
      un = [
        new Pe(1, 1, 1),
        new Pe(-1, 1, 1),
        new Pe(1, 1, -1),
        new Pe(-1, 1, -1),
        new Pe(0, hn, cn),
        new Pe(0, hn, -cn),
        new Pe(cn, 0, hn),
        new Pe(-cn, 0, hn),
        new Pe(hn, cn, 0),
        new Pe(-hn, cn, 0),
      ];
    class dn {
      constructor(e) {
        (this._renderer = e),
          (this._pingPongRenderTarget = null),
          (this._lodMax = 0),
          (this._cubeSize = 0),
          (this._lodPlanes = []),
          (this._sizeLods = []),
          (this._sigmas = []),
          (this._blurMaterial = null),
          (this._cubemapMaterial = null),
          (this._equirectMaterial = null),
          this._compileMaterial(this._blurMaterial);
      }
      fromScene(e, t = 0, i = 0.1, n = 100) {
        (ln = this._renderer.getRenderTarget()), this._setSize(256);
        const s = this._allocateTargets();
        return (
          (s.depthBuffer = !0),
          this._sceneToCubeUV(e, i, n, s),
          t > 0 && this._blur(s, 0, 0, t),
          this._applyPMREM(s),
          this._cleanup(s),
          s
        );
      }
      fromEquirectangular(e, t = null) {
        return this._fromTexture(e, t);
      }
      fromCubemap(e, t = null) {
        return this._fromTexture(e, t);
      }
      compileCubemapShader() {
        null === this._cubemapMaterial &&
          ((this._cubemapMaterial = gn()), this._compileMaterial(this._cubemapMaterial));
      }
      compileEquirectangularShader() {
        null === this._equirectMaterial &&
          ((this._equirectMaterial = fn()), this._compileMaterial(this._equirectMaterial));
      }
      dispose() {
        this._dispose(),
          null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
          null !== this._equirectMaterial && this._equirectMaterial.dispose();
      }
      _setSize(e) {
        (this._lodMax = Math.floor(Math.log2(e))), (this._cubeSize = Math.pow(2, this._lodMax));
      }
      _dispose() {
        null !== this._blurMaterial && this._blurMaterial.dispose(),
          null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
      }
      _cleanup(e) {
        this._renderer.setRenderTarget(ln), (e.scissorTest = !1), pn(e, 0, 0, e.width, e.height);
      }
      _fromTexture(e, t) {
        e.mapping === r || e.mapping === a
          ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width)
          : this._setSize(e.image.width / 4),
          (ln = this._renderer.getRenderTarget());
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
      }
      _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112),
          t = 4 * this._cubeSize,
          i = { magFilter: g, minFilter: g, generateMipmaps: !1, type: b, format: w, encoding: F, depthBuffer: !1 },
          n = mn(e, t, i);
        if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e) {
          null !== this._pingPongRenderTarget && this._dispose(), (this._pingPongRenderTarget = mn(e, t, i));
          const { _lodMax: n } = this;
          ({
            sizeLods: this._sizeLods,
            lodPlanes: this._lodPlanes,
            sigmas: this._sigmas,
          } = (function (e) {
            const t = [],
              i = [],
              n = [];
            let s = e;
            const r = e - 4 + 1 + sn.length;
            for (let a = 0; a < r; a++) {
              const r = Math.pow(2, s);
              i.push(r);
              let o = 1 / r;
              a > e - 4 ? (o = sn[a - e + 4 - 1]) : 0 === a && (o = 0), n.push(o);
              const l = 1 / (r - 2),
                h = -l,
                c = 1 + l,
                u = [h, h, c, h, c, c, h, h, c, c, h, c],
                d = 6,
                m = 6,
                p = 3,
                f = 2,
                g = 1,
                _ = new Float32Array(p * m * d),
                v = new Float32Array(f * m * d),
                x = new Float32Array(g * m * d);
              for (let e = 0; e < d; e++) {
                const t = ((e % 3) * 2) / 3 - 1,
                  i = e > 2 ? 0 : -1,
                  n = [t, i, 0, t + 2 / 3, i, 0, t + 2 / 3, i + 1, 0, t, i, 0, t + 2 / 3, i + 1, 0, t, i + 1, 0];
                _.set(n, p * m * e), v.set(u, f * m * e);
                const s = [e, e, e, e, e, e];
                x.set(s, g * m * e);
              }
              const y = new ai();
              y.setAttribute('position', new Zt(_, p)),
                y.setAttribute('uv', new Zt(v, f)),
                y.setAttribute('faceIndex', new Zt(x, g)),
                t.push(y),
                s > 4 && s--;
            }
            return { lodPlanes: t, sizeLods: i, sigmas: n };
          })(n)),
            (this._blurMaterial = (function (e, t, i) {
              const n = new Float32Array(rn),
                s = new Pe(0, 1, 0);
              return new Pi({
                name: 'SphericalGaussianBlur',
                defines: { n: rn, CUBEUV_TEXEL_WIDTH: 1 / t, CUBEUV_TEXEL_HEIGHT: 1 / i, CUBEUV_MAX_MIP: `${e}.0` },
                uniforms: {
                  envMap: { value: null },
                  samples: { value: 1 },
                  weights: { value: n },
                  latitudinal: { value: !1 },
                  dTheta: { value: 0 },
                  mipInt: { value: 0 },
                  poleAxis: { value: s },
                },
                vertexShader: _n(),
                fragmentShader:
                  "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1,
              });
            })(n, e, t));
        }
        return n;
      }
      _compileMaterial(e) {
        const t = new wi(this._lodPlanes[0], e);
        this._renderer.compile(t, an);
      }
      _sceneToCubeUV(e, t, i, n) {
        const s = new Ii(90, 1, t, i),
          r = [1, -1, 1, 1, 1, 1],
          a = [1, 1, 1, -1, -1, -1],
          o = this._renderer,
          l = o.autoClear,
          h = o.toneMapping;
        o.getClearColor(on), (o.toneMapping = 0), (o.autoClear = !1);
        const c = new Xt({ name: 'PMREM.Background', side: 1, depthWrite: !1, depthTest: !1 }),
          u = new wi(new Ti(), c);
        let d = !1;
        const m = e.background;
        m ? m.isColor && (c.color.copy(m), (e.background = null), (d = !0)) : (c.color.copy(on), (d = !0));
        for (let t = 0; t < 6; t++) {
          const i = t % 3;
          0 === i
            ? (s.up.set(0, r[t], 0), s.lookAt(a[t], 0, 0))
            : 1 === i
            ? (s.up.set(0, 0, r[t]), s.lookAt(0, a[t], 0))
            : (s.up.set(0, r[t], 0), s.lookAt(0, 0, a[t]));
          const l = this._cubeSize;
          pn(n, i * l, t > 2 ? l : 0, l, l), o.setRenderTarget(n), d && o.render(u, s), o.render(e, s);
        }
        u.geometry.dispose(), u.material.dispose(), (o.toneMapping = h), (o.autoClear = l), (e.background = m);
      }
      _textureToCubeUV(e, t) {
        const i = this._renderer,
          n = e.mapping === r || e.mapping === a;
        n
          ? (null === this._cubemapMaterial && (this._cubemapMaterial = gn()),
            (this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1))
          : null === this._equirectMaterial && (this._equirectMaterial = fn());
        const s = n ? this._cubemapMaterial : this._equirectMaterial,
          o = new wi(this._lodPlanes[0], s);
        s.uniforms.envMap.value = e;
        const l = this._cubeSize;
        pn(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, an);
      }
      _applyPMREM(e) {
        const t = this._renderer,
          i = t.autoClear;
        t.autoClear = !1;
        for (let t = 1; t < this._lodPlanes.length; t++) {
          const i = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]),
            n = un[(t - 1) % un.length];
          this._blur(e, t - 1, t, i, n);
        }
        t.autoClear = i;
      }
      _blur(e, t, i, n, s) {
        const r = this._pingPongRenderTarget;
        this._halfBlur(e, r, t, i, n, 'latitudinal', s), this._halfBlur(r, e, i, i, n, 'longitudinal', s);
      }
      _halfBlur(e, t, i, n, s, r, a) {
        const o = this._renderer,
          l = this._blurMaterial,
          h = new wi(this._lodPlanes[n], l),
          c = l.uniforms,
          u = this._sizeLods[i] - 1,
          d = isFinite(s) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
          m = s / d,
          p = isFinite(s) ? 1 + Math.floor(3 * m) : rn,
          f = [];
        let g = 0;
        for (let e = 0; e < rn; ++e) {
          const t = e / m,
            i = Math.exp((-t * t) / 2);
          f.push(i), 0 === e ? (g += i) : e < p && (g += 2 * i);
        }
        for (let e = 0; e < f.length; e++) f[e] = f[e] / g;
        (c.envMap.value = e.texture),
          (c.samples.value = p),
          (c.weights.value = f),
          (c.latitudinal.value = 'latitudinal' === r),
          a && (c.poleAxis.value = a);
        const { _lodMax: _ } = this;
        (c.dTheta.value = d), (c.mipInt.value = _ - i);
        const v = this._sizeLods[n];
        pn(t, 3 * v * (n > _ - 4 ? n - _ + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v),
          o.setRenderTarget(t),
          o.render(h, an);
      }
    }
    function mn(e, t, i) {
      const n = new Te(e, t, i);
      return (n.texture.mapping = h), (n.texture.name = 'PMREM.cubeUv'), (n.scissorTest = !0), n;
    }
    function pn(e, t, i, n, s) {
      e.viewport.set(t, i, n, s), e.scissor.set(t, i, n, s);
    }
    function fn() {
      return new Pi({
        name: 'EquirectangularToCubeUV',
        uniforms: { envMap: { value: null } },
        vertexShader: _n(),
        fragmentShader:
          '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t',
        blending: 0,
        depthTest: !1,
        depthWrite: !1,
      });
    }
    function gn() {
      return new Pi({
        name: 'CubemapToCubeUV',
        uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
        vertexShader: _n(),
        fragmentShader:
          '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t',
        blending: 0,
        depthTest: !1,
        depthWrite: !1,
      });
    }
    function _n() {
      return '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t';
    }
    function vn(e) {
      let t = new WeakMap(),
        i = null;
      function n(e) {
        const i = e.target;
        i.removeEventListener('dispose', n);
        const s = t.get(i);
        void 0 !== s && (t.delete(i), s.dispose());
      }
      return {
        get: function (s) {
          if (s && s.isTexture) {
            const h = s.mapping,
              c = h === o || h === l,
              u = h === r || h === a;
            if (c || u) {
              if (s.isRenderTargetTexture && !0 === s.needsPMREMUpdate) {
                s.needsPMREMUpdate = !1;
                let n = t.get(s);
                return (
                  null === i && (i = new dn(e)),
                  (n = c ? i.fromEquirectangular(s, n) : i.fromCubemap(s, n)),
                  t.set(s, n),
                  n.texture
                );
              }
              if (t.has(s)) return t.get(s).texture;
              {
                const r = s.image;
                if (
                  (c && r && r.height > 0) ||
                  (u &&
                    r &&
                    (function (e) {
                      let t = 0;
                      const i = 6;
                      for (let n = 0; n < i; n++) void 0 !== e[n] && t++;
                      return t === i;
                    })(r))
                ) {
                  null === i && (i = new dn(e));
                  const r = c ? i.fromEquirectangular(s) : i.fromCubemap(s);
                  return t.set(s, r), s.addEventListener('dispose', n), r.texture;
                }
                return null;
              }
            }
          }
          return s;
        },
        dispose: function () {
          (t = new WeakMap()), null !== i && (i.dispose(), (i = null));
        },
      };
    }
    function xn(e) {
      const t = {};
      function i(i) {
        if (void 0 !== t[i]) return t[i];
        let n;
        switch (i) {
          case 'WEBGL_depth_texture':
            n =
              e.getExtension('WEBGL_depth_texture') ||
              e.getExtension('MOZ_WEBGL_depth_texture') ||
              e.getExtension('WEBKIT_WEBGL_depth_texture');
            break;
          case 'EXT_texture_filter_anisotropic':
            n =
              e.getExtension('EXT_texture_filter_anisotropic') ||
              e.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
              e.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
            break;
          case 'WEBGL_compressed_texture_s3tc':
            n =
              e.getExtension('WEBGL_compressed_texture_s3tc') ||
              e.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
              e.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
            break;
          case 'WEBGL_compressed_texture_pvrtc':
            n =
              e.getExtension('WEBGL_compressed_texture_pvrtc') ||
              e.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
            break;
          default:
            n = e.getExtension(i);
        }
        return (t[i] = n), n;
      }
      return {
        has: function (e) {
          return null !== i(e);
        },
        init: function (e) {
          e.isWebGL2
            ? i('EXT_color_buffer_float')
            : (i('WEBGL_depth_texture'),
              i('OES_texture_float'),
              i('OES_texture_half_float'),
              i('OES_texture_half_float_linear'),
              i('OES_standard_derivatives'),
              i('OES_element_index_uint'),
              i('OES_vertex_array_object'),
              i('ANGLE_instanced_arrays')),
            i('OES_texture_float_linear'),
            i('EXT_color_buffer_half_float'),
            i('WEBGL_multisampled_render_to_texture');
        },
        get: function (e) {
          const t = i(e);
          return t;
        },
      };
    }
    function yn(e, t, i, n) {
      const s = {},
        r = new WeakMap();
      function a(e) {
        const o = e.target;
        null !== o.index && t.remove(o.index);
        for (const e in o.attributes) t.remove(o.attributes[e]);
        o.removeEventListener('dispose', a), delete s[o.id];
        const l = r.get(o);
        l && (t.remove(l), r.delete(o)),
          n.releaseStatesOfGeometry(o),
          !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
          i.memory.geometries--;
      }
      function o(e) {
        const i = [],
          n = e.index,
          s = e.attributes.position;
        let a = 0;
        if (null !== n) {
          const e = n.array;
          a = n.version;
          for (let t = 0, n = e.length; t < n; t += 3) {
            const n = e[t + 0],
              s = e[t + 1],
              r = e[t + 2];
            i.push(n, s, s, r, r, n);
          }
        } else {
          const e = s.array;
          a = s.version;
          for (let t = 0, n = e.length / 3 - 1; t < n; t += 3) {
            const e = t + 0,
              n = t + 1,
              s = t + 2;
            i.push(e, n, n, s, s, e);
          }
        }
        const o = new (ae(i) ? Kt : Jt)(i, 1);
        o.version = a;
        const l = r.get(e);
        l && t.remove(l), r.set(e, o);
      }
      return {
        get: function (e, t) {
          return !0 === s[t.id] || (t.addEventListener('dispose', a), (s[t.id] = !0), i.memory.geometries++), t;
        },
        update: function (e) {
          const i = e.attributes;
          for (const e in i) t.update(i[e], 34962);
          const n = e.morphAttributes;
          for (const e in n) {
            const i = n[e];
            for (let e = 0, n = i.length; e < n; e++) t.update(i[e], 34962);
          }
        },
        getWireframeAttribute: function (e) {
          const t = r.get(e);
          if (t) {
            const i = e.index;
            null !== i && t.version < i.version && o(e);
          } else o(e);
          return r.get(e);
        },
      };
    }
    function Mn(e, t, i, n) {
      const s = n.isWebGL2;
      let r, a, o;
      (this.setMode = function (e) {
        r = e;
      }),
        (this.setIndex = function (e) {
          (a = e.type), (o = e.bytesPerElement);
        }),
        (this.render = function (t, n) {
          e.drawElements(r, n, a, t * o), i.update(n, r, 1);
        }),
        (this.renderInstances = function (n, l, h) {
          if (0 === h) return;
          let c, u;
          if (s) (c = e), (u = 'drawElementsInstanced');
          else if (((c = t.get('ANGLE_instanced_arrays')), (u = 'drawElementsInstancedANGLE'), null === c)) return;
          c[u](r, l, a, n * o, h), i.update(l, r, h);
        });
    }
    function bn(e) {
      const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
      return {
        memory: { geometries: 0, textures: 0 },
        render: t,
        programs: null,
        autoReset: !0,
        reset: function () {
          t.frame++, (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
        },
        update: function (e, i, n) {
          switch ((t.calls++, i)) {
            case 4:
              t.triangles += n * (e / 3);
              break;
            case 1:
              t.lines += n * (e / 2);
              break;
            case 3:
              t.lines += n * (e - 1);
              break;
            case 2:
              t.lines += n * e;
              break;
            case 0:
              t.points += n * e;
          }
        },
      };
    }
    function Sn(e, t) {
      return e[0] - t[0];
    }
    function wn(e, t) {
      return Math.abs(t[1]) - Math.abs(e[1]);
    }
    function An(e, t) {
      let i = 1;
      const n = t.isInterleavedBufferAttribute ? t.data.array : t.array;
      n instanceof Int8Array
        ? (i = 127)
        : n instanceof Uint8Array
        ? (i = 255)
        : n instanceof Uint16Array
        ? (i = 65535)
        : n instanceof Int16Array
        ? (i = 32767)
        : n instanceof Int32Array && (i = 2147483647),
        e.divideScalar(i);
    }
    function Tn(e, t, i) {
      const n = {},
        s = new Float32Array(8),
        r = new WeakMap(),
        a = new Ae(),
        o = [];
      for (let e = 0; e < 8; e++) o[e] = [e, 0];
      return {
        update: function (l, h, c, u) {
          const d = l.morphTargetInfluences;
          if (!0 === t.isWebGL2) {
            const m = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color,
              p = void 0 !== m ? m.length : 0;
            let f = r.get(h);
            if (void 0 === f || f.count !== p) {
              void 0 !== f && f.texture.dispose();
              const v = void 0 !== h.morphAttributes.position,
                x = void 0 !== h.morphAttributes.normal,
                y = void 0 !== h.morphAttributes.color,
                b = h.morphAttributes.position || [],
                S = h.morphAttributes.normal || [],
                w = h.morphAttributes.color || [];
              let A = 0;
              !0 === v && (A = 1), !0 === x && (A = 2), !0 === y && (A = 3);
              let T = h.attributes.position.count * A,
                E = 1;
              T > t.maxTextureSize && ((E = Math.ceil(T / t.maxTextureSize)), (T = t.maxTextureSize));
              const L = new Float32Array(T * E * 4 * p),
                C = new Ee(L, T, E, p);
              (C.type = M), (C.needsUpdate = !0);
              const P = 4 * A;
              for (let I = 0; I < p; I++) {
                const R = b[I],
                  O = S[I],
                  N = w[I],
                  z = T * E * 4 * I;
                for (let F = 0; F < R.count; F++) {
                  const k = F * P;
                  !0 === v &&
                    (a.fromBufferAttribute(R, F),
                    !0 === R.normalized && An(a, R),
                    (L[z + k + 0] = a.x),
                    (L[z + k + 1] = a.y),
                    (L[z + k + 2] = a.z),
                    (L[z + k + 3] = 0)),
                    !0 === x &&
                      (a.fromBufferAttribute(O, F),
                      !0 === O.normalized && An(a, O),
                      (L[z + k + 4] = a.x),
                      (L[z + k + 5] = a.y),
                      (L[z + k + 6] = a.z),
                      (L[z + k + 7] = 0)),
                    !0 === y &&
                      (a.fromBufferAttribute(N, F),
                      !0 === N.normalized && An(a, N),
                      (L[z + k + 8] = a.x),
                      (L[z + k + 9] = a.y),
                      (L[z + k + 10] = a.z),
                      (L[z + k + 11] = 4 === N.itemSize ? a.w : 1));
                }
              }
              function D() {
                C.dispose(), r.delete(h), h.removeEventListener('dispose', D);
              }
              (f = { count: p, texture: C, size: new se(T, E) }), r.set(h, f), h.addEventListener('dispose', D);
            }
            let g = 0;
            for (let U = 0; U < d.length; U++) g += d[U];
            const _ = h.morphTargetsRelative ? 1 : 1 - g;
            u.getUniforms().setValue(e, 'morphTargetBaseInfluence', _),
              u.getUniforms().setValue(e, 'morphTargetInfluences', d),
              u.getUniforms().setValue(e, 'morphTargetsTexture', f.texture, i),
              u.getUniforms().setValue(e, 'morphTargetsTextureSize', f.size);
          } else {
            const B = void 0 === d ? 0 : d.length;
            let G = n[h.id];
            if (void 0 === G || G.length !== B) {
              G = [];
              for (let X = 0; X < B; X++) G[X] = [X, 0];
              n[h.id] = G;
            }
            for (let q = 0; q < B; q++) {
              const Y = G[q];
              (Y[0] = q), (Y[1] = d[q]);
            }
            G.sort(wn);
            for (let Z = 0; Z < 8; Z++)
              Z < B && G[Z][1]
                ? ((o[Z][0] = G[Z][0]), (o[Z][1] = G[Z][1]))
                : ((o[Z][0] = Number.MAX_SAFE_INTEGER), (o[Z][1] = 0));
            o.sort(Sn);
            const V = h.morphAttributes.position,
              H = h.morphAttributes.normal;
            let j = 0;
            for (let J = 0; J < 8; J++) {
              const K = o[J],
                $ = K[0],
                Q = K[1];
              $ !== Number.MAX_SAFE_INTEGER && Q
                ? (V && h.getAttribute('morphTarget' + J) !== V[$] && h.setAttribute('morphTarget' + J, V[$]),
                  H && h.getAttribute('morphNormal' + J) !== H[$] && h.setAttribute('morphNormal' + J, H[$]),
                  (s[J] = Q),
                  (j += Q))
                : (V && !0 === h.hasAttribute('morphTarget' + J) && h.deleteAttribute('morphTarget' + J),
                  H && !0 === h.hasAttribute('morphNormal' + J) && h.deleteAttribute('morphNormal' + J),
                  (s[J] = 0));
            }
            const W = h.morphTargetsRelative ? 1 : 1 - j;
            u.getUniforms().setValue(e, 'morphTargetBaseInfluence', W),
              u.getUniforms().setValue(e, 'morphTargetInfluences', s);
          }
        },
      };
    }
    function En(e, t, i, n) {
      let s = new WeakMap();
      function r(e) {
        const t = e.target;
        t.removeEventListener('dispose', r),
          i.remove(t.instanceMatrix),
          null !== t.instanceColor && i.remove(t.instanceColor);
      }
      return {
        update: function (e) {
          const a = n.render.frame,
            o = e.geometry,
            l = t.get(e, o);
          return (
            s.get(l) !== a && (t.update(l), s.set(l, a)),
            e.isInstancedMesh &&
              (!1 === e.hasEventListener('dispose', r) && e.addEventListener('dispose', r),
              i.update(e.instanceMatrix, 34962),
              null !== e.instanceColor && i.update(e.instanceColor, 34962)),
            l
          );
        },
        dispose: function () {
          s = new WeakMap();
        },
      };
    }
    const Ln = new we(),
      Cn = new Ee(),
      Pn = new Le(),
      Dn = new Ni(),
      In = [],
      Rn = [],
      On = new Float32Array(16),
      Nn = new Float32Array(9),
      zn = new Float32Array(4);
    function Fn(e, t, i) {
      const n = e[0];
      if (n <= 0 || n > 0) return e;
      const s = t * i;
      let r = In[s];
      if ((void 0 === r && ((r = new Float32Array(s)), (In[s] = r)), 0 !== t)) {
        n.toArray(r, 0);
        for (let n = 1, s = 0; n !== t; ++n) (s += i), e[n].toArray(r, s);
      }
      return r;
    }
    function kn(e, t) {
      if (e.length !== t.length) return !1;
      for (let i = 0, n = e.length; i < n; i++) if (e[i] !== t[i]) return !1;
      return !0;
    }
    function Un(e, t) {
      for (let i = 0, n = t.length; i < n; i++) e[i] = t[i];
    }
    function Bn(e, t) {
      let i = Rn[t];
      void 0 === i && ((i = new Int32Array(t)), (Rn[t] = i));
      for (let n = 0; n !== t; ++n) i[n] = e.allocateTextureUnit();
      return i;
    }
    function Gn(e, t) {
      const i = this.cache;
      i[0] !== t && (e.uniform1f(this.addr, t), (i[0] = t));
    }
    function Vn(e, t) {
      const i = this.cache;
      if (void 0 !== t.x)
        (i[0] === t.x && i[1] === t.y) || (e.uniform2f(this.addr, t.x, t.y), (i[0] = t.x), (i[1] = t.y));
      else {
        if (kn(i, t)) return;
        e.uniform2fv(this.addr, t), Un(i, t);
      }
    }
    function Hn(e, t) {
      const i = this.cache;
      if (void 0 !== t.x)
        (i[0] === t.x && i[1] === t.y && i[2] === t.z) ||
          (e.uniform3f(this.addr, t.x, t.y, t.z), (i[0] = t.x), (i[1] = t.y), (i[2] = t.z));
      else if (void 0 !== t.r)
        (i[0] === t.r && i[1] === t.g && i[2] === t.b) ||
          (e.uniform3f(this.addr, t.r, t.g, t.b), (i[0] = t.r), (i[1] = t.g), (i[2] = t.b));
      else {
        if (kn(i, t)) return;
        e.uniform3fv(this.addr, t), Un(i, t);
      }
    }
    function jn(e, t) {
      const i = this.cache;
      if (void 0 !== t.x)
        (i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w) ||
          (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), (i[0] = t.x), (i[1] = t.y), (i[2] = t.z), (i[3] = t.w));
      else {
        if (kn(i, t)) return;
        e.uniform4fv(this.addr, t), Un(i, t);
      }
    }
    function Wn(e, t) {
      const i = this.cache,
        n = t.elements;
      if (void 0 === n) {
        if (kn(i, t)) return;
        e.uniformMatrix2fv(this.addr, !1, t), Un(i, t);
      } else {
        if (kn(i, n)) return;
        zn.set(n), e.uniformMatrix2fv(this.addr, !1, zn), Un(i, n);
      }
    }
    function Xn(e, t) {
      const i = this.cache,
        n = t.elements;
      if (void 0 === n) {
        if (kn(i, t)) return;
        e.uniformMatrix3fv(this.addr, !1, t), Un(i, t);
      } else {
        if (kn(i, n)) return;
        Nn.set(n), e.uniformMatrix3fv(this.addr, !1, Nn), Un(i, n);
      }
    }
    function qn(e, t) {
      const i = this.cache,
        n = t.elements;
      if (void 0 === n) {
        if (kn(i, t)) return;
        e.uniformMatrix4fv(this.addr, !1, t), Un(i, t);
      } else {
        if (kn(i, n)) return;
        On.set(n), e.uniformMatrix4fv(this.addr, !1, On), Un(i, n);
      }
    }
    function Yn(e, t) {
      const i = this.cache;
      i[0] !== t && (e.uniform1i(this.addr, t), (i[0] = t));
    }
    function Zn(e, t) {
      const i = this.cache;
      kn(i, t) || (e.uniform2iv(this.addr, t), Un(i, t));
    }
    function Jn(e, t) {
      const i = this.cache;
      kn(i, t) || (e.uniform3iv(this.addr, t), Un(i, t));
    }
    function Kn(e, t) {
      const i = this.cache;
      kn(i, t) || (e.uniform4iv(this.addr, t), Un(i, t));
    }
    function $n(e, t) {
      const i = this.cache;
      i[0] !== t && (e.uniform1ui(this.addr, t), (i[0] = t));
    }
    function Qn(e, t) {
      const i = this.cache;
      kn(i, t) || (e.uniform2uiv(this.addr, t), Un(i, t));
    }
    function es(e, t) {
      const i = this.cache;
      kn(i, t) || (e.uniform3uiv(this.addr, t), Un(i, t));
    }
    function ts(e, t) {
      const i = this.cache;
      kn(i, t) || (e.uniform4uiv(this.addr, t), Un(i, t));
    }
    function is(e, t, i) {
      const n = this.cache,
        s = i.allocateTextureUnit();
      n[0] !== s && (e.uniform1i(this.addr, s), (n[0] = s)), i.setTexture2D(t || Ln, s);
    }
    function ns(e, t, i) {
      const n = this.cache,
        s = i.allocateTextureUnit();
      n[0] !== s && (e.uniform1i(this.addr, s), (n[0] = s)), i.setTexture3D(t || Pn, s);
    }
    function ss(e, t, i) {
      const n = this.cache,
        s = i.allocateTextureUnit();
      n[0] !== s && (e.uniform1i(this.addr, s), (n[0] = s)), i.setTextureCube(t || Dn, s);
    }
    function rs(e, t, i) {
      const n = this.cache,
        s = i.allocateTextureUnit();
      n[0] !== s && (e.uniform1i(this.addr, s), (n[0] = s)), i.setTexture2DArray(t || Cn, s);
    }
    function as(e, t) {
      e.uniform1fv(this.addr, t);
    }
    function os(e, t) {
      const i = Fn(t, this.size, 2);
      e.uniform2fv(this.addr, i);
    }
    function ls(e, t) {
      const i = Fn(t, this.size, 3);
      e.uniform3fv(this.addr, i);
    }
    function hs(e, t) {
      const i = Fn(t, this.size, 4);
      e.uniform4fv(this.addr, i);
    }
    function cs(e, t) {
      const i = Fn(t, this.size, 4);
      e.uniformMatrix2fv(this.addr, !1, i);
    }
    function us(e, t) {
      const i = Fn(t, this.size, 9);
      e.uniformMatrix3fv(this.addr, !1, i);
    }
    function ds(e, t) {
      const i = Fn(t, this.size, 16);
      e.uniformMatrix4fv(this.addr, !1, i);
    }
    function ms(e, t) {
      e.uniform1iv(this.addr, t);
    }
    function ps(e, t) {
      e.uniform2iv(this.addr, t);
    }
    function fs(e, t) {
      e.uniform3iv(this.addr, t);
    }
    function gs(e, t) {
      e.uniform4iv(this.addr, t);
    }
    function _s(e, t) {
      e.uniform1uiv(this.addr, t);
    }
    function vs(e, t) {
      e.uniform2uiv(this.addr, t);
    }
    function xs(e, t) {
      e.uniform3uiv(this.addr, t);
    }
    function ys(e, t) {
      e.uniform4uiv(this.addr, t);
    }
    function Ms(e, t, i) {
      const n = t.length,
        s = Bn(i, n);
      e.uniform1iv(this.addr, s);
      for (let e = 0; e !== n; ++e) i.setTexture2D(t[e] || Ln, s[e]);
    }
    function bs(e, t, i) {
      const n = t.length,
        s = Bn(i, n);
      e.uniform1iv(this.addr, s);
      for (let e = 0; e !== n; ++e) i.setTexture3D(t[e] || Pn, s[e]);
    }
    function Ss(e, t, i) {
      const n = t.length,
        s = Bn(i, n);
      e.uniform1iv(this.addr, s);
      for (let e = 0; e !== n; ++e) i.setTextureCube(t[e] || Dn, s[e]);
    }
    function ws(e, t, i) {
      const n = t.length,
        s = Bn(i, n);
      e.uniform1iv(this.addr, s);
      for (let e = 0; e !== n; ++e) i.setTexture2DArray(t[e] || Cn, s[e]);
    }
    class As {
      constructor(e, t, i) {
        (this.id = e),
          (this.addr = i),
          (this.cache = []),
          (this.setValue = (function (e) {
            switch (e) {
              case 5126:
                return Gn;
              case 35664:
                return Vn;
              case 35665:
                return Hn;
              case 35666:
                return jn;
              case 35674:
                return Wn;
              case 35675:
                return Xn;
              case 35676:
                return qn;
              case 5124:
              case 35670:
                return Yn;
              case 35667:
              case 35671:
                return Zn;
              case 35668:
              case 35672:
                return Jn;
              case 35669:
              case 35673:
                return Kn;
              case 5125:
                return $n;
              case 36294:
                return Qn;
              case 36295:
                return es;
              case 36296:
                return ts;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return is;
              case 35679:
              case 36299:
              case 36307:
                return ns;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return ss;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return rs;
            }
          })(t.type));
      }
    }
    class Ts {
      constructor(e, t, i) {
        (this.id = e),
          (this.addr = i),
          (this.cache = []),
          (this.size = t.size),
          (this.setValue = (function (e) {
            switch (e) {
              case 5126:
                return as;
              case 35664:
                return os;
              case 35665:
                return ls;
              case 35666:
                return hs;
              case 35674:
                return cs;
              case 35675:
                return us;
              case 35676:
                return ds;
              case 5124:
              case 35670:
                return ms;
              case 35667:
              case 35671:
                return ps;
              case 35668:
              case 35672:
                return fs;
              case 35669:
              case 35673:
                return gs;
              case 5125:
                return _s;
              case 36294:
                return vs;
              case 36295:
                return xs;
              case 36296:
                return ys;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return Ms;
              case 35679:
              case 36299:
              case 36307:
                return bs;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return Ss;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return ws;
            }
          })(t.type));
      }
    }
    class Es {
      constructor(e) {
        (this.id = e), (this.seq = []), (this.map = {});
      }
      setValue(e, t, i) {
        const n = this.seq;
        for (let s = 0, r = n.length; s !== r; ++s) {
          const r = n[s];
          r.setValue(e, t[r.id], i);
        }
      }
    }
    const Ls = /(\w+)(\])?(\[|\.)?/g;
    function Cs(e, t) {
      e.seq.push(t), (e.map[t.id] = t);
    }
    function Ps(e, t, i) {
      const n = e.name,
        s = n.length;
      for (Ls.lastIndex = 0; ; ) {
        const r = Ls.exec(n),
          a = Ls.lastIndex;
        let o = r[1];
        const l = ']' === r[2],
          h = r[3];
        if ((l && (o |= 0), void 0 === h || ('[' === h && a + 2 === s))) {
          Cs(i, void 0 === h ? new As(o, e, t) : new Ts(o, e, t));
          break;
        }
        {
          let e = i.map[o];
          void 0 === e && ((e = new Es(o)), Cs(i, e)), (i = e);
        }
      }
    }
    class Ds {
      constructor(e, t) {
        (this.seq = []), (this.map = {});
        const i = e.getProgramParameter(t, 35718);
        for (let n = 0; n < i; ++n) {
          const i = e.getActiveUniform(t, n);
          Ps(i, e.getUniformLocation(t, i.name), this);
        }
      }
      setValue(e, t, i, n) {
        const s = this.map[t];
        void 0 !== s && s.setValue(e, i, n);
      }
      setOptional(e, t, i) {
        const n = t[i];
        void 0 !== n && this.setValue(e, i, n);
      }
      static upload(e, t, i, n) {
        for (let s = 0, r = t.length; s !== r; ++s) {
          const r = t[s],
            a = i[r.id];
          !1 !== a.needsUpdate && r.setValue(e, a.value, n);
        }
      }
      static seqWithValue(e, t) {
        const i = [];
        for (let n = 0, s = e.length; n !== s; ++n) {
          const s = e[n];
          s.id in t && i.push(s);
        }
        return i;
      }
    }
    function Is(e, t, i) {
      const n = e.createShader(t);
      return e.shaderSource(n, i), e.compileShader(n), n;
    }
    let Rs = 0;
    function Os(e, t, i) {
      const n = e.getShaderParameter(t, 35713),
        s = e.getShaderInfoLog(t).trim();
      if (n && '' === s) return '';
      const r = /ERROR: 0:(\d+)/.exec(s);
      if (r) {
        const n = parseInt(r[1]);
        return (
          i.toUpperCase() +
          '\n\n' +
          s +
          '\n\n' +
          (function (e, t) {
            const i = e.split('\n'),
              n = [],
              s = Math.max(t - 6, 0),
              r = Math.min(t + 6, i.length);
            for (let e = s; e < r; e++) {
              const s = e + 1;
              n.push(`${s === t ? '>' : ' '} ${s}: ${i[e]}`);
            }
            return n.join('\n');
          })(e.getShaderSource(t), n)
        );
      }
      return s;
    }
    function Ns(e, t) {
      const i = (function (e) {
        switch (e) {
          case F:
            return ['Linear', '( value )'];
          case k:
            return ['sRGB', '( value )'];
          default:
            return ['Linear', '( value )'];
        }
      })(t);
      return 'vec4 ' + e + '( vec4 value ) { return LinearTo' + i[0] + i[1] + '; }';
    }
    function zs(e, t) {
      let i;
      switch (t) {
        case 1:
        default:
          i = 'Linear';
          break;
        case 2:
          i = 'Reinhard';
          break;
        case 3:
          i = 'OptimizedCineon';
          break;
        case 4:
          i = 'ACESFilmic';
          break;
        case 5:
          i = 'Custom';
      }
      return 'vec3 ' + e + '( vec3 color ) { return ' + i + 'ToneMapping( color ); }';
    }
    function Fs(e) {
      return '' !== e;
    }
    function ks(e, t) {
      return e
        .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
        .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
        .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
        .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
        .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
        .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
        .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
        .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
    }
    function Us(e, t) {
      return e
        .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
        .replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
    }
    const Bs = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function Gs(e) {
      return e.replace(Bs, Vs);
    }
    function Vs(e, t) {
      const i = qi[t];
      if (void 0 === i) throw new Error('Can not resolve #include <' + t + '>');
      return Gs(i);
    }
    const Hs = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
      js =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function Ws(e) {
      return e.replace(js, qs).replace(Hs, Xs);
    }
    function Xs(e, t, i, n) {
      return qs(e, t, i, n);
    }
    function qs(e, t, i, n) {
      let s = '';
      for (let e = parseInt(t); e < parseInt(i); e++)
        s += n.replace(/\[\s*i\s*\]/g, '[ ' + e + ' ]').replace(/UNROLLED_LOOP_INDEX/g, e);
      return s;
    }
    function Ys(e) {
      let t = 'precision ' + e.precision + ' float;\nprecision ' + e.precision + ' int;';
      return (
        'highp' === e.precision
          ? (t += '\n#define HIGH_PRECISION')
          : 'mediump' === e.precision
          ? (t += '\n#define MEDIUM_PRECISION')
          : 'lowp' === e.precision && (t += '\n#define LOW_PRECISION'),
        t
      );
    }
    function Zs(e, t, i, n) {
      const s = e.getContext(),
        o = i.defines;
      let l = i.vertexShader,
        c = i.fragmentShader;
      const u = (function (e) {
          let t = 'SHADOWMAP_TYPE_BASIC';
          return (
            1 === e.shadowMapType
              ? (t = 'SHADOWMAP_TYPE_PCF')
              : 2 === e.shadowMapType
              ? (t = 'SHADOWMAP_TYPE_PCF_SOFT')
              : 3 === e.shadowMapType && (t = 'SHADOWMAP_TYPE_VSM'),
            t
          );
        })(i),
        d = (function (e) {
          let t = 'ENVMAP_TYPE_CUBE';
          if (e.envMap)
            switch (e.envMapMode) {
              case r:
              case a:
                t = 'ENVMAP_TYPE_CUBE';
                break;
              case h:
                t = 'ENVMAP_TYPE_CUBE_UV';
            }
          return t;
        })(i),
        m = (function (e) {
          let t = 'ENVMAP_MODE_REFLECTION';
          e.envMap && e.envMapMode === a && (t = 'ENVMAP_MODE_REFRACTION');
          return t;
        })(i),
        p = (function (e) {
          let t = 'ENVMAP_BLENDING_NONE';
          if (e.envMap)
            switch (e.combine) {
              case 0:
                t = 'ENVMAP_BLENDING_MULTIPLY';
                break;
              case 1:
                t = 'ENVMAP_BLENDING_MIX';
                break;
              case 2:
                t = 'ENVMAP_BLENDING_ADD';
            }
          return t;
        })(i),
        f = (function (e) {
          const t = e.envMapCubeUVHeight;
          if (null === t) return null;
          const i = Math.log2(t) - 2,
            n = 1 / t;
          return { texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 112)), texelHeight: n, maxMip: i };
        })(i),
        g = i.isWebGL2
          ? ''
          : (function (e) {
              return [
                e.extensionDerivatives ||
                e.envMapCubeUVHeight ||
                e.bumpMap ||
                e.tangentSpaceNormalMap ||
                e.clearcoatNormalMap ||
                e.flatShading ||
                'physical' === e.shaderID
                  ? '#extension GL_OES_standard_derivatives : enable'
                  : '',
                (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth
                  ? '#extension GL_EXT_frag_depth : enable'
                  : '',
                e.extensionDrawBuffers && e.rendererExtensionDrawBuffers
                  ? '#extension GL_EXT_draw_buffers : require'
                  : '',
                (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod
                  ? '#extension GL_EXT_shader_texture_lod : enable'
                  : '',
              ]
                .filter(Fs)
                .join('\n');
            })(i),
        _ = (function (e) {
          const t = [];
          for (const i in e) {
            const n = e[i];
            !1 !== n && t.push('#define ' + i + ' ' + n);
          }
          return t.join('\n');
        })(o),
        v = s.createProgram();
      let x,
        y,
        M = i.glslVersion ? '#version ' + i.glslVersion + '\n' : '';
      i.isRawShaderMaterial
        ? ((x = [_].filter(Fs).join('\n')),
          x.length > 0 && (x += '\n'),
          (y = [g, _].filter(Fs).join('\n')),
          y.length > 0 && (y += '\n'))
        : ((x = [
            Ys(i),
            '#define SHADER_NAME ' + i.shaderName,
            _,
            i.instancing ? '#define USE_INSTANCING' : '',
            i.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
            i.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
            i.useFog && i.fog ? '#define USE_FOG' : '',
            i.useFog && i.fogExp2 ? '#define FOG_EXP2' : '',
            i.map ? '#define USE_MAP' : '',
            i.envMap ? '#define USE_ENVMAP' : '',
            i.envMap ? '#define ' + m : '',
            i.lightMap ? '#define USE_LIGHTMAP' : '',
            i.aoMap ? '#define USE_AOMAP' : '',
            i.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            i.bumpMap ? '#define USE_BUMPMAP' : '',
            i.normalMap ? '#define USE_NORMALMAP' : '',
            i.normalMap && i.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            i.normalMap && i.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
            i.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            i.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            i.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            i.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
            i.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
            i.displacementMap && i.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
            i.specularMap ? '#define USE_SPECULARMAP' : '',
            i.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
            i.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
            i.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            i.metalnessMap ? '#define USE_METALNESSMAP' : '',
            i.alphaMap ? '#define USE_ALPHAMAP' : '',
            i.transmission ? '#define USE_TRANSMISSION' : '',
            i.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
            i.thicknessMap ? '#define USE_THICKNESSMAP' : '',
            i.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
            i.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',
            i.vertexTangents ? '#define USE_TANGENT' : '',
            i.vertexColors ? '#define USE_COLOR' : '',
            i.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
            i.vertexUvs ? '#define USE_UV' : '',
            i.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            i.flatShading ? '#define FLAT_SHADED' : '',
            i.skinning ? '#define USE_SKINNING' : '',
            i.morphTargets ? '#define USE_MORPHTARGETS' : '',
            i.morphNormals && !1 === i.flatShading ? '#define USE_MORPHNORMALS' : '',
            i.morphColors && i.isWebGL2 ? '#define USE_MORPHCOLORS' : '',
            i.morphTargetsCount > 0 && i.isWebGL2 ? '#define MORPHTARGETS_TEXTURE' : '',
            i.morphTargetsCount > 0 && i.isWebGL2 ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + i.morphTextureStride : '',
            i.morphTargetsCount > 0 && i.isWebGL2 ? '#define MORPHTARGETS_COUNT ' + i.morphTargetsCount : '',
            i.doubleSided ? '#define DOUBLE_SIDED' : '',
            i.flipSided ? '#define FLIP_SIDED' : '',
            i.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            i.shadowMapEnabled ? '#define ' + u : '',
            i.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
            i.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
            'uniform mat4 modelMatrix;',
            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform mat4 viewMatrix;',
            'uniform mat3 normalMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            '#ifdef USE_INSTANCING',
            '\tattribute mat4 instanceMatrix;',
            '#endif',
            '#ifdef USE_INSTANCING_COLOR',
            '\tattribute vec3 instanceColor;',
            '#endif',
            'attribute vec3 position;',
            'attribute vec3 normal;',
            'attribute vec2 uv;',
            '#ifdef USE_TANGENT',
            '\tattribute vec4 tangent;',
            '#endif',
            '#if defined( USE_COLOR_ALPHA )',
            '\tattribute vec4 color;',
            '#elif defined( USE_COLOR )',
            '\tattribute vec3 color;',
            '#endif',
            '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',
            '\tattribute vec3 morphTarget0;',
            '\tattribute vec3 morphTarget1;',
            '\tattribute vec3 morphTarget2;',
            '\tattribute vec3 morphTarget3;',
            '\t#ifdef USE_MORPHNORMALS',
            '\t\tattribute vec3 morphNormal0;',
            '\t\tattribute vec3 morphNormal1;',
            '\t\tattribute vec3 morphNormal2;',
            '\t\tattribute vec3 morphNormal3;',
            '\t#else',
            '\t\tattribute vec3 morphTarget4;',
            '\t\tattribute vec3 morphTarget5;',
            '\t\tattribute vec3 morphTarget6;',
            '\t\tattribute vec3 morphTarget7;',
            '\t#endif',
            '#endif',
            '#ifdef USE_SKINNING',
            '\tattribute vec4 skinIndex;',
            '\tattribute vec4 skinWeight;',
            '#endif',
            '\n',
          ]
            .filter(Fs)
            .join('\n')),
          (y = [
            g,
            Ys(i),
            '#define SHADER_NAME ' + i.shaderName,
            _,
            i.useFog && i.fog ? '#define USE_FOG' : '',
            i.useFog && i.fogExp2 ? '#define FOG_EXP2' : '',
            i.map ? '#define USE_MAP' : '',
            i.matcap ? '#define USE_MATCAP' : '',
            i.envMap ? '#define USE_ENVMAP' : '',
            i.envMap ? '#define ' + d : '',
            i.envMap ? '#define ' + m : '',
            i.envMap ? '#define ' + p : '',
            f ? '#define CUBEUV_TEXEL_WIDTH ' + f.texelWidth : '',
            f ? '#define CUBEUV_TEXEL_HEIGHT ' + f.texelHeight : '',
            f ? '#define CUBEUV_MAX_MIP ' + f.maxMip + '.0' : '',
            i.lightMap ? '#define USE_LIGHTMAP' : '',
            i.aoMap ? '#define USE_AOMAP' : '',
            i.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            i.bumpMap ? '#define USE_BUMPMAP' : '',
            i.normalMap ? '#define USE_NORMALMAP' : '',
            i.normalMap && i.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            i.normalMap && i.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
            i.clearcoat ? '#define USE_CLEARCOAT' : '',
            i.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            i.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            i.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            i.iridescence ? '#define USE_IRIDESCENCE' : '',
            i.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
            i.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
            i.specularMap ? '#define USE_SPECULARMAP' : '',
            i.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
            i.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
            i.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            i.metalnessMap ? '#define USE_METALNESSMAP' : '',
            i.alphaMap ? '#define USE_ALPHAMAP' : '',
            i.alphaTest ? '#define USE_ALPHATEST' : '',
            i.sheen ? '#define USE_SHEEN' : '',
            i.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
            i.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',
            i.transmission ? '#define USE_TRANSMISSION' : '',
            i.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
            i.thicknessMap ? '#define USE_THICKNESSMAP' : '',
            i.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
            i.vertexTangents ? '#define USE_TANGENT' : '',
            i.vertexColors || i.instancingColor ? '#define USE_COLOR' : '',
            i.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
            i.vertexUvs ? '#define USE_UV' : '',
            i.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            i.gradientMap ? '#define USE_GRADIENTMAP' : '',
            i.flatShading ? '#define FLAT_SHADED' : '',
            i.doubleSided ? '#define DOUBLE_SIDED' : '',
            i.flipSided ? '#define FLIP_SIDED' : '',
            i.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            i.shadowMapEnabled ? '#define ' + u : '',
            i.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
            i.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
            i.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
            'uniform mat4 viewMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            0 !== i.toneMapping ? '#define TONE_MAPPING' : '',
            0 !== i.toneMapping ? qi.tonemapping_pars_fragment : '',
            0 !== i.toneMapping ? zs('toneMapping', i.toneMapping) : '',
            i.dithering ? '#define DITHERING' : '',
            i.opaque ? '#define OPAQUE' : '',
            qi.encodings_pars_fragment,
            Ns('linearToOutputTexel', i.outputEncoding),
            i.useDepthPacking ? '#define DEPTH_PACKING ' + i.depthPacking : '',
            '\n',
          ]
            .filter(Fs)
            .join('\n'))),
        (l = Gs(l)),
        (l = ks(l, i)),
        (l = Us(l, i)),
        (c = Gs(c)),
        (c = ks(c, i)),
        (c = Us(c, i)),
        (l = Ws(l)),
        (c = Ws(c)),
        i.isWebGL2 &&
          !0 !== i.isRawShaderMaterial &&
          ((M = '#version 300 es\n'),
          (x =
            [
              'precision mediump sampler2DArray;',
              '#define attribute in',
              '#define varying out',
              '#define texture2D texture',
            ].join('\n') +
            '\n' +
            x),
          (y =
            [
              '#define varying in',
              i.glslVersion === H ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
              i.glslVersion === H ? '' : '#define gl_FragColor pc_fragColor',
              '#define gl_FragDepthEXT gl_FragDepth',
              '#define texture2D texture',
              '#define textureCube texture',
              '#define texture2DProj textureProj',
              '#define texture2DLodEXT textureLod',
              '#define texture2DProjLodEXT textureProjLod',
              '#define textureCubeLodEXT textureLod',
              '#define texture2DGradEXT textureGrad',
              '#define texture2DProjGradEXT textureProjGrad',
              '#define textureCubeGradEXT textureGrad',
            ].join('\n') +
            '\n' +
            y));
      const b = M + y + c,
        S = Is(s, 35633, M + x + l),
        w = Is(s, 35632, b);
      if (
        (s.attachShader(v, S),
        s.attachShader(v, w),
        void 0 !== i.index0AttributeName
          ? s.bindAttribLocation(v, 0, i.index0AttributeName)
          : !0 === i.morphTargets && s.bindAttribLocation(v, 0, 'position'),
        s.linkProgram(v),
        e.debug.checkShaderErrors)
      ) {
        const e = s.getProgramInfoLog(v).trim(),
          t = s.getShaderInfoLog(S).trim(),
          i = s.getShaderInfoLog(w).trim();
        let n = !0,
          r = !0;
        if (!1 === s.getProgramParameter(v, 35714)) {
          n = !1;
          Os(s, S, 'vertex'), Os(s, w, 'fragment');
        } else '' !== e || ('' !== t && '' !== i) || (r = !1);
        r &&
          (this.diagnostics = {
            runnable: n,
            programLog: e,
            vertexShader: { log: t, prefix: x },
            fragmentShader: { log: i, prefix: y },
          });
      }
      let A, T;
      return (
        s.deleteShader(S),
        s.deleteShader(w),
        (this.getUniforms = function () {
          return void 0 === A && (A = new Ds(s, v)), A;
        }),
        (this.getAttributes = function () {
          return (
            void 0 === T &&
              (T = (function (e, t) {
                const i = {},
                  n = e.getProgramParameter(t, 35721);
                for (let s = 0; s < n; s++) {
                  const n = e.getActiveAttrib(t, s),
                    r = n.name;
                  let a = 1;
                  35674 === n.type && (a = 2),
                    35675 === n.type && (a = 3),
                    35676 === n.type && (a = 4),
                    (i[r] = { type: n.type, location: e.getAttribLocation(t, r), locationSize: a });
                }
                return i;
              })(s, v)),
            T
          );
        }),
        (this.destroy = function () {
          n.releaseStatesOfProgram(this), s.deleteProgram(v), (this.program = void 0);
        }),
        (this.name = i.shaderName),
        (this.id = Rs++),
        (this.cacheKey = t),
        (this.usedTimes = 1),
        (this.program = v),
        (this.vertexShader = S),
        (this.fragmentShader = w),
        this
      );
    }
    let Js = 0;
    class Ks {
      constructor() {
        (this.shaderCache = new Map()), (this.materialCache = new Map());
      }
      update(e) {
        const t = e.vertexShader,
          i = e.fragmentShader,
          n = this._getShaderStage(t),
          s = this._getShaderStage(i),
          r = this._getShaderCacheForMaterial(e);
        return !1 === r.has(n) && (r.add(n), n.usedTimes++), !1 === r.has(s) && (r.add(s), s.usedTimes++), this;
      }
      remove(e) {
        const t = this.materialCache.get(e);
        for (const e of t) e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code);
        return this.materialCache.delete(e), this;
      }
      getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id;
      }
      getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id;
      }
      dispose() {
        this.shaderCache.clear(), this.materialCache.clear();
      }
      _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        return !1 === t.has(e) && t.set(e, new Set()), t.get(e);
      }
      _getShaderStage(e) {
        const t = this.shaderCache;
        if (!1 === t.has(e)) {
          const i = new $s(e);
          t.set(e, i);
        }
        return t.get(e);
      }
    }
    class $s {
      constructor(e) {
        (this.id = Js++), (this.code = e), (this.usedTimes = 0);
      }
    }
    function Qs(e, t, i, n, s, r, a) {
      const o = new vt(),
        l = new Ks(),
        c = [],
        u = s.isWebGL2,
        d = s.logarithmicDepthBuffer,
        m = s.vertexTextures;
      let p = s.precision;
      const f = {
        MeshDepthMaterial: 'depth',
        MeshDistanceMaterial: 'distanceRGBA',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        MeshToonMaterial: 'toon',
        MeshStandardMaterial: 'physical',
        MeshPhysicalMaterial: 'physical',
        MeshMatcapMaterial: 'matcap',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points',
        ShadowMaterial: 'shadow',
        SpriteMaterial: 'sprite',
      };
      return {
        getParameters: function (r, o, c, g, _) {
          const v = g.fog,
            x = _.geometry,
            y = r.isMeshStandardMaterial ? g.environment : null,
            M = (r.isMeshStandardMaterial ? i : t).get(r.envMap || y),
            b = M && M.mapping === h ? M.image.height : null,
            S = f[r.type];
          null !== r.precision && ((p = s.getMaxPrecision(r.precision)), r.precision);
          const w = x.morphAttributes.position || x.morphAttributes.normal || x.morphAttributes.color,
            A = void 0 !== w ? w.length : 0;
          let T,
            E,
            L,
            C,
            P = 0;
          if (
            (void 0 !== x.morphAttributes.position && (P = 1),
            void 0 !== x.morphAttributes.normal && (P = 2),
            void 0 !== x.morphAttributes.color && (P = 3),
            S)
          ) {
            const e = Zi[S];
            (T = e.vertexShader), (E = e.fragmentShader);
          } else
            (T = r.vertexShader),
              (E = r.fragmentShader),
              l.update(r),
              (L = l.getVertexShaderID(r)),
              (C = l.getFragmentShaderID(r));
          const D = e.getRenderTarget(),
            I = r.alphaTest > 0,
            R = r.clearcoat > 0,
            O = r.iridescence > 0;
          return {
            isWebGL2: u,
            shaderID: S,
            shaderName: r.type,
            vertexShader: T,
            fragmentShader: E,
            defines: r.defines,
            customVertexShaderID: L,
            customFragmentShaderID: C,
            isRawShaderMaterial: !0 === r.isRawShaderMaterial,
            glslVersion: r.glslVersion,
            precision: p,
            instancing: !0 === _.isInstancedMesh,
            instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
            supportsVertexTextures: m,
            outputEncoding: null === D ? e.outputEncoding : !0 === D.isXRRenderTarget ? D.texture.encoding : F,
            map: !!r.map,
            matcap: !!r.matcap,
            envMap: !!M,
            envMapMode: M && M.mapping,
            envMapCubeUVHeight: b,
            lightMap: !!r.lightMap,
            aoMap: !!r.aoMap,
            emissiveMap: !!r.emissiveMap,
            bumpMap: !!r.bumpMap,
            normalMap: !!r.normalMap,
            objectSpaceNormalMap: 1 === r.normalMapType,
            tangentSpaceNormalMap: 0 === r.normalMapType,
            decodeVideoTexture: !!r.map && !0 === r.map.isVideoTexture && r.map.encoding === k,
            clearcoat: R,
            clearcoatMap: R && !!r.clearcoatMap,
            clearcoatRoughnessMap: R && !!r.clearcoatRoughnessMap,
            clearcoatNormalMap: R && !!r.clearcoatNormalMap,
            iridescence: O,
            iridescenceMap: O && !!r.iridescenceMap,
            iridescenceThicknessMap: O && !!r.iridescenceThicknessMap,
            displacementMap: !!r.displacementMap,
            roughnessMap: !!r.roughnessMap,
            metalnessMap: !!r.metalnessMap,
            specularMap: !!r.specularMap,
            specularIntensityMap: !!r.specularIntensityMap,
            specularColorMap: !!r.specularColorMap,
            opaque: !1 === r.transparent && 1 === r.blending,
            alphaMap: !!r.alphaMap,
            alphaTest: I,
            gradientMap: !!r.gradientMap,
            sheen: r.sheen > 0,
            sheenColorMap: !!r.sheenColorMap,
            sheenRoughnessMap: !!r.sheenRoughnessMap,
            transmission: r.transmission > 0,
            transmissionMap: !!r.transmissionMap,
            thicknessMap: !!r.thicknessMap,
            combine: r.combine,
            vertexTangents: !!r.normalMap && !!x.attributes.tangent,
            vertexColors: r.vertexColors,
            vertexAlphas: !0 === r.vertexColors && !!x.attributes.color && 4 === x.attributes.color.itemSize,
            vertexUvs: !!(
              r.map ||
              r.bumpMap ||
              r.normalMap ||
              r.specularMap ||
              r.alphaMap ||
              r.emissiveMap ||
              r.roughnessMap ||
              r.metalnessMap ||
              r.clearcoatMap ||
              r.clearcoatRoughnessMap ||
              r.clearcoatNormalMap ||
              r.iridescenceMap ||
              r.iridescenceThicknessMap ||
              r.displacementMap ||
              r.transmissionMap ||
              r.thicknessMap ||
              r.specularIntensityMap ||
              r.specularColorMap ||
              r.sheenColorMap ||
              r.sheenRoughnessMap
            ),
            uvsVertexOnly: !(
              r.map ||
              r.bumpMap ||
              r.normalMap ||
              r.specularMap ||
              r.alphaMap ||
              r.emissiveMap ||
              r.roughnessMap ||
              r.metalnessMap ||
              r.clearcoatNormalMap ||
              r.iridescenceMap ||
              r.iridescenceThicknessMap ||
              r.transmission > 0 ||
              r.transmissionMap ||
              r.thicknessMap ||
              r.specularIntensityMap ||
              r.specularColorMap ||
              r.sheen > 0 ||
              r.sheenColorMap ||
              r.sheenRoughnessMap ||
              !r.displacementMap
            ),
            fog: !!v,
            useFog: !0 === r.fog,
            fogExp2: v && v.isFogExp2,
            flatShading: !!r.flatShading,
            sizeAttenuation: r.sizeAttenuation,
            logarithmicDepthBuffer: d,
            skinning: !0 === _.isSkinnedMesh,
            morphTargets: void 0 !== x.morphAttributes.position,
            morphNormals: void 0 !== x.morphAttributes.normal,
            morphColors: void 0 !== x.morphAttributes.color,
            morphTargetsCount: A,
            morphTextureStride: P,
            numDirLights: o.directional.length,
            numPointLights: o.point.length,
            numSpotLights: o.spot.length,
            numRectAreaLights: o.rectArea.length,
            numHemiLights: o.hemi.length,
            numDirLightShadows: o.directionalShadowMap.length,
            numPointLightShadows: o.pointShadowMap.length,
            numSpotLightShadows: o.spotShadowMap.length,
            numClippingPlanes: a.numPlanes,
            numClipIntersection: a.numIntersection,
            dithering: r.dithering,
            shadowMapEnabled: e.shadowMap.enabled && c.length > 0,
            shadowMapType: e.shadowMap.type,
            toneMapping: r.toneMapped ? e.toneMapping : 0,
            physicallyCorrectLights: e.physicallyCorrectLights,
            premultipliedAlpha: r.premultipliedAlpha,
            doubleSided: 2 === r.side,
            flipSided: 1 === r.side,
            useDepthPacking: !!r.depthPacking,
            depthPacking: r.depthPacking || 0,
            index0AttributeName: r.index0AttributeName,
            extensionDerivatives: r.extensions && r.extensions.derivatives,
            extensionFragDepth: r.extensions && r.extensions.fragDepth,
            extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
            extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: u || n.has('EXT_frag_depth'),
            rendererExtensionDrawBuffers: u || n.has('WEBGL_draw_buffers'),
            rendererExtensionShaderTextureLod: u || n.has('EXT_shader_texture_lod'),
            customProgramCacheKey: r.customProgramCacheKey(),
          };
        },
        getProgramCacheKey: function (t) {
          const i = [];
          if (
            (t.shaderID ? i.push(t.shaderID) : (i.push(t.customVertexShaderID), i.push(t.customFragmentShaderID)),
            void 0 !== t.defines)
          )
            for (const e in t.defines) i.push(e), i.push(t.defines[e]);
          return (
            !1 === t.isRawShaderMaterial &&
              (!(function (e, t) {
                e.push(t.precision),
                  e.push(t.outputEncoding),
                  e.push(t.envMapMode),
                  e.push(t.envMapCubeUVHeight),
                  e.push(t.combine),
                  e.push(t.vertexUvs),
                  e.push(t.fogExp2),
                  e.push(t.sizeAttenuation),
                  e.push(t.morphTargetsCount),
                  e.push(t.morphAttributeCount),
                  e.push(t.numDirLights),
                  e.push(t.numPointLights),
                  e.push(t.numSpotLights),
                  e.push(t.numHemiLights),
                  e.push(t.numRectAreaLights),
                  e.push(t.numDirLightShadows),
                  e.push(t.numPointLightShadows),
                  e.push(t.numSpotLightShadows),
                  e.push(t.shadowMapType),
                  e.push(t.toneMapping),
                  e.push(t.numClippingPlanes),
                  e.push(t.numClipIntersection),
                  e.push(t.depthPacking);
              })(i, t),
              (function (e, t) {
                o.disableAll(), t.isWebGL2 && o.enable(0);
                t.supportsVertexTextures && o.enable(1);
                t.instancing && o.enable(2);
                t.instancingColor && o.enable(3);
                t.map && o.enable(4);
                t.matcap && o.enable(5);
                t.envMap && o.enable(6);
                t.lightMap && o.enable(7);
                t.aoMap && o.enable(8);
                t.emissiveMap && o.enable(9);
                t.bumpMap && o.enable(10);
                t.normalMap && o.enable(11);
                t.objectSpaceNormalMap && o.enable(12);
                t.tangentSpaceNormalMap && o.enable(13);
                t.clearcoat && o.enable(14);
                t.clearcoatMap && o.enable(15);
                t.clearcoatRoughnessMap && o.enable(16);
                t.clearcoatNormalMap && o.enable(17);
                t.iridescence && o.enable(18);
                t.iridescenceMap && o.enable(19);
                t.iridescenceThicknessMap && o.enable(20);
                t.displacementMap && o.enable(21);
                t.specularMap && o.enable(22);
                t.roughnessMap && o.enable(23);
                t.metalnessMap && o.enable(24);
                t.gradientMap && o.enable(25);
                t.alphaMap && o.enable(26);
                t.alphaTest && o.enable(27);
                t.vertexColors && o.enable(28);
                t.vertexAlphas && o.enable(29);
                t.vertexUvs && o.enable(30);
                t.vertexTangents && o.enable(31);
                t.uvsVertexOnly && o.enable(32);
                t.fog && o.enable(33);
                e.push(o.mask), o.disableAll(), t.useFog && o.enable(0);
                t.flatShading && o.enable(1);
                t.logarithmicDepthBuffer && o.enable(2);
                t.skinning && o.enable(3);
                t.morphTargets && o.enable(4);
                t.morphNormals && o.enable(5);
                t.morphColors && o.enable(6);
                t.premultipliedAlpha && o.enable(7);
                t.shadowMapEnabled && o.enable(8);
                t.physicallyCorrectLights && o.enable(9);
                t.doubleSided && o.enable(10);
                t.flipSided && o.enable(11);
                t.useDepthPacking && o.enable(12);
                t.dithering && o.enable(13);
                t.specularIntensityMap && o.enable(14);
                t.specularColorMap && o.enable(15);
                t.transmission && o.enable(16);
                t.transmissionMap && o.enable(17);
                t.thicknessMap && o.enable(18);
                t.sheen && o.enable(19);
                t.sheenColorMap && o.enable(20);
                t.sheenRoughnessMap && o.enable(21);
                t.decodeVideoTexture && o.enable(22);
                t.opaque && o.enable(23);
                e.push(o.mask);
              })(i, t),
              i.push(e.outputEncoding)),
            i.push(t.customProgramCacheKey),
            i.join()
          );
        },
        getUniforms: function (e) {
          const t = f[e.type];
          let i;
          if (t) {
            const e = Zi[t];
            i = Ci.clone(e.uniforms);
          } else i = e.uniforms;
          return i;
        },
        acquireProgram: function (t, i) {
          let n;
          for (let e = 0, t = c.length; e < t; e++) {
            const t = c[e];
            if (t.cacheKey === i) {
              (n = t), ++n.usedTimes;
              break;
            }
          }
          return void 0 === n && ((n = new Zs(e, i, t, r)), c.push(n)), n;
        },
        releaseProgram: function (e) {
          if (0 == --e.usedTimes) {
            const t = c.indexOf(e);
            (c[t] = c[c.length - 1]), c.pop(), e.destroy();
          }
        },
        releaseShaderCache: function (e) {
          l.remove(e);
        },
        programs: c,
        dispose: function () {
          l.dispose();
        },
      };
    }
    function er() {
      let e = new WeakMap();
      return {
        get: function (t) {
          let i = e.get(t);
          return void 0 === i && ((i = {}), e.set(t, i)), i;
        },
        remove: function (t) {
          e.delete(t);
        },
        update: function (t, i, n) {
          e.get(t)[i] = n;
        },
        dispose: function () {
          e = new WeakMap();
        },
      };
    }
    function tr(e, t) {
      return e.groupOrder !== t.groupOrder
        ? e.groupOrder - t.groupOrder
        : e.renderOrder !== t.renderOrder
        ? e.renderOrder - t.renderOrder
        : e.material.id !== t.material.id
        ? e.material.id - t.material.id
        : e.z !== t.z
        ? e.z - t.z
        : e.id - t.id;
    }
    function ir(e, t) {
      return e.groupOrder !== t.groupOrder
        ? e.groupOrder - t.groupOrder
        : e.renderOrder !== t.renderOrder
        ? e.renderOrder - t.renderOrder
        : e.z !== t.z
        ? t.z - e.z
        : e.id - t.id;
    }
    function nr() {
      const e = [];
      let t = 0;
      const i = [],
        n = [],
        s = [];
      function r(i, n, s, r, a, o) {
        let l = e[t];
        return (
          void 0 === l
            ? ((l = {
                id: i.id,
                object: i,
                geometry: n,
                material: s,
                groupOrder: r,
                renderOrder: i.renderOrder,
                z: a,
                group: o,
              }),
              (e[t] = l))
            : ((l.id = i.id),
              (l.object = i),
              (l.geometry = n),
              (l.material = s),
              (l.groupOrder = r),
              (l.renderOrder = i.renderOrder),
              (l.z = a),
              (l.group = o)),
          t++,
          l
        );
      }
      return {
        opaque: i,
        transmissive: n,
        transparent: s,
        init: function () {
          (t = 0), (i.length = 0), (n.length = 0), (s.length = 0);
        },
        push: function (e, t, a, o, l, h) {
          const c = r(e, t, a, o, l, h);
          a.transmission > 0 ? n.push(c) : !0 === a.transparent ? s.push(c) : i.push(c);
        },
        unshift: function (e, t, a, o, l, h) {
          const c = r(e, t, a, o, l, h);
          a.transmission > 0 ? n.unshift(c) : !0 === a.transparent ? s.unshift(c) : i.unshift(c);
        },
        finish: function () {
          for (let i = t, n = e.length; i < n; i++) {
            const t = e[i];
            if (null === t.id) break;
            (t.id = null), (t.object = null), (t.geometry = null), (t.material = null), (t.group = null);
          }
        },
        sort: function (e, t) {
          i.length > 1 && i.sort(e || tr), n.length > 1 && n.sort(t || ir), s.length > 1 && s.sort(t || ir);
        },
      };
    }
    function sr() {
      let e = new WeakMap();
      return {
        get: function (t, i) {
          let n;
          return (
            !1 === e.has(t)
              ? ((n = new nr()), e.set(t, [n]))
              : i >= e.get(t).length
              ? ((n = new nr()), e.get(t).push(n))
              : (n = e.get(t)[i]),
            n
          );
        },
        dispose: function () {
          e = new WeakMap();
        },
      };
    }
    function rr() {
      const e = {};
      return {
        get: function (t) {
          if (void 0 !== e[t.id]) return e[t.id];
          let i;
          switch (t.type) {
            case 'DirectionalLight':
              i = { direction: new Pe(), color: new ve() };
              break;
            case 'SpotLight':
              i = {
                position: new Pe(),
                direction: new Pe(),
                color: new ve(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
              };
              break;
            case 'PointLight':
              i = { position: new Pe(), color: new ve(), distance: 0, decay: 0 };
              break;
            case 'HemisphereLight':
              i = { direction: new Pe(), skyColor: new ve(), groundColor: new ve() };
              break;
            case 'RectAreaLight':
              i = { color: new ve(), position: new Pe(), halfWidth: new Pe(), halfHeight: new Pe() };
          }
          return (e[t.id] = i), i;
        },
      };
    }
    let ar = 0;
    function or(e, t) {
      return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
    }
    function lr(e, t) {
      const i = new rr(),
        n = (function () {
          const e = {};
          return {
            get: function (t) {
              if (void 0 !== e[t.id]) return e[t.id];
              let i;
              switch (t.type) {
                case 'DirectionalLight':
                case 'SpotLight':
                  i = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new se() };
                  break;
                case 'PointLight':
                  i = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new se(),
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3,
                  };
              }
              return (e[t.id] = i), i;
            },
          };
        })(),
        s = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadow: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
        };
      for (let e = 0; e < 9; e++) s.probe.push(new Pe());
      const r = new Pe(),
        a = new ot(),
        o = new ot();
      return {
        setup: function (r, a) {
          let o = 0,
            l = 0,
            h = 0;
          for (let e = 0; e < 9; e++) s.probe[e].set(0, 0, 0);
          let c = 0,
            u = 0,
            d = 0,
            m = 0,
            p = 0,
            f = 0,
            g = 0,
            _ = 0;
          r.sort(or);
          const v = !0 !== a ? Math.PI : 1;
          for (let e = 0, t = r.length; e < t; e++) {
            const t = r[e],
              a = t.color,
              x = t.intensity,
              y = t.distance,
              M = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
            if (t.isAmbientLight) (o += a.r * x * v), (l += a.g * x * v), (h += a.b * x * v);
            else if (t.isLightProbe) for (let e = 0; e < 9; e++) s.probe[e].addScaledVector(t.sh.coefficients[e], x);
            else if (t.isDirectionalLight) {
              const e = i.get(t);
              if ((e.color.copy(t.color).multiplyScalar(t.intensity * v), t.castShadow)) {
                const e = t.shadow,
                  i = n.get(t);
                (i.shadowBias = e.bias),
                  (i.shadowNormalBias = e.normalBias),
                  (i.shadowRadius = e.radius),
                  (i.shadowMapSize = e.mapSize),
                  (s.directionalShadow[c] = i),
                  (s.directionalShadowMap[c] = M),
                  (s.directionalShadowMatrix[c] = t.shadow.matrix),
                  f++;
              }
              (s.directional[c] = e), c++;
            } else if (t.isSpotLight) {
              const e = i.get(t);
              if (
                (e.position.setFromMatrixPosition(t.matrixWorld),
                e.color.copy(a).multiplyScalar(x * v),
                (e.distance = y),
                (e.coneCos = Math.cos(t.angle)),
                (e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra))),
                (e.decay = t.decay),
                t.castShadow)
              ) {
                const e = t.shadow,
                  i = n.get(t);
                (i.shadowBias = e.bias),
                  (i.shadowNormalBias = e.normalBias),
                  (i.shadowRadius = e.radius),
                  (i.shadowMapSize = e.mapSize),
                  (s.spotShadow[d] = i),
                  (s.spotShadowMap[d] = M),
                  (s.spotShadowMatrix[d] = t.shadow.matrix),
                  _++;
              }
              (s.spot[d] = e), d++;
            } else if (t.isRectAreaLight) {
              const e = i.get(t);
              e.color.copy(a).multiplyScalar(x),
                e.halfWidth.set(0.5 * t.width, 0, 0),
                e.halfHeight.set(0, 0.5 * t.height, 0),
                (s.rectArea[m] = e),
                m++;
            } else if (t.isPointLight) {
              const e = i.get(t);
              if (
                (e.color.copy(t.color).multiplyScalar(t.intensity * v),
                (e.distance = t.distance),
                (e.decay = t.decay),
                t.castShadow)
              ) {
                const e = t.shadow,
                  i = n.get(t);
                (i.shadowBias = e.bias),
                  (i.shadowNormalBias = e.normalBias),
                  (i.shadowRadius = e.radius),
                  (i.shadowMapSize = e.mapSize),
                  (i.shadowCameraNear = e.camera.near),
                  (i.shadowCameraFar = e.camera.far),
                  (s.pointShadow[u] = i),
                  (s.pointShadowMap[u] = M),
                  (s.pointShadowMatrix[u] = t.shadow.matrix),
                  g++;
              }
              (s.point[u] = e), u++;
            } else if (t.isHemisphereLight) {
              const e = i.get(t);
              e.skyColor.copy(t.color).multiplyScalar(x * v),
                e.groundColor.copy(t.groundColor).multiplyScalar(x * v),
                (s.hemi[p] = e),
                p++;
            }
          }
          m > 0 &&
            (t.isWebGL2 || !0 === e.has('OES_texture_float_linear')
              ? ((s.rectAreaLTC1 = Yi.LTC_FLOAT_1), (s.rectAreaLTC2 = Yi.LTC_FLOAT_2))
              : !0 === e.has('OES_texture_half_float_linear') &&
                ((s.rectAreaLTC1 = Yi.LTC_HALF_1), (s.rectAreaLTC2 = Yi.LTC_HALF_2))),
            (s.ambient[0] = o),
            (s.ambient[1] = l),
            (s.ambient[2] = h);
          const x = s.hash;
          (x.directionalLength === c &&
            x.pointLength === u &&
            x.spotLength === d &&
            x.rectAreaLength === m &&
            x.hemiLength === p &&
            x.numDirectionalShadows === f &&
            x.numPointShadows === g &&
            x.numSpotShadows === _) ||
            ((s.directional.length = c),
            (s.spot.length = d),
            (s.rectArea.length = m),
            (s.point.length = u),
            (s.hemi.length = p),
            (s.directionalShadow.length = f),
            (s.directionalShadowMap.length = f),
            (s.pointShadow.length = g),
            (s.pointShadowMap.length = g),
            (s.spotShadow.length = _),
            (s.spotShadowMap.length = _),
            (s.directionalShadowMatrix.length = f),
            (s.pointShadowMatrix.length = g),
            (s.spotShadowMatrix.length = _),
            (x.directionalLength = c),
            (x.pointLength = u),
            (x.spotLength = d),
            (x.rectAreaLength = m),
            (x.hemiLength = p),
            (x.numDirectionalShadows = f),
            (x.numPointShadows = g),
            (x.numSpotShadows = _),
            (s.version = ar++));
        },
        setupView: function (e, t) {
          let i = 0,
            n = 0,
            l = 0,
            h = 0,
            c = 0;
          const u = t.matrixWorldInverse;
          for (let t = 0, d = e.length; t < d; t++) {
            const d = e[t];
            if (d.isDirectionalLight) {
              const e = s.directional[i];
              e.direction.setFromMatrixPosition(d.matrixWorld),
                r.setFromMatrixPosition(d.target.matrixWorld),
                e.direction.sub(r),
                e.direction.transformDirection(u),
                i++;
            } else if (d.isSpotLight) {
              const e = s.spot[l];
              e.position.setFromMatrixPosition(d.matrixWorld),
                e.position.applyMatrix4(u),
                e.direction.setFromMatrixPosition(d.matrixWorld),
                r.setFromMatrixPosition(d.target.matrixWorld),
                e.direction.sub(r),
                e.direction.transformDirection(u),
                l++;
            } else if (d.isRectAreaLight) {
              const e = s.rectArea[h];
              e.position.setFromMatrixPosition(d.matrixWorld),
                e.position.applyMatrix4(u),
                o.identity(),
                a.copy(d.matrixWorld),
                a.premultiply(u),
                o.extractRotation(a),
                e.halfWidth.set(0.5 * d.width, 0, 0),
                e.halfHeight.set(0, 0.5 * d.height, 0),
                e.halfWidth.applyMatrix4(o),
                e.halfHeight.applyMatrix4(o),
                h++;
            } else if (d.isPointLight) {
              const e = s.point[n];
              e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), n++;
            } else if (d.isHemisphereLight) {
              const e = s.hemi[c];
              e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(u), c++;
            }
          }
        },
        state: s,
      };
    }
    function hr(e, t) {
      const i = new lr(e, t),
        n = [],
        s = [];
      return {
        init: function () {
          (n.length = 0), (s.length = 0);
        },
        state: { lightsArray: n, shadowsArray: s, lights: i },
        setupLights: function (e) {
          i.setup(n, e);
        },
        setupLightsView: function (e) {
          i.setupView(n, e);
        },
        pushLight: function (e) {
          n.push(e);
        },
        pushShadow: function (e) {
          s.push(e);
        },
      };
    }
    function cr(e, t) {
      let i = new WeakMap();
      return {
        get: function (n, s = 0) {
          let r;
          return (
            !1 === i.has(n)
              ? ((r = new hr(e, t)), i.set(n, [r]))
              : s >= i.get(n).length
              ? ((r = new hr(e, t)), i.get(n).push(r))
              : (r = i.get(n)[s]),
            r
          );
        },
        dispose: function () {
          i = new WeakMap();
        },
      };
    }
    class ur extends Wt {
      constructor(e) {
        super(),
          (this.isMeshDepthMaterial = !0),
          (this.type = 'MeshDepthMaterial'),
          (this.depthPacking = 3200),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.depthPacking = e.depthPacking),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          this
        );
      }
    }
    class dr extends Wt {
      constructor(e) {
        super(),
          (this.isMeshDistanceMaterial = !0),
          (this.type = 'MeshDistanceMaterial'),
          (this.referencePosition = new Pe()),
          (this.nearDistance = 1),
          (this.farDistance = 1e3),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.referencePosition.copy(e.referencePosition),
          (this.nearDistance = e.nearDistance),
          (this.farDistance = e.farDistance),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          this
        );
      }
    }
    function mr(e, t, i) {
      let n = new Hi();
      const s = new se(),
        r = new se(),
        a = new Ae(),
        o = new ur({ depthPacking: 3201 }),
        l = new dr(),
        h = {},
        c = i.maxTextureSize,
        u = { 0: 1, 1: 0, 2: 2 },
        d = new Pi({
          defines: { VSM_SAMPLES: 8 },
          uniforms: { shadow_pass: { value: null }, resolution: { value: new se() }, radius: { value: 4 } },
          vertexShader: 'void main() {\n\tgl_Position = vec4( position, 1.0 );\n}',
          fragmentShader:
            'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}',
        }),
        p = d.clone();
      p.defines.HORIZONTAL_PASS = 1;
      const f = new ai();
      f.setAttribute('position', new Zt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
      const g = new wi(f, d),
        _ = this;
      function v(i, n) {
        const r = t.update(g);
        d.defines.VSM_SAMPLES !== i.blurSamples &&
          ((d.defines.VSM_SAMPLES = i.blurSamples),
          (p.defines.VSM_SAMPLES = i.blurSamples),
          (d.needsUpdate = !0),
          (p.needsUpdate = !0)),
          null === i.mapPass && (i.mapPass = new Te(s.x, s.y)),
          (d.uniforms.shadow_pass.value = i.map.texture),
          (d.uniforms.resolution.value = i.mapSize),
          (d.uniforms.radius.value = i.radius),
          e.setRenderTarget(i.mapPass),
          e.clear(),
          e.renderBufferDirect(n, null, r, d, g, null),
          (p.uniforms.shadow_pass.value = i.mapPass.texture),
          (p.uniforms.resolution.value = i.mapSize),
          (p.uniforms.radius.value = i.radius),
          e.setRenderTarget(i.map),
          e.clear(),
          e.renderBufferDirect(n, null, r, p, g, null);
      }
      function x(t, i, n, s, r, a) {
        let c = null;
        const d = !0 === n.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
        if (
          ((c = void 0 !== d ? d : !0 === n.isPointLight ? l : o),
          (e.localClippingEnabled &&
            !0 === i.clipShadows &&
            Array.isArray(i.clippingPlanes) &&
            0 !== i.clippingPlanes.length) ||
            (i.displacementMap && 0 !== i.displacementScale) ||
            (i.alphaMap && i.alphaTest > 0))
        ) {
          const e = c.uuid,
            t = i.uuid;
          let n = h[e];
          void 0 === n && ((n = {}), (h[e] = n));
          let s = n[t];
          void 0 === s && ((s = c.clone()), (n[t] = s)), (c = s);
        }
        return (
          (c.visible = i.visible),
          (c.wireframe = i.wireframe),
          (c.side =
            3 === a
              ? null !== i.shadowSide
                ? i.shadowSide
                : i.side
              : null !== i.shadowSide
              ? i.shadowSide
              : u[i.side]),
          (c.alphaMap = i.alphaMap),
          (c.alphaTest = i.alphaTest),
          (c.clipShadows = i.clipShadows),
          (c.clippingPlanes = i.clippingPlanes),
          (c.clipIntersection = i.clipIntersection),
          (c.displacementMap = i.displacementMap),
          (c.displacementScale = i.displacementScale),
          (c.displacementBias = i.displacementBias),
          (c.wireframeLinewidth = i.wireframeLinewidth),
          (c.linewidth = i.linewidth),
          !0 === n.isPointLight &&
            !0 === c.isMeshDistanceMaterial &&
            (c.referencePosition.setFromMatrixPosition(n.matrixWorld), (c.nearDistance = s), (c.farDistance = r)),
          c
        );
      }
      function y(i, s, r, a, o) {
        if (!1 === i.visible) return;
        if (
          i.layers.test(s.layers) &&
          (i.isMesh || i.isLine || i.isPoints) &&
          (i.castShadow || (i.receiveShadow && 3 === o)) &&
          (!i.frustumCulled || n.intersectsObject(i))
        ) {
          i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld);
          const n = t.update(i),
            s = i.material;
          if (Array.isArray(s)) {
            const t = n.groups;
            for (let l = 0, h = t.length; l < h; l++) {
              const h = t[l],
                c = s[h.materialIndex];
              if (c && c.visible) {
                const t = x(i, c, a, r.near, r.far, o);
                e.renderBufferDirect(r, null, n, t, i, h);
              }
            }
          } else if (s.visible) {
            const t = x(i, s, a, r.near, r.far, o);
            e.renderBufferDirect(r, null, n, t, i, null);
          }
        }
        const l = i.children;
        for (let e = 0, t = l.length; e < t; e++) y(l[e], s, r, a, o);
      }
      (this.enabled = !1),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this.type = 1),
        (this.render = function (t, i, o) {
          if (!1 === _.enabled) return;
          if (!1 === _.autoUpdate && !1 === _.needsUpdate) return;
          if (0 === t.length) return;
          const l = e.getRenderTarget(),
            h = e.getActiveCubeFace(),
            u = e.getActiveMipmapLevel(),
            d = e.state;
          d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
          for (let l = 0, h = t.length; l < h; l++) {
            const h = t[l],
              u = h.shadow;
            if (void 0 === u) continue;
            if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
            s.copy(u.mapSize);
            const p = u.getFrameExtents();
            if (
              (s.multiply(p),
              r.copy(u.mapSize),
              (s.x > c || s.y > c) &&
                (s.x > c && ((r.x = Math.floor(c / p.x)), (s.x = r.x * p.x), (u.mapSize.x = r.x)),
                s.y > c && ((r.y = Math.floor(c / p.y)), (s.y = r.y * p.y), (u.mapSize.y = r.y))),
              null === u.map)
            ) {
              const e = 3 !== this.type ? { minFilter: m, magFilter: m } : {};
              (u.map = new Te(s.x, s.y, e)),
                (u.map.texture.name = h.name + '.shadowMap'),
                u.camera.updateProjectionMatrix();
            }
            e.setRenderTarget(u.map), e.clear();
            const f = u.getViewportCount();
            for (let e = 0; e < f; e++) {
              const t = u.getViewport(e);
              a.set(r.x * t.x, r.y * t.y, r.x * t.z, r.y * t.w),
                d.viewport(a),
                u.updateMatrices(h, e),
                (n = u.getFrustum()),
                y(i, o, u.camera, h, this.type);
            }
            !0 !== u.isPointLightShadow && 3 === this.type && v(u, o), (u.needsUpdate = !1);
          }
          (_.needsUpdate = !1), e.setRenderTarget(l, h, u);
        });
    }
    function pr(e, t, i) {
      const n = i.isWebGL2;
      const r = new (function () {
          let t = !1;
          const i = new Ae();
          let n = null;
          const s = new Ae(0, 0, 0, 0);
          return {
            setMask: function (i) {
              n === i || t || (e.colorMask(i, i, i, i), (n = i));
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t, n, r, a, o) {
              !0 === o && ((t *= a), (n *= a), (r *= a)),
                i.set(t, n, r, a),
                !1 === s.equals(i) && (e.clearColor(t, n, r, a), s.copy(i));
            },
            reset: function () {
              (t = !1), (n = null), s.set(-1, 0, 0, 0);
            },
          };
        })(),
        a = new (function () {
          let t = !1,
            i = null,
            n = null,
            s = null;
          return {
            setTest: function (e) {
              e ? U(2929) : B(2929);
            },
            setMask: function (n) {
              i === n || t || (e.depthMask(n), (i = n));
            },
            setFunc: function (t) {
              if (n !== t) {
                if (t)
                  switch (t) {
                    case 0:
                      e.depthFunc(512);
                      break;
                    case 1:
                      e.depthFunc(519);
                      break;
                    case 2:
                      e.depthFunc(513);
                      break;
                    case 3:
                    default:
                      e.depthFunc(515);
                      break;
                    case 4:
                      e.depthFunc(514);
                      break;
                    case 5:
                      e.depthFunc(518);
                      break;
                    case 6:
                      e.depthFunc(516);
                      break;
                    case 7:
                      e.depthFunc(517);
                  }
                else e.depthFunc(515);
                n = t;
              }
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t) {
              s !== t && (e.clearDepth(t), (s = t));
            },
            reset: function () {
              (t = !1), (i = null), (n = null), (s = null);
            },
          };
        })(),
        o = new (function () {
          let t = !1,
            i = null,
            n = null,
            s = null,
            r = null,
            a = null,
            o = null,
            l = null,
            h = null;
          return {
            setTest: function (e) {
              t || (e ? U(2960) : B(2960));
            },
            setMask: function (n) {
              i === n || t || (e.stencilMask(n), (i = n));
            },
            setFunc: function (t, i, a) {
              (n === t && s === i && r === a) || (e.stencilFunc(t, i, a), (n = t), (s = i), (r = a));
            },
            setOp: function (t, i, n) {
              (a === t && o === i && l === n) || (e.stencilOp(t, i, n), (a = t), (o = i), (l = n));
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t) {
              h !== t && (e.clearStencil(t), (h = t));
            },
            reset: function () {
              (t = !1), (i = null), (n = null), (s = null), (r = null), (a = null), (o = null), (l = null), (h = null);
            },
          };
        })();
      let l = {},
        h = {},
        c = new WeakMap(),
        u = [],
        d = null,
        m = !1,
        p = null,
        f = null,
        g = null,
        _ = null,
        v = null,
        x = null,
        y = null,
        M = !1,
        b = null,
        S = null,
        w = null,
        A = null,
        T = null;
      const E = e.getParameter(35661);
      let L = !1,
        C = 0;
      const P = e.getParameter(7938);
      -1 !== P.indexOf('WebGL')
        ? ((C = parseFloat(/^WebGL (\d)/.exec(P)[1])), (L = C >= 1))
        : -1 !== P.indexOf('OpenGL ES') && ((C = parseFloat(/^OpenGL ES (\d)/.exec(P)[1])), (L = C >= 2));
      let D = null,
        I = {};
      const R = e.getParameter(3088),
        O = e.getParameter(2978),
        N = new Ae().fromArray(R),
        z = new Ae().fromArray(O);
      function F(t, i, n) {
        const s = new Uint8Array(4),
          r = e.createTexture();
        e.bindTexture(t, r), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
        for (let t = 0; t < n; t++) e.texImage2D(i + t, 0, 6408, 1, 1, 0, 6408, 5121, s);
        return r;
      }
      const k = {};
      function U(t) {
        !0 !== l[t] && (e.enable(t), (l[t] = !0));
      }
      function B(t) {
        !1 !== l[t] && (e.disable(t), (l[t] = !1));
      }
      (k[3553] = F(3553, 3553, 1)),
        (k[34067] = F(34067, 34069, 6)),
        r.setClear(0, 0, 0, 1),
        a.setClear(1),
        o.setClear(0),
        U(2929),
        a.setFunc(3),
        j(!1),
        W(1),
        U(2884),
        H(0);
      const G = { [s]: 32774, 101: 32778, 102: 32779 };
      if (n) (G[103] = 32775), (G[104] = 32776);
      else {
        const e = t.get('EXT_blend_minmax');
        null !== e && ((G[103] = e.MIN_EXT), (G[104] = e.MAX_EXT));
      }
      const V = {
        200: 0,
        201: 1,
        202: 768,
        204: 770,
        210: 776,
        208: 774,
        206: 772,
        203: 769,
        205: 771,
        209: 775,
        207: 773,
      };
      function H(t, i, n, r, a, o, l, h) {
        if (0 !== t) {
          if ((!1 === m && (U(3042), (m = !0)), 5 === t))
            (a = a || i),
              (o = o || n),
              (l = l || r),
              (i === f && a === v) || (e.blendEquationSeparate(G[i], G[a]), (f = i), (v = a)),
              (n === g && r === _ && o === x && l === y) ||
                (e.blendFuncSeparate(V[n], V[r], V[o], V[l]), (g = n), (_ = r), (x = o), (y = l)),
              (p = t),
              (M = null);
          else if (t !== p || h !== M) {
            if (((f === s && v === s) || (e.blendEquation(32774), (f = s), (v = s)), h))
              switch (t) {
                case 1:
                  e.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case 2:
                  e.blendFunc(1, 1);
                  break;
                case 3:
                  e.blendFuncSeparate(0, 769, 0, 1);
                  break;
                case 4:
                  e.blendFuncSeparate(0, 768, 0, 770);
              }
            else
              switch (t) {
                case 1:
                  e.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case 2:
                  e.blendFunc(770, 1);
                  break;
                case 3:
                  e.blendFuncSeparate(0, 769, 0, 1);
                  break;
                case 4:
                  e.blendFunc(0, 768);
              }
            (g = null), (_ = null), (x = null), (y = null), (p = t), (M = h);
          }
        } else !0 === m && (B(3042), (m = !1));
      }
      function j(t) {
        b !== t && (t ? e.frontFace(2304) : e.frontFace(2305), (b = t));
      }
      function W(t) {
        0 !== t
          ? (U(2884), t !== S && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032)))
          : B(2884),
          (S = t);
      }
      function X(t, i, n) {
        t ? (U(32823), (A === i && T === n) || (e.polygonOffset(i, n), (A = i), (T = n))) : B(32823);
      }
      function q(t) {
        void 0 === t && (t = 33984 + E - 1), D !== t && (e.activeTexture(t), (D = t));
      }
      return {
        buffers: { color: r, depth: a, stencil: o },
        enable: U,
        disable: B,
        bindFramebuffer: function (t, i) {
          return (
            h[t] !== i &&
            (e.bindFramebuffer(t, i),
            (h[t] = i),
            n && (36009 === t && (h[36160] = i), 36160 === t && (h[36009] = i)),
            !0)
          );
        },
        drawBuffers: function (n, s) {
          let r = u,
            a = !1;
          if (n)
            if (((r = c.get(s)), void 0 === r && ((r = []), c.set(s, r)), n.isWebGLMultipleRenderTargets)) {
              const e = n.texture;
              if (r.length !== e.length || 36064 !== r[0]) {
                for (let t = 0, i = e.length; t < i; t++) r[t] = 36064 + t;
                (r.length = e.length), (a = !0);
              }
            } else 36064 !== r[0] && ((r[0] = 36064), (a = !0));
          else 1029 !== r[0] && ((r[0] = 1029), (a = !0));
          a && (i.isWebGL2 ? e.drawBuffers(r) : t.get('WEBGL_draw_buffers').drawBuffersWEBGL(r));
        },
        useProgram: function (t) {
          return d !== t && (e.useProgram(t), (d = t), !0);
        },
        setBlending: H,
        setMaterial: function (e, t) {
          2 === e.side ? B(2884) : U(2884);
          let i = 1 === e.side;
          t && (i = !i),
            j(i),
            1 === e.blending && !1 === e.transparent
              ? H(0)
              : H(
                  e.blending,
                  e.blendEquation,
                  e.blendSrc,
                  e.blendDst,
                  e.blendEquationAlpha,
                  e.blendSrcAlpha,
                  e.blendDstAlpha,
                  e.premultipliedAlpha,
                ),
            a.setFunc(e.depthFunc),
            a.setTest(e.depthTest),
            a.setMask(e.depthWrite),
            r.setMask(e.colorWrite);
          const n = e.stencilWrite;
          o.setTest(n),
            n &&
              (o.setMask(e.stencilWriteMask),
              o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
              o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
            X(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
            !0 === e.alphaToCoverage ? U(32926) : B(32926);
        },
        setFlipSided: j,
        setCullFace: W,
        setLineWidth: function (t) {
          t !== w && (L && e.lineWidth(t), (w = t));
        },
        setPolygonOffset: X,
        setScissorTest: function (e) {
          e ? U(3089) : B(3089);
        },
        activeTexture: q,
        bindTexture: function (t, i) {
          null === D && q();
          let n = I[D];
          void 0 === n && ((n = { type: void 0, texture: void 0 }), (I[D] = n)),
            (n.type === t && n.texture === i) || (e.bindTexture(t, i || k[t]), (n.type = t), (n.texture = i));
        },
        unbindTexture: function () {
          const t = I[D];
          void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), (t.type = void 0), (t.texture = void 0));
        },
        compressedTexImage2D: function () {
          try {
            e.compressedTexImage2D.apply(e, arguments);
          } catch (e) {}
        },
        texImage2D: function () {
          try {
            e.texImage2D.apply(e, arguments);
          } catch (e) {}
        },
        texImage3D: function () {
          try {
            e.texImage3D.apply(e, arguments);
          } catch (e) {}
        },
        texStorage2D: function () {
          try {
            e.texStorage2D.apply(e, arguments);
          } catch (e) {}
        },
        texStorage3D: function () {
          try {
            e.texStorage3D.apply(e, arguments);
          } catch (e) {}
        },
        texSubImage2D: function () {
          try {
            e.texSubImage2D.apply(e, arguments);
          } catch (e) {}
        },
        texSubImage3D: function () {
          try {
            e.texSubImage3D.apply(e, arguments);
          } catch (e) {}
        },
        compressedTexSubImage2D: function () {
          try {
            e.compressedTexSubImage2D.apply(e, arguments);
          } catch (e) {}
        },
        scissor: function (t) {
          !1 === N.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), N.copy(t));
        },
        viewport: function (t) {
          !1 === z.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), z.copy(t));
        },
        reset: function () {
          e.disable(3042),
            e.disable(2884),
            e.disable(2929),
            e.disable(32823),
            e.disable(3089),
            e.disable(2960),
            e.disable(32926),
            e.blendEquation(32774),
            e.blendFunc(1, 0),
            e.blendFuncSeparate(1, 0, 1, 0),
            e.colorMask(!0, !0, !0, !0),
            e.clearColor(0, 0, 0, 0),
            e.depthMask(!0),
            e.depthFunc(513),
            e.clearDepth(1),
            e.stencilMask(4294967295),
            e.stencilFunc(519, 0, 4294967295),
            e.stencilOp(7680, 7680, 7680),
            e.clearStencil(0),
            e.cullFace(1029),
            e.frontFace(2305),
            e.polygonOffset(0, 0),
            e.activeTexture(33984),
            e.bindFramebuffer(36160, null),
            !0 === n && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)),
            e.useProgram(null),
            e.lineWidth(1),
            e.scissor(0, 0, e.canvas.width, e.canvas.height),
            e.viewport(0, 0, e.canvas.width, e.canvas.height),
            (l = {}),
            (D = null),
            (I = {}),
            (h = {}),
            (c = new WeakMap()),
            (u = []),
            (d = null),
            (m = !1),
            (p = null),
            (f = null),
            (g = null),
            (_ = null),
            (v = null),
            (x = null),
            (y = null),
            (M = !1),
            (b = null),
            (S = null),
            (w = null),
            (A = null),
            (T = null),
            N.set(0, 0, e.canvas.width, e.canvas.height),
            z.set(0, 0, e.canvas.width, e.canvas.height),
            r.reset(),
            a.reset(),
            o.reset();
        },
      };
    }
    function fr(e, t, i, n, s, r, a) {
      const o = s.isWebGL2,
        l = (s.maxTextures, s.maxCubemapSize),
        h = s.maxTextureSize,
        x = s.maxSamples,
        E = t.has('WEBGL_multisampled_render_to_texture') ? t.get('WEBGL_multisampled_render_to_texture') : null,
        L = /OculusBrowser/g.test(navigator.userAgent),
        C = new WeakMap();
      let P;
      const D = new WeakMap();
      let I = !1;
      try {
        I = 'undefined' != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext('2d');
      } catch (e) {}
      function R(e, t) {
        return I ? new OffscreenCanvas(e, t) : oe('canvas');
      }
      function O(e, t, i, n) {
        let s = 1;
        if (((e.width > n || e.height > n) && (s = n / Math.max(e.width, e.height)), s < 1 || !0 === t)) {
          if (
            ('undefined' != typeof HTMLImageElement && e instanceof HTMLImageElement) ||
            ('undefined' != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement) ||
            ('undefined' != typeof ImageBitmap && e instanceof ImageBitmap)
          ) {
            const n = t ? ie : Math.floor,
              r = n(s * e.width),
              a = n(s * e.height);
            void 0 === P && (P = R(r, a));
            const o = i ? R(r, a) : P;
            (o.width = r), (o.height = a);
            return o.getContext('2d').drawImage(e, 0, 0, r, a), o;
          }
          return e;
        }
        return e;
      }
      function N(e) {
        return ee(e.width) && ee(e.height);
      }
      function z(e, t) {
        return e.generateMipmaps && t && e.minFilter !== m && e.minFilter !== g;
      }
      function U(t) {
        e.generateMipmap(t);
      }
      function B(i, n, s, r, a = !1) {
        if (!1 === o) return n;
        if (null !== i && void 0 !== e[i]) return e[i];
        let l = n;
        return (
          6403 === n && (5126 === s && (l = 33326), 5131 === s && (l = 33325), 5121 === s && (l = 33321)),
          33319 === n && (5126 === s && (l = 33328), 5131 === s && (l = 33327), 5121 === s && (l = 33323)),
          6408 === n &&
            (5126 === s && (l = 34836),
            5131 === s && (l = 34842),
            5121 === s && (l = r === k && !1 === a ? 35907 : 32856),
            32819 === s && (l = 32854),
            32820 === s && (l = 32855)),
          (33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l) ||
            t.get('EXT_color_buffer_float'),
          l
        );
      }
      function G(e, t, i) {
        return !0 === z(e, i) || (e.isFramebufferTexture && e.minFilter !== m && e.minFilter !== g)
          ? Math.log2(Math.max(t.width, t.height)) + 1
          : void 0 !== e.mipmaps && e.mipmaps.length > 0
          ? e.mipmaps.length
          : e.isCompressedTexture && Array.isArray(e.image)
          ? t.mipmaps.length
          : 1;
      }
      function V(e) {
        return e === m || e === p || e === f ? 9728 : 9729;
      }
      function H(e) {
        const t = e.target;
        t.removeEventListener('dispose', H),
          (function (e) {
            const t = n.get(e);
            if (void 0 === t.__webglInit) return;
            const i = e.source,
              s = D.get(i);
            if (s) {
              const n = s[t.__cacheKey];
              n.usedTimes--, 0 === n.usedTimes && X(e), 0 === Object.keys(s).length && D.delete(i);
            }
            n.remove(e);
          })(t),
          t.isVideoTexture && C.delete(t);
      }
      function W(t) {
        const i = t.target;
        i.removeEventListener('dispose', W),
          (function (t) {
            const i = t.texture,
              s = n.get(t),
              r = n.get(i);
            void 0 !== r.__webglTexture && (e.deleteTexture(r.__webglTexture), a.memory.textures--);
            t.depthTexture && t.depthTexture.dispose();
            if (t.isWebGLCubeRenderTarget)
              for (let t = 0; t < 6; t++)
                e.deleteFramebuffer(s.__webglFramebuffer[t]),
                  s.__webglDepthbuffer && e.deleteRenderbuffer(s.__webglDepthbuffer[t]);
            else {
              if (
                (e.deleteFramebuffer(s.__webglFramebuffer),
                s.__webglDepthbuffer && e.deleteRenderbuffer(s.__webglDepthbuffer),
                s.__webglMultisampledFramebuffer && e.deleteFramebuffer(s.__webglMultisampledFramebuffer),
                s.__webglColorRenderbuffer)
              )
                for (let t = 0; t < s.__webglColorRenderbuffer.length; t++)
                  s.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(s.__webglColorRenderbuffer[t]);
              s.__webglDepthRenderbuffer && e.deleteRenderbuffer(s.__webglDepthRenderbuffer);
            }
            if (t.isWebGLMultipleRenderTargets)
              for (let t = 0, s = i.length; t < s; t++) {
                const s = n.get(i[t]);
                s.__webglTexture && (e.deleteTexture(s.__webglTexture), a.memory.textures--), n.remove(i[t]);
              }
            n.remove(i), n.remove(t);
          })(i);
      }
      function X(t) {
        const i = n.get(t);
        e.deleteTexture(i.__webglTexture);
        const s = t.source;
        delete D.get(s)[i.__cacheKey], a.memory.textures--;
      }
      let q = 0;
      function Y(e, t) {
        const s = n.get(e);
        if (
          (e.isVideoTexture &&
            (function (e) {
              const t = a.render.frame;
              C.get(e) !== t && (C.set(e, t), e.update());
            })(e),
          !1 === e.isRenderTargetTexture && e.version > 0 && s.__version !== e.version)
        ) {
          const i = e.image;
          if (null === i);
          else if (!1 !== i.complete) return void Q(s, e, t);
        }
        i.activeTexture(33984 + t), i.bindTexture(3553, s.__webglTexture);
      }
      const Z = { [c]: 10497, [u]: 33071, [d]: 33648 },
        J = { [m]: 9728, [p]: 9984, [f]: 9986, [g]: 9729, [_]: 9985, [v]: 9987 };
      function K(i, r, a) {
        if (
          (a
            ? (e.texParameteri(i, 10242, Z[r.wrapS]),
              e.texParameteri(i, 10243, Z[r.wrapT]),
              (32879 !== i && 35866 !== i) || e.texParameteri(i, 32882, Z[r.wrapR]),
              e.texParameteri(i, 10240, J[r.magFilter]),
              e.texParameteri(i, 10241, J[r.minFilter]))
            : (e.texParameteri(i, 10242, 33071),
              e.texParameteri(i, 10243, 33071),
              (32879 !== i && 35866 !== i) || e.texParameteri(i, 32882, 33071),
              r.wrapS !== u || r.wrapT,
              e.texParameteri(i, 10240, V(r.magFilter)),
              e.texParameteri(i, 10241, V(r.minFilter)),
              r.minFilter !== m && r.minFilter),
          !0 === t.has('EXT_texture_filter_anisotropic'))
        ) {
          const a = t.get('EXT_texture_filter_anisotropic');
          if (r.type === M && !1 === t.has('OES_texture_float_linear')) return;
          if (!1 === o && r.type === b && !1 === t.has('OES_texture_half_float_linear')) return;
          (r.anisotropy > 1 || n.get(r).__currentAnisotropy) &&
            (e.texParameterf(i, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(r.anisotropy, s.getMaxAnisotropy())),
            (n.get(r).__currentAnisotropy = r.anisotropy));
        }
      }
      function $(t, i) {
        let n = !1;
        void 0 === t.__webglInit && ((t.__webglInit = !0), i.addEventListener('dispose', H));
        const s = i.source;
        let r = D.get(s);
        void 0 === r && ((r = {}), D.set(s, r));
        const o = (function (e) {
          const t = [];
          return (
            t.push(e.wrapS),
            t.push(e.wrapT),
            t.push(e.magFilter),
            t.push(e.minFilter),
            t.push(e.anisotropy),
            t.push(e.internalFormat),
            t.push(e.format),
            t.push(e.type),
            t.push(e.generateMipmaps),
            t.push(e.premultiplyAlpha),
            t.push(e.flipY),
            t.push(e.unpackAlignment),
            t.push(e.encoding),
            t.join()
          );
        })(i);
        if (o !== t.__cacheKey) {
          void 0 === r[o] && ((r[o] = { texture: e.createTexture(), usedTimes: 0 }), a.memory.textures++, (n = !0)),
            r[o].usedTimes++;
          const s = r[t.__cacheKey];
          void 0 !== s && (r[t.__cacheKey].usedTimes--, 0 === s.usedTimes && X(i)),
            (t.__cacheKey = o),
            (t.__webglTexture = r[o].texture);
        }
        return n;
      }
      function Q(t, n, s) {
        let a = 3553;
        n.isDataArrayTexture && (a = 35866), n.isData3DTexture && (a = 32879);
        const l = $(t, n),
          c = n.source;
        if (
          (i.activeTexture(33984 + s), i.bindTexture(a, t.__webglTexture), c.version !== c.__currentVersion || !0 === l)
        ) {
          e.pixelStorei(37440, n.flipY),
            e.pixelStorei(37441, n.premultiplyAlpha),
            e.pixelStorei(3317, n.unpackAlignment),
            e.pixelStorei(37443, 0);
          const t =
            (function (e) {
              return !o && (e.wrapS !== u || e.wrapT !== u || (e.minFilter !== m && e.minFilter !== g));
            })(n) && !1 === N(n.image);
          let s = O(n.image, t, !1, h);
          s = le(n, s);
          const d = N(s) || o,
            p = r.convert(n.format, n.encoding);
          let f,
            _ = r.convert(n.type),
            v = B(n.internalFormat, p, _, n.encoding, n.isVideoTexture);
          K(a, n, d);
          const x = n.mipmaps,
            b = o && !0 !== n.isVideoTexture,
            E = void 0 === c.__currentVersion || !0 === l,
            L = G(n, s, d);
          if (n.isDepthTexture)
            (v = 6402),
              o ? (v = n.type === M ? 36012 : n.type === y ? 33190 : n.type === S ? 35056 : 33189) : n.type,
              n.format === A &&
                6402 === v &&
                1012 !== n.type &&
                n.type !== y &&
                ((n.type = y), (_ = r.convert(n.type))),
              n.format === T && 6402 === v && ((v = 34041), n.type !== S && ((n.type = S), (_ = r.convert(n.type)))),
              E &&
                (b
                  ? i.texStorage2D(3553, 1, v, s.width, s.height)
                  : i.texImage2D(3553, 0, v, s.width, s.height, 0, p, _, null));
          else if (n.isDataTexture)
            if (x.length > 0 && d) {
              b && E && i.texStorage2D(3553, L, v, x[0].width, x[0].height);
              for (let e = 0, t = x.length; e < t; e++)
                (f = x[e]),
                  b
                    ? i.texSubImage2D(3553, e, 0, 0, f.width, f.height, p, _, f.data)
                    : i.texImage2D(3553, e, v, f.width, f.height, 0, p, _, f.data);
              n.generateMipmaps = !1;
            } else
              b
                ? (E && i.texStorage2D(3553, L, v, s.width, s.height),
                  i.texSubImage2D(3553, 0, 0, 0, s.width, s.height, p, _, s.data))
                : i.texImage2D(3553, 0, v, s.width, s.height, 0, p, _, s.data);
          else if (n.isCompressedTexture) {
            b && E && i.texStorage2D(3553, L, v, x[0].width, x[0].height);
            for (let e = 0, t = x.length; e < t; e++)
              (f = x[e]),
                n.format !== w
                  ? null !== p &&
                    (b
                      ? i.compressedTexSubImage2D(3553, e, 0, 0, f.width, f.height, p, f.data)
                      : i.compressedTexImage2D(3553, e, v, f.width, f.height, 0, f.data))
                  : b
                  ? i.texSubImage2D(3553, e, 0, 0, f.width, f.height, p, _, f.data)
                  : i.texImage2D(3553, e, v, f.width, f.height, 0, p, _, f.data);
          } else if (n.isDataArrayTexture)
            b
              ? (E && i.texStorage3D(35866, L, v, s.width, s.height, s.depth),
                i.texSubImage3D(35866, 0, 0, 0, 0, s.width, s.height, s.depth, p, _, s.data))
              : i.texImage3D(35866, 0, v, s.width, s.height, s.depth, 0, p, _, s.data);
          else if (n.isData3DTexture)
            b
              ? (E && i.texStorage3D(32879, L, v, s.width, s.height, s.depth),
                i.texSubImage3D(32879, 0, 0, 0, 0, s.width, s.height, s.depth, p, _, s.data))
              : i.texImage3D(32879, 0, v, s.width, s.height, s.depth, 0, p, _, s.data);
          else if (n.isFramebufferTexture) {
            if (E)
              if (b) i.texStorage2D(3553, L, v, s.width, s.height);
              else {
                let e = s.width,
                  t = s.height;
                for (let n = 0; n < L; n++) i.texImage2D(3553, n, v, e, t, 0, p, _, null), (e >>= 1), (t >>= 1);
              }
          } else if (x.length > 0 && d) {
            b && E && i.texStorage2D(3553, L, v, x[0].width, x[0].height);
            for (let e = 0, t = x.length; e < t; e++)
              (f = x[e]), b ? i.texSubImage2D(3553, e, 0, 0, p, _, f) : i.texImage2D(3553, e, v, p, _, f);
            n.generateMipmaps = !1;
          } else
            b
              ? (E && i.texStorage2D(3553, L, v, s.width, s.height), i.texSubImage2D(3553, 0, 0, 0, p, _, s))
              : i.texImage2D(3553, 0, v, p, _, s);
          z(n, d) && U(a), (c.__currentVersion = c.version), n.onUpdate && n.onUpdate(n);
        }
        t.__version = n.version;
      }
      function te(t, s, a, o, l) {
        const h = r.convert(a.format, a.encoding),
          c = r.convert(a.type),
          u = B(a.internalFormat, h, c, a.encoding);
        n.get(s).__hasExternalTextures ||
          (32879 === l || 35866 === l
            ? i.texImage3D(l, 0, u, s.width, s.height, s.depth, 0, h, c, null)
            : i.texImage2D(l, 0, u, s.width, s.height, 0, h, c, null)),
          i.bindFramebuffer(36160, t),
          ae(s)
            ? E.framebufferTexture2DMultisampleEXT(36160, o, l, n.get(a).__webglTexture, 0, re(s))
            : e.framebufferTexture2D(36160, o, l, n.get(a).__webglTexture, 0),
          i.bindFramebuffer(36160, null);
      }
      function ne(t, i, n) {
        if ((e.bindRenderbuffer(36161, t), i.depthBuffer && !i.stencilBuffer)) {
          let s = 33189;
          if (n || ae(i)) {
            const t = i.depthTexture;
            t && t.isDepthTexture && (t.type === M ? (s = 36012) : t.type === y && (s = 33190));
            const n = re(i);
            ae(i)
              ? E.renderbufferStorageMultisampleEXT(36161, n, s, i.width, i.height)
              : e.renderbufferStorageMultisample(36161, n, s, i.width, i.height);
          } else e.renderbufferStorage(36161, s, i.width, i.height);
          e.framebufferRenderbuffer(36160, 36096, 36161, t);
        } else if (i.depthBuffer && i.stencilBuffer) {
          const s = re(i);
          n && !1 === ae(i)
            ? e.renderbufferStorageMultisample(36161, s, 35056, i.width, i.height)
            : ae(i)
            ? E.renderbufferStorageMultisampleEXT(36161, s, 35056, i.width, i.height)
            : e.renderbufferStorage(36161, 34041, i.width, i.height),
            e.framebufferRenderbuffer(36160, 33306, 36161, t);
        } else {
          const t = !0 === i.isWebGLMultipleRenderTargets ? i.texture : [i.texture];
          for (let s = 0; s < t.length; s++) {
            const a = t[s],
              o = r.convert(a.format, a.encoding),
              l = r.convert(a.type),
              h = B(a.internalFormat, o, l, a.encoding),
              c = re(i);
            n && !1 === ae(i)
              ? e.renderbufferStorageMultisample(36161, c, h, i.width, i.height)
              : ae(i)
              ? E.renderbufferStorageMultisampleEXT(36161, c, h, i.width, i.height)
              : e.renderbufferStorage(36161, h, i.width, i.height);
          }
        }
        e.bindRenderbuffer(36161, null);
      }
      function se(t) {
        const s = n.get(t),
          r = !0 === t.isWebGLCubeRenderTarget;
        if (t.depthTexture && !s.__autoAllocateDepthBuffer) {
          if (r) throw new Error('target.depthTexture not supported in Cube render targets');
          !(function (t, s) {
            if (s && s.isWebGLCubeRenderTarget)
              throw new Error('Depth Texture with cube render targets is not supported');
            if ((i.bindFramebuffer(36160, t), !s.depthTexture || !s.depthTexture.isDepthTexture))
              throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
            (n.get(s.depthTexture).__webglTexture &&
              s.depthTexture.image.width === s.width &&
              s.depthTexture.image.height === s.height) ||
              ((s.depthTexture.image.width = s.width),
              (s.depthTexture.image.height = s.height),
              (s.depthTexture.needsUpdate = !0)),
              Y(s.depthTexture, 0);
            const r = n.get(s.depthTexture).__webglTexture,
              a = re(s);
            if (s.depthTexture.format === A)
              ae(s)
                ? E.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, r, 0, a)
                : e.framebufferTexture2D(36160, 36096, 3553, r, 0);
            else {
              if (s.depthTexture.format !== T) throw new Error('Unknown depthTexture format');
              ae(s)
                ? E.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, r, 0, a)
                : e.framebufferTexture2D(36160, 33306, 3553, r, 0);
            }
          })(s.__webglFramebuffer, t);
        } else if (r) {
          s.__webglDepthbuffer = [];
          for (let n = 0; n < 6; n++)
            i.bindFramebuffer(36160, s.__webglFramebuffer[n]),
              (s.__webglDepthbuffer[n] = e.createRenderbuffer()),
              ne(s.__webglDepthbuffer[n], t, !1);
        } else
          i.bindFramebuffer(36160, s.__webglFramebuffer),
            (s.__webglDepthbuffer = e.createRenderbuffer()),
            ne(s.__webglDepthbuffer, t, !1);
        i.bindFramebuffer(36160, null);
      }
      function re(e) {
        return Math.min(x, e.samples);
      }
      function ae(e) {
        const i = n.get(e);
        return (
          o && e.samples > 0 && !0 === t.has('WEBGL_multisampled_render_to_texture') && !1 !== i.__useRenderToTexture
        );
      }
      function le(e, i) {
        const n = e.encoding,
          s = e.format;
        e.type;
        return (
          !0 === e.isCompressedTexture ||
            !0 === e.isVideoTexture ||
            e.format === j ||
            (n !== F &&
              n === k &&
              !1 === o &&
              (!0 === t.has('EXT_sRGB') && s === w
                ? ((e.format = j), (e.minFilter = g), (e.generateMipmaps = !1))
                : (i = ye.sRGBToLinear(i)))),
          i
        );
      }
      (this.allocateTextureUnit = function () {
        const e = q;
        return (q += 1), e;
      }),
        (this.resetTextureUnits = function () {
          q = 0;
        }),
        (this.setTexture2D = Y),
        (this.setTexture2DArray = function (e, t) {
          const s = n.get(e);
          e.version > 0 && s.__version !== e.version
            ? Q(s, e, t)
            : (i.activeTexture(33984 + t), i.bindTexture(35866, s.__webglTexture));
        }),
        (this.setTexture3D = function (e, t) {
          const s = n.get(e);
          e.version > 0 && s.__version !== e.version
            ? Q(s, e, t)
            : (i.activeTexture(33984 + t), i.bindTexture(32879, s.__webglTexture));
        }),
        (this.setTextureCube = function (t, s) {
          const a = n.get(t);
          t.version > 0 && a.__version !== t.version
            ? (function (t, n, s) {
                if (6 !== n.image.length) return;
                const a = $(t, n),
                  h = n.source;
                if (
                  (i.activeTexture(33984 + s),
                  i.bindTexture(34067, t.__webglTexture),
                  h.version !== h.__currentVersion || !0 === a)
                ) {
                  e.pixelStorei(37440, n.flipY),
                    e.pixelStorei(37441, n.premultiplyAlpha),
                    e.pixelStorei(3317, n.unpackAlignment),
                    e.pixelStorei(37443, 0);
                  const t = n.isCompressedTexture || n.image[0].isCompressedTexture,
                    s = n.image[0] && n.image[0].isDataTexture,
                    c = [];
                  for (let e = 0; e < 6; e++)
                    (c[e] = t || s ? (s ? n.image[e].image : n.image[e]) : O(n.image[e], !1, !0, l)),
                      (c[e] = le(n, c[e]));
                  const u = c[0],
                    d = N(u) || o,
                    m = r.convert(n.format, n.encoding),
                    p = r.convert(n.type),
                    f = B(n.internalFormat, m, p, n.encoding),
                    g = o && !0 !== n.isVideoTexture,
                    _ = void 0 === h.__currentVersion || !0 === a;
                  let v,
                    x = G(n, u, d);
                  if ((K(34067, n, d), t)) {
                    g && _ && i.texStorage2D(34067, x, f, u.width, u.height);
                    for (let e = 0; e < 6; e++) {
                      v = c[e].mipmaps;
                      for (let t = 0; t < v.length; t++) {
                        const s = v[t];
                        n.format !== w
                          ? null !== m &&
                            (g
                              ? i.compressedTexSubImage2D(34069 + e, t, 0, 0, s.width, s.height, m, s.data)
                              : i.compressedTexImage2D(34069 + e, t, f, s.width, s.height, 0, s.data))
                          : g
                          ? i.texSubImage2D(34069 + e, t, 0, 0, s.width, s.height, m, p, s.data)
                          : i.texImage2D(34069 + e, t, f, s.width, s.height, 0, m, p, s.data);
                      }
                    }
                  } else {
                    (v = n.mipmaps),
                      g && _ && (v.length > 0 && x++, i.texStorage2D(34067, x, f, c[0].width, c[0].height));
                    for (let e = 0; e < 6; e++)
                      if (s) {
                        g
                          ? i.texSubImage2D(34069 + e, 0, 0, 0, c[e].width, c[e].height, m, p, c[e].data)
                          : i.texImage2D(34069 + e, 0, f, c[e].width, c[e].height, 0, m, p, c[e].data);
                        for (let t = 0; t < v.length; t++) {
                          const n = v[t].image[e].image;
                          g
                            ? i.texSubImage2D(34069 + e, t + 1, 0, 0, n.width, n.height, m, p, n.data)
                            : i.texImage2D(34069 + e, t + 1, f, n.width, n.height, 0, m, p, n.data);
                        }
                      } else {
                        g ? i.texSubImage2D(34069 + e, 0, 0, 0, m, p, c[e]) : i.texImage2D(34069 + e, 0, f, m, p, c[e]);
                        for (let t = 0; t < v.length; t++) {
                          const n = v[t];
                          g
                            ? i.texSubImage2D(34069 + e, t + 1, 0, 0, m, p, n.image[e])
                            : i.texImage2D(34069 + e, t + 1, f, m, p, n.image[e]);
                        }
                      }
                  }
                  z(n, d) && U(34067), (h.__currentVersion = h.version), n.onUpdate && n.onUpdate(n);
                }
                t.__version = n.version;
              })(a, t, s)
            : (i.activeTexture(33984 + s), i.bindTexture(34067, a.__webglTexture));
        }),
        (this.rebindTextures = function (e, t, i) {
          const s = n.get(e);
          void 0 !== t && te(s.__webglFramebuffer, e, e.texture, 36064, 3553), void 0 !== i && se(e);
        }),
        (this.setupRenderTarget = function (t) {
          const l = t.texture,
            h = n.get(t),
            c = n.get(l);
          t.addEventListener('dispose', W),
            !0 !== t.isWebGLMultipleRenderTargets &&
              (void 0 === c.__webglTexture && (c.__webglTexture = e.createTexture()),
              (c.__version = l.version),
              a.memory.textures++);
          const u = !0 === t.isWebGLCubeRenderTarget,
            d = !0 === t.isWebGLMultipleRenderTargets,
            m = N(t) || o;
          if (u) {
            h.__webglFramebuffer = [];
            for (let t = 0; t < 6; t++) h.__webglFramebuffer[t] = e.createFramebuffer();
          } else {
            if (((h.__webglFramebuffer = e.createFramebuffer()), d && s.drawBuffers)) {
              const i = t.texture;
              for (let t = 0, s = i.length; t < s; t++) {
                const s = n.get(i[t]);
                void 0 === s.__webglTexture && ((s.__webglTexture = e.createTexture()), a.memory.textures++);
              }
            }
            if (o && t.samples > 0 && !1 === ae(t)) {
              const n = d ? l : [l];
              (h.__webglMultisampledFramebuffer = e.createFramebuffer()),
                (h.__webglColorRenderbuffer = []),
                i.bindFramebuffer(36160, h.__webglMultisampledFramebuffer);
              for (let i = 0; i < n.length; i++) {
                const s = n[i];
                (h.__webglColorRenderbuffer[i] = e.createRenderbuffer()),
                  e.bindRenderbuffer(36161, h.__webglColorRenderbuffer[i]);
                const a = r.convert(s.format, s.encoding),
                  o = r.convert(s.type),
                  l = B(s.internalFormat, a, o, s.encoding),
                  c = re(t);
                e.renderbufferStorageMultisample(36161, c, l, t.width, t.height),
                  e.framebufferRenderbuffer(36160, 36064 + i, 36161, h.__webglColorRenderbuffer[i]);
              }
              e.bindRenderbuffer(36161, null),
                t.depthBuffer &&
                  ((h.__webglDepthRenderbuffer = e.createRenderbuffer()), ne(h.__webglDepthRenderbuffer, t, !0)),
                i.bindFramebuffer(36160, null);
            }
          }
          if (u) {
            i.bindTexture(34067, c.__webglTexture), K(34067, l, m);
            for (let e = 0; e < 6; e++) te(h.__webglFramebuffer[e], t, l, 36064, 34069 + e);
            z(l, m) && U(34067), i.unbindTexture();
          } else if (d) {
            const e = t.texture;
            for (let s = 0, r = e.length; s < r; s++) {
              const r = e[s],
                a = n.get(r);
              i.bindTexture(3553, a.__webglTexture),
                K(3553, r, m),
                te(h.__webglFramebuffer, t, r, 36064 + s, 3553),
                z(r, m) && U(3553);
            }
            i.unbindTexture();
          } else {
            let e = 3553;
            (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) &&
              o &&
              (e = t.isWebGL3DRenderTarget ? 32879 : 35866),
              i.bindTexture(e, c.__webglTexture),
              K(e, l, m),
              te(h.__webglFramebuffer, t, l, 36064, e),
              z(l, m) && U(e),
              i.unbindTexture();
          }
          t.depthBuffer && se(t);
        }),
        (this.updateRenderTargetMipmap = function (e) {
          const t = N(e) || o,
            s = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
          for (let r = 0, a = s.length; r < a; r++) {
            const a = s[r];
            if (z(a, t)) {
              const t = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                s = n.get(a).__webglTexture;
              i.bindTexture(t, s), U(t), i.unbindTexture();
            }
          }
        }),
        (this.updateMultisampleRenderTarget = function (t) {
          if (o && t.samples > 0 && !1 === ae(t)) {
            const s = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture],
              r = t.width,
              a = t.height;
            let o = 16384;
            const l = [],
              h = t.stencilBuffer ? 33306 : 36096,
              c = n.get(t),
              u = !0 === t.isWebGLMultipleRenderTargets;
            if (u)
              for (let t = 0; t < s.length; t++)
                i.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                  e.framebufferRenderbuffer(36160, 36064 + t, 36161, null),
                  i.bindFramebuffer(36160, c.__webglFramebuffer),
                  e.framebufferTexture2D(36009, 36064 + t, 3553, null, 0);
            i.bindFramebuffer(36008, c.__webglMultisampledFramebuffer), i.bindFramebuffer(36009, c.__webglFramebuffer);
            for (let i = 0; i < s.length; i++) {
              l.push(36064 + i), t.depthBuffer && l.push(h);
              const d = void 0 !== c.__ignoreDepthValues && c.__ignoreDepthValues;
              if (
                (!1 === d && (t.depthBuffer && (o |= 256), t.stencilBuffer && (o |= 1024)),
                u && e.framebufferRenderbuffer(36008, 36064, 36161, c.__webglColorRenderbuffer[i]),
                !0 === d && (e.invalidateFramebuffer(36008, [h]), e.invalidateFramebuffer(36009, [h])),
                u)
              ) {
                const t = n.get(s[i]).__webglTexture;
                e.framebufferTexture2D(36009, 36064, 3553, t, 0);
              }
              e.blitFramebuffer(0, 0, r, a, 0, 0, r, a, o, 9728), L && e.invalidateFramebuffer(36008, l);
            }
            if ((i.bindFramebuffer(36008, null), i.bindFramebuffer(36009, null), u))
              for (let t = 0; t < s.length; t++) {
                i.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                  e.framebufferRenderbuffer(36160, 36064 + t, 36161, c.__webglColorRenderbuffer[t]);
                const r = n.get(s[t]).__webglTexture;
                i.bindFramebuffer(36160, c.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + t, 3553, r, 0);
              }
            i.bindFramebuffer(36009, c.__webglMultisampledFramebuffer);
          }
        }),
        (this.setupDepthRenderbuffer = se),
        (this.setupFrameBufferTexture = te),
        (this.useMultisampledRTT = ae);
    }
    function gr(e, t, i) {
      const n = i.isWebGL2;
      return {
        convert: function (i, s = null) {
          let r;
          if (i === x) return 5121;
          if (1017 === i) return 32819;
          if (1018 === i) return 32820;
          if (1010 === i) return 5120;
          if (1011 === i) return 5122;
          if (1012 === i) return 5123;
          if (1013 === i) return 5124;
          if (i === y) return 5125;
          if (i === M) return 5126;
          if (i === b) return n ? 5131 : ((r = t.get('OES_texture_half_float')), null !== r ? r.HALF_FLOAT_OES : null);
          if (1021 === i) return 6406;
          if (i === w) return 6408;
          if (1024 === i) return 6409;
          if (1025 === i) return 6410;
          if (i === A) return 6402;
          if (i === T) return 34041;
          if (1028 === i) return 6403;
          if (1022 === i) return 6408;
          if (i === j) return (r = t.get('EXT_sRGB')), null !== r ? r.SRGB_ALPHA_EXT : null;
          if (1029 === i) return 36244;
          if (1030 === i) return 33319;
          if (1031 === i) return 33320;
          if (1033 === i) return 36249;
          if (i === E || i === L || i === C || i === P)
            if (s === k) {
              if (((r = t.get('WEBGL_compressed_texture_s3tc_srgb')), null === r)) return null;
              if (i === E) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
              if (i === L) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
              if (i === C) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
              if (i === P) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            } else {
              if (((r = t.get('WEBGL_compressed_texture_s3tc')), null === r)) return null;
              if (i === E) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (i === L) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (i === C) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (i === P) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
          if (35840 === i || 35841 === i || 35842 === i || 35843 === i) {
            if (((r = t.get('WEBGL_compressed_texture_pvrtc')), null === r)) return null;
            if (35840 === i) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (35841 === i) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (35842 === i) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (35843 === i) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (36196 === i)
            return (r = t.get('WEBGL_compressed_texture_etc1')), null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
          if (37492 === i || 37496 === i) {
            if (((r = t.get('WEBGL_compressed_texture_etc')), null === r)) return null;
            if (37492 === i) return s === k ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
            if (37496 === i) return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
          }
          if (
            37808 === i ||
            37809 === i ||
            37810 === i ||
            37811 === i ||
            37812 === i ||
            37813 === i ||
            37814 === i ||
            37815 === i ||
            37816 === i ||
            37817 === i ||
            37818 === i ||
            37819 === i ||
            37820 === i ||
            37821 === i
          ) {
            if (((r = t.get('WEBGL_compressed_texture_astc')), null === r)) return null;
            if (37808 === i) return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (37809 === i) return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (37810 === i) return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (37811 === i) return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (37812 === i) return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (37813 === i) return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (37814 === i) return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (37815 === i) return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (37816 === i) return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (37817 === i) return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (37818 === i) return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (37819 === i)
              return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (37820 === i)
              return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (37821 === i)
              return s === k ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
          }
          if (36492 === i) {
            if (((r = t.get('EXT_texture_compression_bptc')), null === r)) return null;
            if (36492 === i) return s === k ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          }
          return i === S
            ? n
              ? 34042
              : ((r = t.get('WEBGL_depth_texture')), null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null)
            : void 0 !== e[i]
            ? e[i]
            : null;
        },
      };
    }
    class _r extends Ii {
      constructor(e = []) {
        super(), (this.isArrayCamera = !0), (this.cameras = e);
      }
    }
    class vr extends It {
      constructor() {
        super(), (this.isGroup = !0), (this.type = 'Group');
      }
    }
    const xr = { type: 'move' };
    class yr {
      constructor() {
        (this._targetRay = null), (this._grip = null), (this._hand = null);
      }
      getHandSpace() {
        return (
          null === this._hand &&
            ((this._hand = new vr()),
            (this._hand.matrixAutoUpdate = !1),
            (this._hand.visible = !1),
            (this._hand.joints = {}),
            (this._hand.inputState = { pinching: !1 })),
          this._hand
        );
      }
      getTargetRaySpace() {
        return (
          null === this._targetRay &&
            ((this._targetRay = new vr()),
            (this._targetRay.matrixAutoUpdate = !1),
            (this._targetRay.visible = !1),
            (this._targetRay.hasLinearVelocity = !1),
            (this._targetRay.linearVelocity = new Pe()),
            (this._targetRay.hasAngularVelocity = !1),
            (this._targetRay.angularVelocity = new Pe())),
          this._targetRay
        );
      }
      getGripSpace() {
        return (
          null === this._grip &&
            ((this._grip = new vr()),
            (this._grip.matrixAutoUpdate = !1),
            (this._grip.visible = !1),
            (this._grip.hasLinearVelocity = !1),
            (this._grip.linearVelocity = new Pe()),
            (this._grip.hasAngularVelocity = !1),
            (this._grip.angularVelocity = new Pe())),
          this._grip
        );
      }
      dispatchEvent(e) {
        return (
          null !== this._targetRay && this._targetRay.dispatchEvent(e),
          null !== this._grip && this._grip.dispatchEvent(e),
          null !== this._hand && this._hand.dispatchEvent(e),
          this
        );
      }
      disconnect(e) {
        return (
          this.dispatchEvent({ type: 'disconnected', data: e }),
          null !== this._targetRay && (this._targetRay.visible = !1),
          null !== this._grip && (this._grip.visible = !1),
          null !== this._hand && (this._hand.visible = !1),
          this
        );
      }
      update(e, t, i) {
        let n = null,
          s = null,
          r = null;
        const a = this._targetRay,
          o = this._grip,
          l = this._hand;
        if (e && 'visible-blurred' !== t.session.visibilityState) {
          if (l && e.hand) {
            r = !0;
            for (const n of e.hand.values()) {
              const e = t.getJointPose(n, i);
              if (void 0 === l.joints[n.jointName]) {
                const e = new vr();
                (e.matrixAutoUpdate = !1), (e.visible = !1), (l.joints[n.jointName] = e), l.add(e);
              }
              const s = l.joints[n.jointName];
              null !== e &&
                (s.matrix.fromArray(e.transform.matrix),
                s.matrix.decompose(s.position, s.rotation, s.scale),
                (s.jointRadius = e.radius)),
                (s.visible = null !== e);
            }
            const n = l.joints['index-finger-tip'],
              s = l.joints['thumb-tip'],
              a = n.position.distanceTo(s.position),
              o = 0.02,
              h = 0.005;
            l.inputState.pinching && a > o + h
              ? ((l.inputState.pinching = !1),
                this.dispatchEvent({ type: 'pinchend', handedness: e.handedness, target: this }))
              : !l.inputState.pinching &&
                a <= o - h &&
                ((l.inputState.pinching = !0),
                this.dispatchEvent({ type: 'pinchstart', handedness: e.handedness, target: this }));
          } else
            null !== o &&
              e.gripSpace &&
              ((s = t.getPose(e.gripSpace, i)),
              null !== s &&
                (o.matrix.fromArray(s.transform.matrix),
                o.matrix.decompose(o.position, o.rotation, o.scale),
                s.linearVelocity
                  ? ((o.hasLinearVelocity = !0), o.linearVelocity.copy(s.linearVelocity))
                  : (o.hasLinearVelocity = !1),
                s.angularVelocity
                  ? ((o.hasAngularVelocity = !0), o.angularVelocity.copy(s.angularVelocity))
                  : (o.hasAngularVelocity = !1)));
          null !== a &&
            ((n = t.getPose(e.targetRaySpace, i)),
            null === n && null !== s && (n = s),
            null !== n &&
              (a.matrix.fromArray(n.transform.matrix),
              a.matrix.decompose(a.position, a.rotation, a.scale),
              n.linearVelocity
                ? ((a.hasLinearVelocity = !0), a.linearVelocity.copy(n.linearVelocity))
                : (a.hasLinearVelocity = !1),
              n.angularVelocity
                ? ((a.hasAngularVelocity = !0), a.angularVelocity.copy(n.angularVelocity))
                : (a.hasAngularVelocity = !1),
              this.dispatchEvent(xr)));
        }
        return (
          null !== a && (a.visible = null !== n),
          null !== o && (o.visible = null !== s),
          null !== l && (l.visible = null !== r),
          this
        );
      }
    }
    class Mr extends we {
      constructor(e, t, i, n, s, r, a, o, l, h) {
        if ((h = void 0 !== h ? h : A) !== A && h !== T)
          throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
        void 0 === i && h === A && (i = y),
          void 0 === i && h === T && (i = S),
          super(null, n, s, r, a, o, h, i, l),
          (this.isDepthTexture = !0),
          (this.image = { width: e, height: t }),
          (this.magFilter = void 0 !== a ? a : m),
          (this.minFilter = void 0 !== o ? o : m),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
    }
    class br extends W {
      constructor(e, t) {
        super();
        const i = this;
        let n = null,
          s = 1,
          r = null,
          a = 'local-floor',
          o = null,
          l = null,
          h = null,
          c = null,
          u = null,
          d = null;
        const m = t.getContextAttributes();
        let p = null,
          f = null;
        const g = [],
          _ = [],
          v = new Ii();
        v.layers.enable(1), (v.viewport = new Ae());
        const M = new Ii();
        M.layers.enable(2), (M.viewport = new Ae());
        const b = [v, M],
          E = new _r();
        E.layers.enable(1), E.layers.enable(2);
        let L = null,
          C = null;
        function P(e) {
          const t = _.indexOf(e.inputSource);
          if (-1 === t) return;
          const i = g[t];
          void 0 !== i && i.dispatchEvent({ type: e.type, data: e.inputSource });
        }
        function D() {
          n.removeEventListener('select', P),
            n.removeEventListener('selectstart', P),
            n.removeEventListener('selectend', P),
            n.removeEventListener('squeeze', P),
            n.removeEventListener('squeezestart', P),
            n.removeEventListener('squeezeend', P),
            n.removeEventListener('end', D),
            n.removeEventListener('inputsourceschange', I);
          for (let e = 0; e < g.length; e++) {
            const t = _[e];
            null !== t && ((_[e] = null), g[e].disconnect(t));
          }
          (L = null),
            (C = null),
            e.setRenderTarget(p),
            (u = null),
            (c = null),
            (h = null),
            (n = null),
            (f = null),
            F.stop(),
            (i.isPresenting = !1),
            i.dispatchEvent({ type: 'sessionend' });
        }
        function I(e) {
          for (let t = 0; t < e.removed.length; t++) {
            const i = e.removed[t],
              n = _.indexOf(i);
            n >= 0 && ((_[n] = null), g[n].dispatchEvent({ type: 'disconnected', data: i }));
          }
          for (let t = 0; t < e.added.length; t++) {
            const i = e.added[t];
            let n = _.indexOf(i);
            if (-1 === n) {
              for (let e = 0; e < g.length; e++) {
                if (e >= _.length) {
                  _.push(i), (n = e);
                  break;
                }
                if (null === _[e]) {
                  (_[e] = i), (n = e);
                  break;
                }
              }
              if (-1 === n) break;
            }
            const s = g[n];
            s && s.dispatchEvent({ type: 'connected', data: i });
          }
        }
        (this.cameraAutoUpdate = !0),
          (this.enabled = !1),
          (this.isPresenting = !1),
          (this.getController = function (e) {
            let t = g[e];
            return void 0 === t && ((t = new yr()), (g[e] = t)), t.getTargetRaySpace();
          }),
          (this.getControllerGrip = function (e) {
            let t = g[e];
            return void 0 === t && ((t = new yr()), (g[e] = t)), t.getGripSpace();
          }),
          (this.getHand = function (e) {
            let t = g[e];
            return void 0 === t && ((t = new yr()), (g[e] = t)), t.getHandSpace();
          }),
          (this.setFramebufferScaleFactor = function (e) {
            (s = e), i.isPresenting;
          }),
          (this.setReferenceSpaceType = function (e) {
            (a = e), i.isPresenting;
          }),
          (this.getReferenceSpace = function () {
            return o || r;
          }),
          (this.setReferenceSpace = function (e) {
            o = e;
          }),
          (this.getBaseLayer = function () {
            return null !== c ? c : u;
          }),
          (this.getBinding = function () {
            return h;
          }),
          (this.getFrame = function () {
            return d;
          }),
          (this.getSession = function () {
            return n;
          }),
          (this.setSession = async function (l) {
            if (((n = l), null !== n)) {
              if (
                ((p = e.getRenderTarget()),
                n.addEventListener('select', P),
                n.addEventListener('selectstart', P),
                n.addEventListener('selectend', P),
                n.addEventListener('squeeze', P),
                n.addEventListener('squeezestart', P),
                n.addEventListener('squeezeend', P),
                n.addEventListener('end', D),
                n.addEventListener('inputsourceschange', I),
                !0 !== m.xrCompatible && (await t.makeXRCompatible()),
                void 0 === n.renderState.layers || !1 === e.capabilities.isWebGL2)
              ) {
                const i = {
                  antialias: void 0 !== n.renderState.layers || m.antialias,
                  alpha: m.alpha,
                  depth: m.depth,
                  stencil: m.stencil,
                  framebufferScaleFactor: s,
                };
                (u = new XRWebGLLayer(n, t, i)),
                  n.updateRenderState({ baseLayer: u }),
                  (f = new Te(u.framebufferWidth, u.framebufferHeight, {
                    format: w,
                    type: x,
                    encoding: e.outputEncoding,
                  }));
              } else {
                let i = null,
                  r = null,
                  a = null;
                m.depth && ((a = m.stencil ? 35056 : 33190), (i = m.stencil ? T : A), (r = m.stencil ? S : y));
                const o = { colorFormat: 32856, depthFormat: a, scaleFactor: s };
                (h = new XRWebGLBinding(n, t)),
                  (c = h.createProjectionLayer(o)),
                  n.updateRenderState({ layers: [c] }),
                  (f = new Te(c.textureWidth, c.textureHeight, {
                    format: w,
                    type: x,
                    depthTexture: new Mr(
                      c.textureWidth,
                      c.textureHeight,
                      r,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      i,
                    ),
                    stencilBuffer: m.stencil,
                    encoding: e.outputEncoding,
                    samples: m.antialias ? 4 : 0,
                  }));
                e.properties.get(f).__ignoreDepthValues = c.ignoreDepthValues;
              }
              (f.isXRRenderTarget = !0),
                this.setFoveation(1),
                (o = null),
                (r = await n.requestReferenceSpace(a)),
                F.setContext(n),
                F.start(),
                (i.isPresenting = !0),
                i.dispatchEvent({ type: 'sessionstart' });
            }
          });
        const R = new Pe(),
          O = new Pe();
        function N(e, t) {
          null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.copy(e.matrixWorld).invert();
        }
        (this.updateCamera = function (e) {
          if (null === n) return;
          (E.near = M.near = v.near = e.near),
            (E.far = M.far = v.far = e.far),
            (L === E.near && C === E.far) ||
              (n.updateRenderState({ depthNear: E.near, depthFar: E.far }), (L = E.near), (C = E.far));
          const t = e.parent,
            i = E.cameras;
          N(E, t);
          for (let e = 0; e < i.length; e++) N(i[e], t);
          E.matrixWorld.decompose(E.position, E.quaternion, E.scale),
            e.position.copy(E.position),
            e.quaternion.copy(E.quaternion),
            e.scale.copy(E.scale),
            e.matrix.copy(E.matrix),
            e.matrixWorld.copy(E.matrixWorld);
          const s = e.children;
          for (let e = 0, t = s.length; e < t; e++) s[e].updateMatrixWorld(!0);
          2 === i.length
            ? (function (e, t, i) {
                R.setFromMatrixPosition(t.matrixWorld), O.setFromMatrixPosition(i.matrixWorld);
                const n = R.distanceTo(O),
                  s = t.projectionMatrix.elements,
                  r = i.projectionMatrix.elements,
                  a = s[14] / (s[10] - 1),
                  o = s[14] / (s[10] + 1),
                  l = (s[9] + 1) / s[5],
                  h = (s[9] - 1) / s[5],
                  c = (s[8] - 1) / s[0],
                  u = (r[8] + 1) / r[0],
                  d = a * c,
                  m = a * u,
                  p = n / (-c + u),
                  f = p * -c;
                t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                  e.translateX(f),
                  e.translateZ(p),
                  e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                  e.matrixWorldInverse.copy(e.matrixWorld).invert();
                const g = a + p,
                  _ = o + p,
                  v = d - f,
                  x = m + (n - f),
                  y = ((l * o) / _) * g,
                  M = ((h * o) / _) * g;
                e.projectionMatrix.makePerspective(v, x, y, M, g, _);
              })(E, v, M)
            : E.projectionMatrix.copy(v.projectionMatrix);
        }),
          (this.getCamera = function () {
            return E;
          }),
          (this.getFoveation = function () {
            return null !== c ? c.fixedFoveation : null !== u ? u.fixedFoveation : void 0;
          }),
          (this.setFoveation = function (e) {
            null !== c && (c.fixedFoveation = e), null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = e);
          });
        let z = null;
        const F = new ji();
        F.setAnimationLoop(function (t, i) {
          if (((l = i.getViewerPose(o || r)), (d = i), null !== l)) {
            const t = l.views;
            null !== u && (e.setRenderTargetFramebuffer(f, u.framebuffer), e.setRenderTarget(f));
            let i = !1;
            t.length !== E.cameras.length && ((E.cameras.length = 0), (i = !0));
            for (let n = 0; n < t.length; n++) {
              const s = t[n];
              let r = null;
              if (null !== u) r = u.getViewport(s);
              else {
                const t = h.getViewSubImage(c, s);
                (r = t.viewport),
                  0 === n &&
                    (e.setRenderTargetTextures(f, t.colorTexture, c.ignoreDepthValues ? void 0 : t.depthStencilTexture),
                    e.setRenderTarget(f));
              }
              let a = b[n];
              void 0 === a && ((a = new Ii()), a.layers.enable(n), (a.viewport = new Ae()), (b[n] = a)),
                a.matrix.fromArray(s.transform.matrix),
                a.projectionMatrix.fromArray(s.projectionMatrix),
                a.viewport.set(r.x, r.y, r.width, r.height),
                0 === n && E.matrix.copy(a.matrix),
                !0 === i && E.cameras.push(a);
            }
          }
          for (let e = 0; e < g.length; e++) {
            const t = _[e],
              n = g[e];
            null !== t && void 0 !== n && n.update(t, i, o || r);
          }
          z && z(t, i), (d = null);
        }),
          (this.setAnimationLoop = function (e) {
            z = e;
          }),
          (this.dispose = function () {});
      }
    }
    function Sr(e, t) {
      function i(i, n) {
        (i.opacity.value = n.opacity),
          n.color && i.diffuse.value.copy(n.color),
          n.emissive && i.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
          n.map && (i.map.value = n.map),
          n.alphaMap && (i.alphaMap.value = n.alphaMap),
          n.bumpMap &&
            ((i.bumpMap.value = n.bumpMap),
            (i.bumpScale.value = n.bumpScale),
            1 === n.side && (i.bumpScale.value *= -1)),
          n.displacementMap &&
            ((i.displacementMap.value = n.displacementMap),
            (i.displacementScale.value = n.displacementScale),
            (i.displacementBias.value = n.displacementBias)),
          n.emissiveMap && (i.emissiveMap.value = n.emissiveMap),
          n.normalMap &&
            ((i.normalMap.value = n.normalMap),
            i.normalScale.value.copy(n.normalScale),
            1 === n.side && i.normalScale.value.negate()),
          n.specularMap && (i.specularMap.value = n.specularMap),
          n.alphaTest > 0 && (i.alphaTest.value = n.alphaTest);
        const s = t.get(n).envMap;
        if (
          (s &&
            ((i.envMap.value = s),
            (i.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1),
            (i.reflectivity.value = n.reflectivity),
            (i.ior.value = n.ior),
            (i.refractionRatio.value = n.refractionRatio)),
          n.lightMap)
        ) {
          i.lightMap.value = n.lightMap;
          const t = !0 !== e.physicallyCorrectLights ? Math.PI : 1;
          i.lightMapIntensity.value = n.lightMapIntensity * t;
        }
        let r, a;
        n.aoMap && ((i.aoMap.value = n.aoMap), (i.aoMapIntensity.value = n.aoMapIntensity)),
          n.map
            ? (r = n.map)
            : n.specularMap
            ? (r = n.specularMap)
            : n.displacementMap
            ? (r = n.displacementMap)
            : n.normalMap
            ? (r = n.normalMap)
            : n.bumpMap
            ? (r = n.bumpMap)
            : n.roughnessMap
            ? (r = n.roughnessMap)
            : n.metalnessMap
            ? (r = n.metalnessMap)
            : n.alphaMap
            ? (r = n.alphaMap)
            : n.emissiveMap
            ? (r = n.emissiveMap)
            : n.clearcoatMap
            ? (r = n.clearcoatMap)
            : n.clearcoatNormalMap
            ? (r = n.clearcoatNormalMap)
            : n.clearcoatRoughnessMap
            ? (r = n.clearcoatRoughnessMap)
            : n.iridescenceMap
            ? (r = n.iridescenceMap)
            : n.iridescenceThicknessMap
            ? (r = n.iridescenceThicknessMap)
            : n.specularIntensityMap
            ? (r = n.specularIntensityMap)
            : n.specularColorMap
            ? (r = n.specularColorMap)
            : n.transmissionMap
            ? (r = n.transmissionMap)
            : n.thicknessMap
            ? (r = n.thicknessMap)
            : n.sheenColorMap
            ? (r = n.sheenColorMap)
            : n.sheenRoughnessMap && (r = n.sheenRoughnessMap),
          void 0 !== r &&
            (r.isWebGLRenderTarget && (r = r.texture),
            !0 === r.matrixAutoUpdate && r.updateMatrix(),
            i.uvTransform.value.copy(r.matrix)),
          n.aoMap ? (a = n.aoMap) : n.lightMap && (a = n.lightMap),
          void 0 !== a &&
            (a.isWebGLRenderTarget && (a = a.texture),
            !0 === a.matrixAutoUpdate && a.updateMatrix(),
            i.uv2Transform.value.copy(a.matrix));
      }
      return {
        refreshFogUniforms: function (e, t) {
          e.fogColor.value.copy(t.color),
            t.isFog
              ? ((e.fogNear.value = t.near), (e.fogFar.value = t.far))
              : t.isFogExp2 && (e.fogDensity.value = t.density);
        },
        refreshMaterialUniforms: function (e, n, s, r, a) {
          n.isMeshBasicMaterial || n.isMeshLambertMaterial
            ? i(e, n)
            : n.isMeshToonMaterial
            ? (i(e, n),
              (function (e, t) {
                t.gradientMap && (e.gradientMap.value = t.gradientMap);
              })(e, n))
            : n.isMeshPhongMaterial
            ? (i(e, n),
              (function (e, t) {
                e.specular.value.copy(t.specular), (e.shininess.value = Math.max(t.shininess, 1e-4));
              })(e, n))
            : n.isMeshStandardMaterial
            ? (i(e, n),
              (function (e, i) {
                (e.roughness.value = i.roughness),
                  (e.metalness.value = i.metalness),
                  i.roughnessMap && (e.roughnessMap.value = i.roughnessMap);
                i.metalnessMap && (e.metalnessMap.value = i.metalnessMap);
                t.get(i).envMap && (e.envMapIntensity.value = i.envMapIntensity);
              })(e, n),
              n.isMeshPhysicalMaterial &&
                (function (e, t, i) {
                  (e.ior.value = t.ior),
                    t.sheen > 0 &&
                      (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),
                      (e.sheenRoughness.value = t.sheenRoughness),
                      t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap),
                      t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap));
                  t.clearcoat > 0 &&
                    ((e.clearcoat.value = t.clearcoat),
                    (e.clearcoatRoughness.value = t.clearcoatRoughness),
                    t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap),
                    t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap),
                    t.clearcoatNormalMap &&
                      (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                      (e.clearcoatNormalMap.value = t.clearcoatNormalMap),
                      1 === t.side && e.clearcoatNormalScale.value.negate()));
                  t.iridescence > 0 &&
                    ((e.iridescence.value = t.iridescence),
                    (e.iridescenceIOR.value = t.iridescenceIOR),
                    (e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0]),
                    (e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1]),
                    t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap),
                    t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap));
                  t.transmission > 0 &&
                    ((e.transmission.value = t.transmission),
                    (e.transmissionSamplerMap.value = i.texture),
                    e.transmissionSamplerSize.value.set(i.width, i.height),
                    t.transmissionMap && (e.transmissionMap.value = t.transmissionMap),
                    (e.thickness.value = t.thickness),
                    t.thicknessMap && (e.thicknessMap.value = t.thicknessMap),
                    (e.attenuationDistance.value = t.attenuationDistance),
                    e.attenuationColor.value.copy(t.attenuationColor));
                  (e.specularIntensity.value = t.specularIntensity),
                    e.specularColor.value.copy(t.specularColor),
                    t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap);
                  t.specularColorMap && (e.specularColorMap.value = t.specularColorMap);
                })(e, n, a))
            : n.isMeshMatcapMaterial
            ? (i(e, n),
              (function (e, t) {
                t.matcap && (e.matcap.value = t.matcap);
              })(e, n))
            : n.isMeshDepthMaterial
            ? i(e, n)
            : n.isMeshDistanceMaterial
            ? (i(e, n),
              (function (e, t) {
                e.referencePosition.value.copy(t.referencePosition),
                  (e.nearDistance.value = t.nearDistance),
                  (e.farDistance.value = t.farDistance);
              })(e, n))
            : n.isMeshNormalMaterial
            ? i(e, n)
            : n.isLineBasicMaterial
            ? ((function (e, t) {
                e.diffuse.value.copy(t.color), (e.opacity.value = t.opacity);
              })(e, n),
              n.isLineDashedMaterial &&
                (function (e, t) {
                  (e.dashSize.value = t.dashSize),
                    (e.totalSize.value = t.dashSize + t.gapSize),
                    (e.scale.value = t.scale);
                })(e, n))
            : n.isPointsMaterial
            ? (function (e, t, i, n) {
                e.diffuse.value.copy(t.color),
                  (e.opacity.value = t.opacity),
                  (e.size.value = t.size * i),
                  (e.scale.value = 0.5 * n),
                  t.map && (e.map.value = t.map);
                t.alphaMap && (e.alphaMap.value = t.alphaMap);
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                let s;
                t.map ? (s = t.map) : t.alphaMap && (s = t.alphaMap);
                void 0 !== s && (!0 === s.matrixAutoUpdate && s.updateMatrix(), e.uvTransform.value.copy(s.matrix));
              })(e, n, s, r)
            : n.isSpriteMaterial
            ? (function (e, t) {
                e.diffuse.value.copy(t.color),
                  (e.opacity.value = t.opacity),
                  (e.rotation.value = t.rotation),
                  t.map && (e.map.value = t.map);
                t.alphaMap && (e.alphaMap.value = t.alphaMap);
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                let i;
                t.map ? (i = t.map) : t.alphaMap && (i = t.alphaMap);
                void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix));
              })(e, n)
            : n.isShadowMaterial
            ? (e.color.value.copy(n.color), (e.opacity.value = n.opacity))
            : n.isShaderMaterial && (n.uniformsNeedUpdate = !1);
        },
      };
    }
    function wr(e = {}) {
      this.isWebGLRenderer = !0;
      const t =
          void 0 !== e.canvas
            ? e.canvas
            : (function () {
                const e = oe('canvas');
                return (e.style.display = 'block'), e;
              })(),
        i = void 0 !== e.context ? e.context : null,
        n = void 0 === e.depth || e.depth,
        s = void 0 === e.stencil || e.stencil,
        r = void 0 !== e.antialias && e.antialias,
        a = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
        o = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
        l = void 0 !== e.powerPreference ? e.powerPreference : 'default',
        h = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
      let c;
      c = null !== i ? i.getContextAttributes().alpha : void 0 !== e.alpha && e.alpha;
      let u = null,
        d = null;
      const m = [],
        p = [];
      (this.domElement = t),
        (this.debug = { checkShaderErrors: !0 }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this.outputEncoding = F),
        (this.physicallyCorrectLights = !1),
        (this.toneMapping = 0),
        (this.toneMappingExposure = 1),
        Object.defineProperties(this, {
          gammaFactor: {
            get: function () {
              return 2;
            },
            set: function () {},
          },
        });
      const f = this;
      let g = !1,
        _ = 0,
        y = 0,
        S = null,
        A = -1,
        T = null;
      const E = new Ae(),
        L = new Ae();
      let C = null,
        P = t.width,
        D = t.height,
        I = 1,
        R = null,
        O = null;
      const N = new Ae(0, 0, P, D),
        z = new Ae(0, 0, P, D);
      let k = !1;
      const U = new Hi();
      let B = !1,
        G = !1,
        V = null;
      const H = new ot(),
        j = new se(),
        W = new Pe(),
        X = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
      function q() {
        return null === S ? I : 1;
      }
      let Y,
        Z,
        J,
        K,
        $,
        Q,
        ee,
        te,
        ne,
        re,
        ae,
        le,
        he,
        ce,
        ue,
        de,
        me,
        pe,
        fe,
        ge,
        _e,
        ve,
        xe,
        ye = i;
      function Me(e, i) {
        for (let n = 0; n < e.length; n++) {
          const s = e[n],
            r = t.getContext(s, i);
          if (null !== r) return r;
        }
        return null;
      }
      try {
        const e = {
          alpha: !0,
          depth: n,
          stencil: s,
          antialias: r,
          premultipliedAlpha: a,
          preserveDrawingBuffer: o,
          powerPreference: l,
          failIfMajorPerformanceCaveat: h,
        };
        if (
          ('setAttribute' in t && t.setAttribute('data-engine', 'three.js r142'),
          t.addEventListener('webglcontextlost', we, !1),
          t.addEventListener('webglcontextrestored', Ee, !1),
          t.addEventListener('webglcontextcreationerror', Le, !1),
          null === ye)
        ) {
          const t = ['webgl2', 'webgl', 'experimental-webgl'];
          if ((!0 === f.isWebGL1Renderer && t.shift(), (ye = Me(t, e)), null === ye))
            throw Me(t)
              ? new Error('Error creating WebGL context with your selected attributes.')
              : new Error('Error creating WebGL context.');
        }
        void 0 === ye.getShaderPrecisionFormat &&
          (ye.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
      } catch (e) {
        throw e;
      }
      function be() {
        (Y = new xn(ye)),
          (Z = new Qi(ye, Y, e)),
          Y.init(Z),
          (ve = new gr(ye, Y, Z)),
          (J = new pr(ye, Y, Z)),
          (K = new bn()),
          ($ = new er()),
          (Q = new fr(ye, Y, J, $, Z, ve, K)),
          (ee = new tn(f)),
          (te = new vn(f)),
          (ne = new Wi(ye, Z)),
          (xe = new Ki(ye, Y, ne, Z)),
          (re = new yn(ye, ne, K, xe)),
          (ae = new En(ye, re, ne, K)),
          (fe = new Tn(ye, Z, Q)),
          (de = new en($)),
          (le = new Qs(f, ee, te, Y, Z, xe, de)),
          (he = new Sr(f, $)),
          (ce = new sr()),
          (ue = new cr(Y, Z)),
          (pe = new Ji(f, ee, J, ae, c, a)),
          (me = new mr(f, ae, Z)),
          (ge = new $i(ye, Y, K, Z)),
          (_e = new Mn(ye, Y, K, Z)),
          (K.programs = le.programs),
          (f.capabilities = Z),
          (f.extensions = Y),
          (f.properties = $),
          (f.renderLists = ce),
          (f.shadowMap = me),
          (f.state = J),
          (f.info = K);
      }
      be();
      const Se = new br(f, ye);
      function we(e) {
        e.preventDefault(), (g = !0);
      }
      function Ee() {
        g = !1;
        const e = K.autoReset,
          t = me.enabled,
          i = me.autoUpdate,
          n = me.needsUpdate,
          s = me.type;
        be(), (K.autoReset = e), (me.enabled = t), (me.autoUpdate = i), (me.needsUpdate = n), (me.type = s);
      }
      function Le(e) {}
      function Ce(e) {
        const t = e.target;
        t.removeEventListener('dispose', Ce),
          (function (e) {
            (function (e) {
              const t = $.get(e).programs;
              void 0 !== t &&
                (t.forEach(function (e) {
                  le.releaseProgram(e);
                }),
                e.isShaderMaterial && le.releaseShaderCache(e));
            })(e),
              $.remove(e);
          })(t);
      }
      (this.xr = Se),
        (this.getContext = function () {
          return ye;
        }),
        (this.getContextAttributes = function () {
          return ye.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          const e = Y.get('WEBGL_lose_context');
          e && e.loseContext();
        }),
        (this.forceContextRestore = function () {
          const e = Y.get('WEBGL_lose_context');
          e && e.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return I;
        }),
        (this.setPixelRatio = function (e) {
          void 0 !== e && ((I = e), this.setSize(P, D, !1));
        }),
        (this.getSize = function (e) {
          return e.set(P, D);
        }),
        (this.setSize = function (e, i, n) {
          Se.isPresenting ||
            ((P = e),
            (D = i),
            (t.width = Math.floor(e * I)),
            (t.height = Math.floor(i * I)),
            !1 !== n && ((t.style.width = e + 'px'), (t.style.height = i + 'px')),
            this.setViewport(0, 0, e, i));
        }),
        (this.getDrawingBufferSize = function (e) {
          return e.set(P * I, D * I).floor();
        }),
        (this.setDrawingBufferSize = function (e, i, n) {
          (P = e),
            (D = i),
            (I = n),
            (t.width = Math.floor(e * n)),
            (t.height = Math.floor(i * n)),
            this.setViewport(0, 0, e, i);
        }),
        (this.getCurrentViewport = function (e) {
          return e.copy(E);
        }),
        (this.getViewport = function (e) {
          return e.copy(N);
        }),
        (this.setViewport = function (e, t, i, n) {
          e.isVector4 ? N.set(e.x, e.y, e.z, e.w) : N.set(e, t, i, n), J.viewport(E.copy(N).multiplyScalar(I).floor());
        }),
        (this.getScissor = function (e) {
          return e.copy(z);
        }),
        (this.setScissor = function (e, t, i, n) {
          e.isVector4 ? z.set(e.x, e.y, e.z, e.w) : z.set(e, t, i, n), J.scissor(L.copy(z).multiplyScalar(I).floor());
        }),
        (this.getScissorTest = function () {
          return k;
        }),
        (this.setScissorTest = function (e) {
          J.setScissorTest((k = e));
        }),
        (this.setOpaqueSort = function (e) {
          R = e;
        }),
        (this.setTransparentSort = function (e) {
          O = e;
        }),
        (this.getClearColor = function (e) {
          return e.copy(pe.getClearColor());
        }),
        (this.setClearColor = function () {
          pe.setClearColor.apply(pe, arguments);
        }),
        (this.getClearAlpha = function () {
          return pe.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          pe.setClearAlpha.apply(pe, arguments);
        }),
        (this.clear = function (e = !0, t = !0, i = !0) {
          let n = 0;
          e && (n |= 16384), t && (n |= 256), i && (n |= 1024), ye.clear(n);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
          t.removeEventListener('webglcontextlost', we, !1),
            t.removeEventListener('webglcontextrestored', Ee, !1),
            t.removeEventListener('webglcontextcreationerror', Le, !1),
            ce.dispose(),
            ue.dispose(),
            $.dispose(),
            ee.dispose(),
            te.dispose(),
            ae.dispose(),
            xe.dispose(),
            le.dispose(),
            Se.dispose(),
            Se.removeEventListener('sessionstart', Ie),
            Se.removeEventListener('sessionend', Re),
            V && (V.dispose(), (V = null)),
            Oe.stop();
        }),
        (this.renderBufferDirect = function (e, t, i, n, s, r) {
          null === t && (t = X);
          const a = s.isMesh && s.matrixWorld.determinant() < 0,
            o = (function (e, t, i, n, s) {
              !0 !== t.isScene && (t = X);
              Q.resetTextureUnits();
              const r = t.fog,
                a = n.isMeshStandardMaterial ? t.environment : null,
                o = null === S ? f.outputEncoding : !0 === S.isXRRenderTarget ? S.texture.encoding : F,
                l = (n.isMeshStandardMaterial ? te : ee).get(n.envMap || a),
                h = !0 === n.vertexColors && !!i.attributes.color && 4 === i.attributes.color.itemSize,
                c = !!n.normalMap && !!i.attributes.tangent,
                u = !!i.morphAttributes.position,
                m = !!i.morphAttributes.normal,
                p = !!i.morphAttributes.color,
                g = n.toneMapped ? f.toneMapping : 0,
                _ = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color,
                v = void 0 !== _ ? _.length : 0,
                x = $.get(n),
                y = d.state.lights;
              if (!0 === B && (!0 === G || e !== T)) {
                const t = e === T && n.id === A;
                de.setState(n, e, t);
              }
              let M = !1;
              n.version === x.__version
                ? (x.needsLights && x.lightsStateVersion !== y.state.version) ||
                  x.outputEncoding !== o ||
                  (s.isInstancedMesh && !1 === x.instancing)
                  ? (M = !0)
                  : s.isInstancedMesh || !0 !== x.instancing
                  ? s.isSkinnedMesh && !1 === x.skinning
                    ? (M = !0)
                    : s.isSkinnedMesh || !0 !== x.skinning
                    ? x.envMap !== l || (!0 === n.fog && x.fog !== r)
                      ? (M = !0)
                      : void 0 === x.numClippingPlanes ||
                        (x.numClippingPlanes === de.numPlanes && x.numIntersection === de.numIntersection)
                      ? (x.vertexAlphas !== h ||
                          x.vertexTangents !== c ||
                          x.morphTargets !== u ||
                          x.morphNormals !== m ||
                          x.morphColors !== p ||
                          x.toneMapping !== g ||
                          (!0 === Z.isWebGL2 && x.morphTargetsCount !== v)) &&
                        (M = !0)
                      : (M = !0)
                    : (M = !0)
                  : (M = !0)
                : ((M = !0), (x.__version = n.version));
              let b = x.currentProgram;
              !0 === M && (b = Ue(n, t, s));
              let w = !1,
                E = !1,
                L = !1;
              const C = b.getUniforms(),
                P = x.uniforms;
              J.useProgram(b.program) && ((w = !0), (E = !0), (L = !0));
              n.id !== A && ((A = n.id), (E = !0));
              if (w || T !== e) {
                if (
                  (C.setValue(ye, 'projectionMatrix', e.projectionMatrix),
                  Z.logarithmicDepthBuffer && C.setValue(ye, 'logDepthBufFC', 2 / (Math.log(e.far + 1) / Math.LN2)),
                  T !== e && ((T = e), (E = !0), (L = !0)),
                  n.isShaderMaterial ||
                    n.isMeshPhongMaterial ||
                    n.isMeshToonMaterial ||
                    n.isMeshStandardMaterial ||
                    n.envMap)
                ) {
                  const t = C.map.cameraPosition;
                  void 0 !== t && t.setValue(ye, W.setFromMatrixPosition(e.matrixWorld));
                }
                (n.isMeshPhongMaterial ||
                  n.isMeshToonMaterial ||
                  n.isMeshLambertMaterial ||
                  n.isMeshBasicMaterial ||
                  n.isMeshStandardMaterial ||
                  n.isShaderMaterial) &&
                  C.setValue(ye, 'isOrthographic', !0 === e.isOrthographicCamera),
                  (n.isMeshPhongMaterial ||
                    n.isMeshToonMaterial ||
                    n.isMeshLambertMaterial ||
                    n.isMeshBasicMaterial ||
                    n.isMeshStandardMaterial ||
                    n.isShaderMaterial ||
                    n.isShadowMaterial ||
                    s.isSkinnedMesh) &&
                    C.setValue(ye, 'viewMatrix', e.matrixWorldInverse);
              }
              if (s.isSkinnedMesh) {
                C.setOptional(ye, s, 'bindMatrix'), C.setOptional(ye, s, 'bindMatrixInverse');
                const e = s.skeleton;
                e &&
                  Z.floatVertexTextures &&
                  (null === e.boneTexture && e.computeBoneTexture(),
                  C.setValue(ye, 'boneTexture', e.boneTexture, Q),
                  C.setValue(ye, 'boneTextureSize', e.boneTextureSize));
              }
              const R = i.morphAttributes;
              (void 0 !== R.position || void 0 !== R.normal || (void 0 !== R.color && !0 === Z.isWebGL2)) &&
                fe.update(s, i, n, b);
              (E || x.receiveShadow !== s.receiveShadow) &&
                ((x.receiveShadow = s.receiveShadow), C.setValue(ye, 'receiveShadow', s.receiveShadow));
              E &&
                (C.setValue(ye, 'toneMappingExposure', f.toneMappingExposure),
                x.needsLights &&
                  ((N = L),
                  ((O = P).ambientLightColor.needsUpdate = N),
                  (O.lightProbe.needsUpdate = N),
                  (O.directionalLights.needsUpdate = N),
                  (O.directionalLightShadows.needsUpdate = N),
                  (O.pointLights.needsUpdate = N),
                  (O.pointLightShadows.needsUpdate = N),
                  (O.spotLights.needsUpdate = N),
                  (O.spotLightShadows.needsUpdate = N),
                  (O.rectAreaLights.needsUpdate = N),
                  (O.hemisphereLights.needsUpdate = N)),
                r && !0 === n.fog && he.refreshFogUniforms(P, r),
                he.refreshMaterialUniforms(P, n, I, D, V),
                Ds.upload(ye, x.uniformsList, P, Q));
              var O, N;
              n.isShaderMaterial &&
                !0 === n.uniformsNeedUpdate &&
                (Ds.upload(ye, x.uniformsList, P, Q), (n.uniformsNeedUpdate = !1));
              n.isSpriteMaterial && C.setValue(ye, 'center', s.center);
              return (
                C.setValue(ye, 'modelViewMatrix', s.modelViewMatrix),
                C.setValue(ye, 'normalMatrix', s.normalMatrix),
                C.setValue(ye, 'modelMatrix', s.matrixWorld),
                b
              );
            })(e, t, i, n, s);
          J.setMaterial(n, a);
          let l = i.index;
          const h = i.attributes.position;
          if (null === l) {
            if (void 0 === h || 0 === h.count) return;
          } else if (0 === l.count) return;
          let c,
            u = 1;
          !0 === n.wireframe && ((l = re.getWireframeAttribute(i)), (u = 2)), xe.setup(s, n, o, i, l);
          let m = ge;
          null !== l && ((c = ne.get(l)), (m = _e), m.setIndex(c));
          const p = null !== l ? l.count : h.count,
            g = i.drawRange.start * u,
            _ = i.drawRange.count * u,
            v = null !== r ? r.start * u : 0,
            x = null !== r ? r.count * u : 1 / 0,
            y = Math.max(g, v),
            M = Math.min(p, g + _, v + x) - 1,
            b = Math.max(0, M - y + 1);
          if (0 !== b) {
            if (s.isMesh)
              !0 === n.wireframe ? (J.setLineWidth(n.wireframeLinewidth * q()), m.setMode(1)) : m.setMode(4);
            else if (s.isLine) {
              let e = n.linewidth;
              void 0 === e && (e = 1),
                J.setLineWidth(e * q()),
                s.isLineSegments ? m.setMode(1) : s.isLineLoop ? m.setMode(2) : m.setMode(3);
            } else s.isPoints ? m.setMode(0) : s.isSprite && m.setMode(4);
            if (s.isInstancedMesh) m.renderInstances(y, b, s.count);
            else if (i.isInstancedBufferGeometry) {
              const e = Math.min(i.instanceCount, i._maxInstanceCount);
              m.renderInstances(y, b, e);
            } else m.render(y, b);
          }
        }),
        (this.compile = function (e, t) {
          (d = ue.get(e)),
            d.init(),
            p.push(d),
            e.traverseVisible(function (e) {
              e.isLight && e.layers.test(t.layers) && (d.pushLight(e), e.castShadow && d.pushShadow(e));
            }),
            d.setupLights(f.physicallyCorrectLights),
            e.traverse(function (t) {
              const i = t.material;
              if (i)
                if (Array.isArray(i))
                  for (let n = 0; n < i.length; n++) {
                    Ue(i[n], e, t);
                  }
                else Ue(i, e, t);
            }),
            p.pop(),
            (d = null);
        });
      let De = null;
      function Ie() {
        Oe.stop();
      }
      function Re() {
        Oe.start();
      }
      const Oe = new ji();
      function Ne(e, t, i, n) {
        if (!1 === e.visible) return;
        if (e.layers.test(t.layers))
          if (e.isGroup) i = e.renderOrder;
          else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
          else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);
          else if (e.isSprite) {
            if (!e.frustumCulled || U.intersectsSprite(e)) {
              n && W.setFromMatrixPosition(e.matrixWorld).applyMatrix4(H);
              const t = ae.update(e),
                s = e.material;
              s.visible && u.push(e, t, s, i, W.z, null);
            }
          } else if (
            (e.isMesh || e.isLine || e.isPoints) &&
            (e.isSkinnedMesh &&
              e.skeleton.frame !== K.render.frame &&
              (e.skeleton.update(), (e.skeleton.frame = K.render.frame)),
            !e.frustumCulled || U.intersectsObject(e))
          ) {
            n && W.setFromMatrixPosition(e.matrixWorld).applyMatrix4(H);
            const t = ae.update(e),
              s = e.material;
            if (Array.isArray(s)) {
              const n = t.groups;
              for (let r = 0, a = n.length; r < a; r++) {
                const a = n[r],
                  o = s[a.materialIndex];
                o && o.visible && u.push(e, t, o, i, W.z, a);
              }
            } else s.visible && u.push(e, t, s, i, W.z, null);
          }
        const s = e.children;
        for (let e = 0, r = s.length; e < r; e++) Ne(s[e], t, i, n);
      }
      function ze(e, t, i, n) {
        const s = e.opaque,
          a = e.transmissive,
          o = e.transparent;
        d.setupLightsView(i),
          a.length > 0 &&
            (function (e, t, i) {
              const n = Z.isWebGL2;
              null === V &&
                (V = new Te(1, 1, {
                  generateMipmaps: !0,
                  type: Y.has('EXT_color_buffer_half_float') ? b : x,
                  minFilter: v,
                  samples: n && !0 === r ? 4 : 0,
                }));
              f.getDrawingBufferSize(j), n ? V.setSize(j.x, j.y) : V.setSize(ie(j.x), ie(j.y));
              const s = f.getRenderTarget();
              f.setRenderTarget(V), f.clear();
              const a = f.toneMapping;
              (f.toneMapping = 0),
                Fe(e, t, i),
                (f.toneMapping = a),
                Q.updateMultisampleRenderTarget(V),
                Q.updateRenderTargetMipmap(V),
                f.setRenderTarget(s);
            })(s, t, i),
          n && J.viewport(E.copy(n)),
          s.length > 0 && Fe(s, t, i),
          a.length > 0 && Fe(a, t, i),
          o.length > 0 && Fe(o, t, i),
          J.buffers.depth.setTest(!0),
          J.buffers.depth.setMask(!0),
          J.buffers.color.setMask(!0),
          J.setPolygonOffset(!1);
      }
      function Fe(e, t, i) {
        const n = !0 === t.isScene ? t.overrideMaterial : null;
        for (let s = 0, r = e.length; s < r; s++) {
          const r = e[s],
            a = r.object,
            o = r.geometry,
            l = null === n ? r.material : n,
            h = r.group;
          a.layers.test(i.layers) && ke(a, t, i, o, l, h);
        }
      }
      function ke(e, t, i, n, s, r) {
        e.onBeforeRender(f, t, i, n, s, r),
          e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld),
          e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
          s.onBeforeRender(f, t, i, n, e, r),
          !0 === s.transparent && 2 === s.side
            ? ((s.side = 1),
              (s.needsUpdate = !0),
              f.renderBufferDirect(i, t, n, s, e, r),
              (s.side = 0),
              (s.needsUpdate = !0),
              f.renderBufferDirect(i, t, n, s, e, r),
              (s.side = 2))
            : f.renderBufferDirect(i, t, n, s, e, r),
          e.onAfterRender(f, t, i, n, s, r);
      }
      function Ue(e, t, i) {
        !0 !== t.isScene && (t = X);
        const n = $.get(e),
          s = d.state.lights,
          r = d.state.shadowsArray,
          a = s.state.version,
          o = le.getParameters(e, s.state, r, t, i),
          l = le.getProgramCacheKey(o);
        let h = n.programs;
        (n.environment = e.isMeshStandardMaterial ? t.environment : null),
          (n.fog = t.fog),
          (n.envMap = (e.isMeshStandardMaterial ? te : ee).get(e.envMap || n.environment)),
          void 0 === h && (e.addEventListener('dispose', Ce), (h = new Map()), (n.programs = h));
        let c = h.get(l);
        if (void 0 !== c) {
          if (n.currentProgram === c && n.lightsStateVersion === a) return Be(e, o), c;
        } else
          (o.uniforms = le.getUniforms(e)),
            e.onBuild(i, o, f),
            e.onBeforeCompile(o, f),
            (c = le.acquireProgram(o, l)),
            h.set(l, c),
            (n.uniforms = o.uniforms);
        const u = n.uniforms;
        ((e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping) || (u.clippingPlanes = de.uniform),
          Be(e, o),
          (n.needsLights = (function (e) {
            return (
              e.isMeshLambertMaterial ||
              e.isMeshToonMaterial ||
              e.isMeshPhongMaterial ||
              e.isMeshStandardMaterial ||
              e.isShadowMaterial ||
              (e.isShaderMaterial && !0 === e.lights)
            );
          })(e)),
          (n.lightsStateVersion = a),
          n.needsLights &&
            ((u.ambientLightColor.value = s.state.ambient),
            (u.lightProbe.value = s.state.probe),
            (u.directionalLights.value = s.state.directional),
            (u.directionalLightShadows.value = s.state.directionalShadow),
            (u.spotLights.value = s.state.spot),
            (u.spotLightShadows.value = s.state.spotShadow),
            (u.rectAreaLights.value = s.state.rectArea),
            (u.ltc_1.value = s.state.rectAreaLTC1),
            (u.ltc_2.value = s.state.rectAreaLTC2),
            (u.pointLights.value = s.state.point),
            (u.pointLightShadows.value = s.state.pointShadow),
            (u.hemisphereLights.value = s.state.hemi),
            (u.directionalShadowMap.value = s.state.directionalShadowMap),
            (u.directionalShadowMatrix.value = s.state.directionalShadowMatrix),
            (u.spotShadowMap.value = s.state.spotShadowMap),
            (u.spotShadowMatrix.value = s.state.spotShadowMatrix),
            (u.pointShadowMap.value = s.state.pointShadowMap),
            (u.pointShadowMatrix.value = s.state.pointShadowMatrix));
        const m = c.getUniforms(),
          p = Ds.seqWithValue(m.seq, u);
        return (n.currentProgram = c), (n.uniformsList = p), c;
      }
      function Be(e, t) {
        const i = $.get(e);
        (i.outputEncoding = t.outputEncoding),
          (i.instancing = t.instancing),
          (i.skinning = t.skinning),
          (i.morphTargets = t.morphTargets),
          (i.morphNormals = t.morphNormals),
          (i.morphColors = t.morphColors),
          (i.morphTargetsCount = t.morphTargetsCount),
          (i.numClippingPlanes = t.numClippingPlanes),
          (i.numIntersection = t.numClipIntersection),
          (i.vertexAlphas = t.vertexAlphas),
          (i.vertexTangents = t.vertexTangents),
          (i.toneMapping = t.toneMapping);
      }
      Oe.setAnimationLoop(function (e) {
        De && De(e);
      }),
        'undefined' != typeof self && Oe.setContext(self),
        (this.setAnimationLoop = function (e) {
          (De = e), Se.setAnimationLoop(e), null === e ? Oe.stop() : Oe.start();
        }),
        Se.addEventListener('sessionstart', Ie),
        Se.addEventListener('sessionend', Re),
        (this.render = function (e, t) {
          if (void 0 !== t && !0 !== t.isCamera) return;
          if (!0 === g) return;
          !0 === e.autoUpdate && e.updateMatrixWorld(),
            null === t.parent && t.updateMatrixWorld(),
            !0 === Se.enabled &&
              !0 === Se.isPresenting &&
              (!0 === Se.cameraAutoUpdate && Se.updateCamera(t), (t = Se.getCamera())),
            !0 === e.isScene && e.onBeforeRender(f, e, t, S),
            (d = ue.get(e, p.length)),
            d.init(),
            p.push(d),
            H.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            U.setFromProjectionMatrix(H),
            (G = this.localClippingEnabled),
            (B = de.init(this.clippingPlanes, G, t)),
            (u = ce.get(e, m.length)),
            u.init(),
            m.push(u),
            Ne(e, t, 0, f.sortObjects),
            u.finish(),
            !0 === f.sortObjects && u.sort(R, O),
            !0 === B && de.beginShadows();
          const i = d.state.shadowsArray;
          if (
            (me.render(i, e, t),
            !0 === B && de.endShadows(),
            !0 === this.info.autoReset && this.info.reset(),
            pe.render(u, e),
            d.setupLights(f.physicallyCorrectLights),
            t.isArrayCamera)
          ) {
            const i = t.cameras;
            for (let t = 0, n = i.length; t < n; t++) {
              const n = i[t];
              ze(u, e, n, n.viewport);
            }
          } else ze(u, e, t);
          null !== S && (Q.updateMultisampleRenderTarget(S), Q.updateRenderTargetMipmap(S)),
            !0 === e.isScene && e.onAfterRender(f, e, t),
            xe.resetDefaultState(),
            (A = -1),
            (T = null),
            p.pop(),
            (d = p.length > 0 ? p[p.length - 1] : null),
            m.pop(),
            (u = m.length > 0 ? m[m.length - 1] : null);
        }),
        (this.getActiveCubeFace = function () {
          return _;
        }),
        (this.getActiveMipmapLevel = function () {
          return y;
        }),
        (this.getRenderTarget = function () {
          return S;
        }),
        (this.setRenderTargetTextures = function (e, t, i) {
          ($.get(e.texture).__webglTexture = t), ($.get(e.depthTexture).__webglTexture = i);
          const n = $.get(e);
          (n.__hasExternalTextures = !0),
            n.__hasExternalTextures &&
              ((n.__autoAllocateDepthBuffer = void 0 === i),
              n.__autoAllocateDepthBuffer ||
                (!0 === Y.has('WEBGL_multisampled_render_to_texture') && (n.__useRenderToTexture = !1)));
        }),
        (this.setRenderTargetFramebuffer = function (e, t) {
          const i = $.get(e);
          (i.__webglFramebuffer = t), (i.__useDefaultFramebuffer = void 0 === t);
        }),
        (this.setRenderTarget = function (e, t = 0, i = 0) {
          (S = e), (_ = t), (y = i);
          let n = !0;
          if (e) {
            const t = $.get(e);
            void 0 !== t.__useDefaultFramebuffer
              ? (J.bindFramebuffer(36160, null), (n = !1))
              : void 0 === t.__webglFramebuffer
              ? Q.setupRenderTarget(e)
              : t.__hasExternalTextures &&
                Q.rebindTextures(e, $.get(e.texture).__webglTexture, $.get(e.depthTexture).__webglTexture);
          }
          let s = null,
            r = !1,
            a = !1;
          if (e) {
            const i = e.texture;
            (i.isData3DTexture || i.isDataArrayTexture) && (a = !0);
            const n = $.get(e).__webglFramebuffer;
            e.isWebGLCubeRenderTarget
              ? ((s = n[t]), (r = !0))
              : (s =
                  Z.isWebGL2 && e.samples > 0 && !1 === Q.useMultisampledRTT(e)
                    ? $.get(e).__webglMultisampledFramebuffer
                    : n),
              E.copy(e.viewport),
              L.copy(e.scissor),
              (C = e.scissorTest);
          } else E.copy(N).multiplyScalar(I).floor(), L.copy(z).multiplyScalar(I).floor(), (C = k);
          if (
            (J.bindFramebuffer(36160, s) && Z.drawBuffers && n && J.drawBuffers(e, s),
            J.viewport(E),
            J.scissor(L),
            J.setScissorTest(C),
            r)
          ) {
            const n = $.get(e.texture);
            ye.framebufferTexture2D(36160, 36064, 34069 + t, n.__webglTexture, i);
          } else if (a) {
            const n = $.get(e.texture),
              s = t || 0;
            ye.framebufferTextureLayer(36160, 36064, n.__webglTexture, i || 0, s);
          }
          A = -1;
        }),
        (this.readRenderTargetPixels = function (e, t, i, n, s, r, a) {
          if (!e || !e.isWebGLRenderTarget) return;
          let o = $.get(e).__webglFramebuffer;
          if ((e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
            J.bindFramebuffer(36160, o);
            try {
              const a = e.texture,
                o = a.format,
                l = a.type;
              if (o !== w && ve.convert(o) !== ye.getParameter(35739)) return;
              const h =
                l === b && (Y.has('EXT_color_buffer_half_float') || (Z.isWebGL2 && Y.has('EXT_color_buffer_float')));
              if (
                !(
                  l === x ||
                  ve.convert(l) === ye.getParameter(35738) ||
                  (l === M && (Z.isWebGL2 || Y.has('OES_texture_float') || Y.has('WEBGL_color_buffer_float'))) ||
                  h
                )
              )
                return;
              t >= 0 &&
                t <= e.width - n &&
                i >= 0 &&
                i <= e.height - s &&
                ye.readPixels(t, i, n, s, ve.convert(o), ve.convert(l), r);
            } finally {
              const e = null !== S ? $.get(S).__webglFramebuffer : null;
              J.bindFramebuffer(36160, e);
            }
          }
        }),
        (this.copyFramebufferToTexture = function (e, t, i = 0) {
          const n = Math.pow(2, -i),
            s = Math.floor(t.image.width * n),
            r = Math.floor(t.image.height * n);
          Q.setTexture2D(t, 0), ye.copyTexSubImage2D(3553, i, 0, 0, e.x, e.y, s, r), J.unbindTexture();
        }),
        (this.copyTextureToTexture = function (e, t, i, n = 0) {
          const s = t.image.width,
            r = t.image.height,
            a = ve.convert(i.format),
            o = ve.convert(i.type);
          Q.setTexture2D(i, 0),
            ye.pixelStorei(37440, i.flipY),
            ye.pixelStorei(37441, i.premultiplyAlpha),
            ye.pixelStorei(3317, i.unpackAlignment),
            t.isDataTexture
              ? ye.texSubImage2D(3553, n, e.x, e.y, s, r, a, o, t.image.data)
              : t.isCompressedTexture
              ? ye.compressedTexSubImage2D(
                  3553,
                  n,
                  e.x,
                  e.y,
                  t.mipmaps[0].width,
                  t.mipmaps[0].height,
                  a,
                  t.mipmaps[0].data,
                )
              : ye.texSubImage2D(3553, n, e.x, e.y, a, o, t.image),
            0 === n && i.generateMipmaps && ye.generateMipmap(3553),
            J.unbindTexture();
        }),
        (this.copyTextureToTexture3D = function (e, t, i, n, s = 0) {
          if (f.isWebGL1Renderer) return;
          const r = e.max.x - e.min.x + 1,
            a = e.max.y - e.min.y + 1,
            o = e.max.z - e.min.z + 1,
            l = ve.convert(n.format),
            h = ve.convert(n.type);
          let c;
          if (n.isData3DTexture) Q.setTexture3D(n, 0), (c = 32879);
          else {
            if (!n.isDataArrayTexture) return;
            Q.setTexture2DArray(n, 0), (c = 35866);
          }
          ye.pixelStorei(37440, n.flipY),
            ye.pixelStorei(37441, n.premultiplyAlpha),
            ye.pixelStorei(3317, n.unpackAlignment);
          const u = ye.getParameter(3314),
            d = ye.getParameter(32878),
            m = ye.getParameter(3316),
            p = ye.getParameter(3315),
            g = ye.getParameter(32877),
            _ = i.isCompressedTexture ? i.mipmaps[0] : i.image;
          ye.pixelStorei(3314, _.width),
            ye.pixelStorei(32878, _.height),
            ye.pixelStorei(3316, e.min.x),
            ye.pixelStorei(3315, e.min.y),
            ye.pixelStorei(32877, e.min.z),
            i.isDataTexture || i.isData3DTexture
              ? ye.texSubImage3D(c, s, t.x, t.y, t.z, r, a, o, l, h, _.data)
              : i.isCompressedTexture
              ? ye.compressedTexSubImage3D(c, s, t.x, t.y, t.z, r, a, o, l, _.data)
              : ye.texSubImage3D(c, s, t.x, t.y, t.z, r, a, o, l, h, _),
            ye.pixelStorei(3314, u),
            ye.pixelStorei(32878, d),
            ye.pixelStorei(3316, m),
            ye.pixelStorei(3315, p),
            ye.pixelStorei(32877, g),
            0 === s && n.generateMipmaps && ye.generateMipmap(c),
            J.unbindTexture();
        }),
        (this.initTexture = function (e) {
          e.isCubeTexture
            ? Q.setTextureCube(e, 0)
            : e.isData3DTexture
            ? Q.setTexture3D(e, 0)
            : e.isDataArrayTexture
            ? Q.setTexture2DArray(e, 0)
            : Q.setTexture2D(e, 0),
            J.unbindTexture();
        }),
        (this.resetState = function () {
          (_ = 0), (y = 0), (S = null), J.reset(), xe.reset();
        }),
        'undefined' != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
    }
    (class extends wr {}).prototype.isWebGL1Renderer = !0;
    class Ar extends It {
      constructor() {
        super(),
          (this.isScene = !0),
          (this.type = 'Scene'),
          (this.background = null),
          (this.environment = null),
          (this.fog = null),
          (this.overrideMaterial = null),
          (this.autoUpdate = !0),
          'undefined' != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          null !== e.background && (this.background = e.background.clone()),
          null !== e.environment && (this.environment = e.environment.clone()),
          null !== e.fog && (this.fog = e.fog.clone()),
          null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
          (this.autoUpdate = e.autoUpdate),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          this
        );
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return null !== this.fog && (t.object.fog = this.fog.toJSON()), t;
      }
    }
    class Tr {
      constructor(e, t) {
        (this.isInterleavedBuffer = !0),
          (this.array = e),
          (this.stride = t),
          (this.count = void 0 !== e ? e.length / t : 0),
          (this.usage = V),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0),
          (this.uuid = J());
      }
      onUploadCallback() {}
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
      setUsage(e) {
        return (this.usage = e), this;
      }
      copy(e) {
        return (
          (this.array = new e.array.constructor(e.array)),
          (this.count = e.count),
          (this.stride = e.stride),
          (this.usage = e.usage),
          this
        );
      }
      copyAt(e, t, i) {
        (e *= this.stride), (i *= t.stride);
        for (let n = 0, s = this.stride; n < s; n++) this.array[e + n] = t.array[i + n];
        return this;
      }
      set(e, t = 0) {
        return this.array.set(e, t), this;
      }
      clone(e) {
        void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
          void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = J()),
          void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
            (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
          i = new this.constructor(t, this.stride);
        return i.setUsage(this.usage), i;
      }
      onUpload(e) {
        return (this.onUploadCallback = e), this;
      }
      toJSON(e) {
        return (
          void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
          void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = J()),
          void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
            (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
          { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride }
        );
      }
    }
    const Er = new Pe();
    class Lr {
      constructor(e, t, i, n = !1) {
        (this.isInterleavedBufferAttribute = !0),
          (this.name = ''),
          (this.data = e),
          (this.itemSize = t),
          (this.offset = i),
          (this.normalized = !0 === n);
      }
      get count() {
        return this.data.count;
      }
      get array() {
        return this.data.array;
      }
      set needsUpdate(e) {
        this.data.needsUpdate = e;
      }
      applyMatrix4(e) {
        for (let t = 0, i = this.data.count; t < i; t++)
          Er.fromBufferAttribute(this, t), Er.applyMatrix4(e), this.setXYZ(t, Er.x, Er.y, Er.z);
        return this;
      }
      applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
          Er.fromBufferAttribute(this, t), Er.applyNormalMatrix(e), this.setXYZ(t, Er.x, Er.y, Er.z);
        return this;
      }
      transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
          Er.fromBufferAttribute(this, t), Er.transformDirection(e), this.setXYZ(t, Er.x, Er.y, Er.z);
        return this;
      }
      setX(e, t) {
        return (this.data.array[e * this.data.stride + this.offset] = t), this;
      }
      setY(e, t) {
        return (this.data.array[e * this.data.stride + this.offset + 1] = t), this;
      }
      setZ(e, t) {
        return (this.data.array[e * this.data.stride + this.offset + 2] = t), this;
      }
      setW(e, t) {
        return (this.data.array[e * this.data.stride + this.offset + 3] = t), this;
      }
      getX(e) {
        return this.data.array[e * this.data.stride + this.offset];
      }
      getY(e) {
        return this.data.array[e * this.data.stride + this.offset + 1];
      }
      getZ(e) {
        return this.data.array[e * this.data.stride + this.offset + 2];
      }
      getW(e) {
        return this.data.array[e * this.data.stride + this.offset + 3];
      }
      setXY(e, t, i) {
        return (
          (e = e * this.data.stride + this.offset), (this.data.array[e + 0] = t), (this.data.array[e + 1] = i), this
        );
      }
      setXYZ(e, t, i, n) {
        return (
          (e = e * this.data.stride + this.offset),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = i),
          (this.data.array[e + 2] = n),
          this
        );
      }
      setXYZW(e, t, i, n, s) {
        return (
          (e = e * this.data.stride + this.offset),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = i),
          (this.data.array[e + 2] = n),
          (this.data.array[e + 3] = s),
          this
        );
      }
      clone(e) {
        if (void 0 === e) {
          const e = [];
          for (let t = 0; t < this.count; t++) {
            const i = t * this.data.stride + this.offset;
            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[i + t]);
          }
          return new Zt(new this.array.constructor(e), this.itemSize, this.normalized);
        }
        return (
          void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
          void 0 === e.interleavedBuffers[this.data.uuid] &&
            (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
          new Lr(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
        );
      }
      toJSON(e) {
        if (void 0 === e) {
          const e = [];
          for (let t = 0; t < this.count; t++) {
            const i = t * this.data.stride + this.offset;
            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[i + t]);
          }
          return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized };
        }
        return (
          void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
          void 0 === e.interleavedBuffers[this.data.uuid] &&
            (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
          {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized,
          }
        );
      }
    }
    class Cr extends Wt {
      constructor(e) {
        super(),
          (this.isSpriteMaterial = !0),
          (this.type = 'SpriteMaterial'),
          (this.color = new ve(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.rotation = 0),
          (this.sizeAttenuation = !0),
          (this.transparent = !0),
          (this.fog = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.rotation = e.rotation),
          (this.sizeAttenuation = e.sizeAttenuation),
          (this.fog = e.fog),
          this
        );
      }
    }
    let Pr;
    const Dr = new Pe(),
      Ir = new Pe(),
      Rr = new Pe(),
      Or = new se(),
      Nr = new se(),
      zr = new ot(),
      Fr = new Pe(),
      kr = new Pe(),
      Ur = new Pe(),
      Br = new se(),
      Gr = new se(),
      Vr = new se();
    class Hr extends It {
      constructor(e) {
        if ((super(), (this.isSprite = !0), (this.type = 'Sprite'), void 0 === Pr)) {
          Pr = new ai();
          const e = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]),
            t = new Tr(e, 5);
          Pr.setIndex([0, 1, 2, 0, 2, 3]),
            Pr.setAttribute('position', new Lr(t, 3, 0, !1)),
            Pr.setAttribute('uv', new Lr(t, 2, 3, !1));
        }
        (this.geometry = Pr), (this.material = void 0 !== e ? e : new Cr()), (this.center = new se(0.5, 0.5));
      }
      raycast(e, t) {
        e.camera,
          Ir.setFromMatrixScale(this.matrixWorld),
          zr.copy(e.camera.matrixWorld),
          this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
          Rr.setFromMatrixPosition(this.modelViewMatrix),
          e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Ir.multiplyScalar(-Rr.z);
        const i = this.material.rotation;
        let n, s;
        0 !== i && ((s = Math.cos(i)), (n = Math.sin(i)));
        const r = this.center;
        jr(Fr.set(-0.5, -0.5, 0), Rr, r, Ir, n, s),
          jr(kr.set(0.5, -0.5, 0), Rr, r, Ir, n, s),
          jr(Ur.set(0.5, 0.5, 0), Rr, r, Ir, n, s),
          Br.set(0, 0),
          Gr.set(1, 0),
          Vr.set(1, 1);
        let a = e.ray.intersectTriangle(Fr, kr, Ur, !1, Dr);
        if (
          null === a &&
          (jr(kr.set(-0.5, 0.5, 0), Rr, r, Ir, n, s),
          Gr.set(0, 1),
          (a = e.ray.intersectTriangle(Fr, Ur, kr, !1, Dr)),
          null === a)
        )
          return;
        const o = e.ray.origin.distanceTo(Dr);
        o < e.near ||
          o > e.far ||
          t.push({
            distance: o,
            point: Dr.clone(),
            uv: Ht.getUV(Dr, Fr, kr, Ur, Br, Gr, Vr, new se()),
            face: null,
            object: this,
          });
      }
      copy(e, t) {
        return super.copy(e, t), void 0 !== e.center && this.center.copy(e.center), (this.material = e.material), this;
      }
    }
    function jr(e, t, i, n, s, r) {
      Or.subVectors(e, i).addScalar(0.5).multiply(n),
        void 0 !== s ? ((Nr.x = r * Or.x - s * Or.y), (Nr.y = s * Or.x + r * Or.y)) : Nr.copy(Or),
        e.copy(t),
        (e.x += Nr.x),
        (e.y += Nr.y),
        e.applyMatrix4(zr);
    }
    const Wr = new Pe(),
      Xr = new Ae(),
      qr = new Ae(),
      Yr = new Pe(),
      Zr = new ot();
    class Jr extends wi {
      constructor(e, t) {
        super(e, t),
          (this.isSkinnedMesh = !0),
          (this.type = 'SkinnedMesh'),
          (this.bindMode = 'attached'),
          (this.bindMatrix = new ot()),
          (this.bindMatrixInverse = new ot());
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.bindMode = e.bindMode),
          this.bindMatrix.copy(e.bindMatrix),
          this.bindMatrixInverse.copy(e.bindMatrixInverse),
          (this.skeleton = e.skeleton),
          this
        );
      }
      bind(e, t) {
        (this.skeleton = e),
          void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), (t = this.matrixWorld)),
          this.bindMatrix.copy(t),
          this.bindMatrixInverse.copy(t).invert();
      }
      pose() {
        this.skeleton.pose();
      }
      normalizeSkinWeights() {
        const e = new Ae(),
          t = this.geometry.attributes.skinWeight;
        for (let i = 0, n = t.count; i < n; i++) {
          e.fromBufferAttribute(t, i);
          const n = 1 / e.manhattanLength();
          n !== 1 / 0 ? e.multiplyScalar(n) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
        }
      }
      updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
          'attached' === this.bindMode
            ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
            : 'detached' === this.bindMode && this.bindMatrixInverse.copy(this.bindMatrix).invert();
      }
      boneTransform(e, t) {
        const i = this.skeleton,
          n = this.geometry;
        Xr.fromBufferAttribute(n.attributes.skinIndex, e),
          qr.fromBufferAttribute(n.attributes.skinWeight, e),
          Wr.copy(t).applyMatrix4(this.bindMatrix),
          t.set(0, 0, 0);
        for (let e = 0; e < 4; e++) {
          const n = qr.getComponent(e);
          if (0 !== n) {
            const s = Xr.getComponent(e);
            Zr.multiplyMatrices(i.bones[s].matrixWorld, i.boneInverses[s]),
              t.addScaledVector(Yr.copy(Wr).applyMatrix4(Zr), n);
          }
        }
        return t.applyMatrix4(this.bindMatrixInverse);
      }
    }
    class Kr extends It {
      constructor() {
        super(), (this.isBone = !0), (this.type = 'Bone');
      }
    }
    class $r extends we {
      constructor(e = null, t = 1, i = 1, n, s, r, a, o, l = 1003, h = 1003, c, u) {
        super(null, r, a, o, l, h, n, s, c, u),
          (this.isDataTexture = !0),
          (this.image = { data: e, width: t, height: i }),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1);
      }
    }
    const Qr = new ot(),
      ea = new ot();
    class ta {
      constructor(e = [], t = []) {
        (this.uuid = J()),
          (this.bones = e.slice(0)),
          (this.boneInverses = t),
          (this.boneMatrices = null),
          (this.boneTexture = null),
          (this.boneTextureSize = 0),
          (this.frame = -1),
          this.init();
      }
      init() {
        const e = this.bones,
          t = this.boneInverses;
        if (((this.boneMatrices = new Float32Array(16 * e.length)), 0 === t.length)) this.calculateInverses();
        else if (e.length !== t.length) {
          this.boneInverses = [];
          for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new ot());
        }
      }
      calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = new ot();
          this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t);
        }
      }
      pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = this.bones[e];
          t && t.matrixWorld.copy(this.boneInverses[e]).invert();
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = this.bones[e];
          t &&
            (t.parent && t.parent.isBone
              ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld))
              : t.matrix.copy(t.matrixWorld),
            t.matrix.decompose(t.position, t.quaternion, t.scale));
        }
      }
      update() {
        const e = this.bones,
          t = this.boneInverses,
          i = this.boneMatrices,
          n = this.boneTexture;
        for (let n = 0, s = e.length; n < s; n++) {
          const s = e[n] ? e[n].matrixWorld : ea;
          Qr.multiplyMatrices(s, t[n]), Qr.toArray(i, 16 * n);
        }
        null !== n && (n.needsUpdate = !0);
      }
      clone() {
        return new ta(this.bones, this.boneInverses);
      }
      computeBoneTexture() {
        let e = Math.sqrt(4 * this.bones.length);
        (e = te(e)), (e = Math.max(e, 4));
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const i = new $r(t, e, e, w, M);
        return (i.needsUpdate = !0), (this.boneMatrices = t), (this.boneTexture = i), (this.boneTextureSize = e), this;
      }
      getBoneByName(e) {
        for (let t = 0, i = this.bones.length; t < i; t++) {
          const i = this.bones[t];
          if (i.name === e) return i;
        }
      }
      dispose() {
        null !== this.boneTexture && (this.boneTexture.dispose(), (this.boneTexture = null));
      }
      fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let i = 0, n = e.bones.length; i < n; i++) {
          let n = t[e.bones[i]];
          void 0 === n && (n = new Kr()),
            this.bones.push(n),
            this.boneInverses.push(new ot().fromArray(e.boneInverses[i]));
        }
        return this.init(), this;
      }
      toJSON() {
        const e = {
          metadata: { version: 4.5, type: 'Skeleton', generator: 'Skeleton.toJSON' },
          bones: [],
          boneInverses: [],
        };
        e.uuid = this.uuid;
        const t = this.bones,
          i = this.boneInverses;
        for (let n = 0, s = t.length; n < s; n++) {
          const s = t[n];
          e.bones.push(s.uuid);
          const r = i[n];
          e.boneInverses.push(r.toArray());
        }
        return e;
      }
    }
    class ia extends Zt {
      constructor(e, t, i, n = 1) {
        'number' == typeof i && ((n = i), (i = !1)),
          super(e, t, i),
          (this.isInstancedBufferAttribute = !0),
          (this.meshPerAttribute = n);
      }
      copy(e) {
        return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
      }
      toJSON() {
        const e = super.toJSON();
        return (e.meshPerAttribute = this.meshPerAttribute), (e.isInstancedBufferAttribute = !0), e;
      }
    }
    const na = new ot(),
      sa = new ot(),
      ra = [],
      aa = new wi();
    class oa extends wi {
      constructor(e, t, i) {
        super(e, t),
          (this.isInstancedMesh = !0),
          (this.instanceMatrix = new ia(new Float32Array(16 * i), 16)),
          (this.instanceColor = null),
          (this.count = i),
          (this.frustumCulled = !1);
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          this.instanceMatrix.copy(e.instanceMatrix),
          null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()),
          (this.count = e.count),
          this
        );
      }
      getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, 3 * e);
      }
      getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, 16 * e);
      }
      raycast(e, t) {
        const i = this.matrixWorld,
          n = this.count;
        if (((aa.geometry = this.geometry), (aa.material = this.material), void 0 !== aa.material))
          for (let s = 0; s < n; s++) {
            this.getMatrixAt(s, na), sa.multiplyMatrices(i, na), (aa.matrixWorld = sa), aa.raycast(e, ra);
            for (let e = 0, i = ra.length; e < i; e++) {
              const i = ra[e];
              (i.instanceId = s), (i.object = this), t.push(i);
            }
            ra.length = 0;
          }
      }
      setColorAt(e, t) {
        null === this.instanceColor &&
          (this.instanceColor = new ia(new Float32Array(3 * this.instanceMatrix.count), 3)),
          t.toArray(this.instanceColor.array, 3 * e);
      }
      setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, 16 * e);
      }
      updateMorphTargets() {}
      dispose() {
        this.dispatchEvent({ type: 'dispose' });
      }
    }
    class la extends Wt {
      constructor(e) {
        super(),
          (this.isLineBasicMaterial = !0),
          (this.type = 'LineBasicMaterial'),
          (this.color = new ve(16777215)),
          (this.linewidth = 1),
          (this.linecap = 'round'),
          (this.linejoin = 'round'),
          (this.fog = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.linewidth = e.linewidth),
          (this.linecap = e.linecap),
          (this.linejoin = e.linejoin),
          (this.fog = e.fog),
          this
        );
      }
    }
    const ha = new Pe(),
      ca = new Pe(),
      ua = new ot(),
      da = new at(),
      ma = new $e();
    class pa extends It {
      constructor(e = new ai(), t = new la()) {
        super(),
          (this.isLine = !0),
          (this.type = 'Line'),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e, t) {
        return super.copy(e, t), (this.material = e.material), (this.geometry = e.geometry), this;
      }
      computeLineDistances() {
        const e = this.geometry;
        if (null === e.index) {
          const t = e.attributes.position,
            i = [0];
          for (let e = 1, n = t.count; e < n; e++)
            ha.fromBufferAttribute(t, e - 1),
              ca.fromBufferAttribute(t, e),
              (i[e] = i[e - 1]),
              (i[e] += ha.distanceTo(ca));
          e.setAttribute('lineDistance', new $t(i, 1));
        }
        return this;
      }
      raycast(e, t) {
        const i = this.geometry,
          n = this.matrixWorld,
          s = e.params.Line.threshold,
          r = i.drawRange;
        if (
          (null === i.boundingSphere && i.computeBoundingSphere(),
          ma.copy(i.boundingSphere),
          ma.applyMatrix4(n),
          (ma.radius += s),
          !1 === e.ray.intersectsSphere(ma))
        )
          return;
        ua.copy(n).invert(), da.copy(e.ray).applyMatrix4(ua);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          o = a * a,
          l = new Pe(),
          h = new Pe(),
          c = new Pe(),
          u = new Pe(),
          d = this.isLineSegments ? 2 : 1,
          m = i.index,
          p = i.attributes.position;
        if (null !== m) {
          for (let i = Math.max(0, r.start), n = Math.min(m.count, r.start + r.count) - 1; i < n; i += d) {
            const n = m.getX(i),
              s = m.getX(i + 1);
            l.fromBufferAttribute(p, n), h.fromBufferAttribute(p, s);
            if (da.distanceSqToSegment(l, h, u, c) > o) continue;
            u.applyMatrix4(this.matrixWorld);
            const r = e.ray.origin.distanceTo(u);
            r < e.near ||
              r > e.far ||
              t.push({
                distance: r,
                point: c.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this,
              });
          }
        } else {
          for (let i = Math.max(0, r.start), n = Math.min(p.count, r.start + r.count) - 1; i < n; i += d) {
            l.fromBufferAttribute(p, i), h.fromBufferAttribute(p, i + 1);
            if (da.distanceSqToSegment(l, h, u, c) > o) continue;
            u.applyMatrix4(this.matrixWorld);
            const n = e.ray.origin.distanceTo(u);
            n < e.near ||
              n > e.far ||
              t.push({
                distance: n,
                point: c.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this,
              });
          }
        }
      }
      updateMorphTargets() {
        const e = this.geometry.morphAttributes,
          t = Object.keys(e);
        if (t.length > 0) {
          const i = e[t[0]];
          if (void 0 !== i) {
            (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
            for (let e = 0, t = i.length; e < t; e++) {
              const t = i[e].name || String(e);
              this.morphTargetInfluences.push(0), (this.morphTargetDictionary[t] = e);
            }
          }
        }
      }
    }
    const fa = new Pe(),
      ga = new Pe();
    class _a extends pa {
      constructor(e, t) {
        super(e, t), (this.isLineSegments = !0), (this.type = 'LineSegments');
      }
      computeLineDistances() {
        const e = this.geometry;
        if (null === e.index) {
          const t = e.attributes.position,
            i = [];
          for (let e = 0, n = t.count; e < n; e += 2)
            fa.fromBufferAttribute(t, e),
              ga.fromBufferAttribute(t, e + 1),
              (i[e] = 0 === e ? 0 : i[e - 1]),
              (i[e + 1] = i[e] + fa.distanceTo(ga));
          e.setAttribute('lineDistance', new $t(i, 1));
        }
        return this;
      }
    }
    class va extends pa {
      constructor(e, t) {
        super(e, t), (this.isLineLoop = !0), (this.type = 'LineLoop');
      }
    }
    class xa extends Wt {
      constructor(e) {
        super(),
          (this.isPointsMaterial = !0),
          (this.type = 'PointsMaterial'),
          (this.color = new ve(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.size = 1),
          (this.sizeAttenuation = !0),
          (this.fog = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.size = e.size),
          (this.sizeAttenuation = e.sizeAttenuation),
          (this.fog = e.fog),
          this
        );
      }
    }
    const ya = new ot(),
      Ma = new at(),
      ba = new $e(),
      Sa = new Pe();
    class wa extends It {
      constructor(e = new ai(), t = new xa()) {
        super(),
          (this.isPoints = !0),
          (this.type = 'Points'),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e, t) {
        return super.copy(e, t), (this.material = e.material), (this.geometry = e.geometry), this;
      }
      raycast(e, t) {
        const i = this.geometry,
          n = this.matrixWorld,
          s = e.params.Points.threshold,
          r = i.drawRange;
        if (
          (null === i.boundingSphere && i.computeBoundingSphere(),
          ba.copy(i.boundingSphere),
          ba.applyMatrix4(n),
          (ba.radius += s),
          !1 === e.ray.intersectsSphere(ba))
        )
          return;
        ya.copy(n).invert(), Ma.copy(e.ray).applyMatrix4(ya);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          o = a * a,
          l = i.index,
          h = i.attributes.position;
        if (null !== l) {
          for (let i = Math.max(0, r.start), s = Math.min(l.count, r.start + r.count); i < s; i++) {
            const s = l.getX(i);
            Sa.fromBufferAttribute(h, s), Aa(Sa, s, o, n, e, t, this);
          }
        } else {
          for (let i = Math.max(0, r.start), s = Math.min(h.count, r.start + r.count); i < s; i++)
            Sa.fromBufferAttribute(h, i), Aa(Sa, i, o, n, e, t, this);
        }
      }
      updateMorphTargets() {
        const e = this.geometry.morphAttributes,
          t = Object.keys(e);
        if (t.length > 0) {
          const i = e[t[0]];
          if (void 0 !== i) {
            (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
            for (let e = 0, t = i.length; e < t; e++) {
              const t = i[e].name || String(e);
              this.morphTargetInfluences.push(0), (this.morphTargetDictionary[t] = e);
            }
          }
        }
      }
    }
    function Aa(e, t, i, n, s, r, a) {
      const o = Ma.distanceSqToPoint(e);
      if (o < i) {
        const i = new Pe();
        Ma.closestPointToPoint(e, i), i.applyMatrix4(n);
        const l = s.ray.origin.distanceTo(i);
        if (l < s.near || l > s.far) return;
        r.push({ distance: l, distanceToRay: Math.sqrt(o), point: i, index: t, face: null, object: a });
      }
    }
    class Ta {
      constructor() {
        (this.type = 'Curve'), (this.arcLengthDivisions = 200);
      }
      getPoint() {
        return null;
      }
      getPointAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getPoint(i, t);
      }
      getPoints(e = 5) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
        return t;
      }
      getSpacedPoints(e = 5) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
        return t;
      }
      getLength() {
        const e = this.getLengths();
        return e[e.length - 1];
      }
      getLengths(e = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
          return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let i,
          n = this.getPoint(0),
          s = 0;
        t.push(0);
        for (let r = 1; r <= e; r++) (i = this.getPoint(r / e)), (s += i.distanceTo(n)), t.push(s), (n = i);
        return (this.cacheArcLengths = t), t;
      }
      updateArcLengths() {
        (this.needsUpdate = !0), this.getLengths();
      }
      getUtoTmapping(e, t) {
        const i = this.getLengths();
        let n = 0;
        const s = i.length;
        let r;
        r = t || e * i[s - 1];
        let a,
          o = 0,
          l = s - 1;
        for (; o <= l; )
          if (((n = Math.floor(o + (l - o) / 2)), (a = i[n] - r), a < 0)) o = n + 1;
          else {
            if (!(a > 0)) {
              l = n;
              break;
            }
            l = n - 1;
          }
        if (((n = l), i[n] === r)) return n / (s - 1);
        const h = i[n];
        return (n + (r - h) / (i[n + 1] - h)) / (s - 1);
      }
      getTangent(e, t) {
        const i = 1e-4;
        let n = e - i,
          s = e + i;
        n < 0 && (n = 0), s > 1 && (s = 1);
        const r = this.getPoint(n),
          a = this.getPoint(s),
          o = t || (r.isVector2 ? new se() : new Pe());
        return o.copy(a).sub(r).normalize(), o;
      }
      getTangentAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getTangent(i, t);
      }
      computeFrenetFrames(e, t) {
        const i = new Pe(),
          n = [],
          s = [],
          r = [],
          a = new Pe(),
          o = new ot();
        for (let t = 0; t <= e; t++) {
          const i = t / e;
          n[t] = this.getTangentAt(i, new Pe());
        }
        (s[0] = new Pe()), (r[0] = new Pe());
        let l = Number.MAX_VALUE;
        const h = Math.abs(n[0].x),
          c = Math.abs(n[0].y),
          u = Math.abs(n[0].z);
        h <= l && ((l = h), i.set(1, 0, 0)),
          c <= l && ((l = c), i.set(0, 1, 0)),
          u <= l && i.set(0, 0, 1),
          a.crossVectors(n[0], i).normalize(),
          s[0].crossVectors(n[0], a),
          r[0].crossVectors(n[0], s[0]);
        for (let t = 1; t <= e; t++) {
          if (
            ((s[t] = s[t - 1].clone()),
            (r[t] = r[t - 1].clone()),
            a.crossVectors(n[t - 1], n[t]),
            a.length() > Number.EPSILON)
          ) {
            a.normalize();
            const e = Math.acos(K(n[t - 1].dot(n[t]), -1, 1));
            s[t].applyMatrix4(o.makeRotationAxis(a, e));
          }
          r[t].crossVectors(n[t], s[t]);
        }
        if (!0 === t) {
          let t = Math.acos(K(s[0].dot(s[e]), -1, 1));
          (t /= e), n[0].dot(a.crossVectors(s[0], s[e])) > 0 && (t = -t);
          for (let i = 1; i <= e; i++)
            s[i].applyMatrix4(o.makeRotationAxis(n[i], t * i)), r[i].crossVectors(n[i], s[i]);
        }
        return { tangents: n, normals: s, binormals: r };
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return (this.arcLengthDivisions = e.arcLengthDivisions), this;
      }
      toJSON() {
        const e = { metadata: { version: 4.5, type: 'Curve', generator: 'Curve.toJSON' } };
        return (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e;
      }
      fromJSON(e) {
        return (this.arcLengthDivisions = e.arcLengthDivisions), this;
      }
    }
    class Ea extends Ta {
      constructor(e = 0, t = 0, i = 1, n = 1, s = 0, r = 2 * Math.PI, a = !1, o = 0) {
        super(),
          (this.isEllipseCurve = !0),
          (this.type = 'EllipseCurve'),
          (this.aX = e),
          (this.aY = t),
          (this.xRadius = i),
          (this.yRadius = n),
          (this.aStartAngle = s),
          (this.aEndAngle = r),
          (this.aClockwise = a),
          (this.aRotation = o);
      }
      getPoint(e, t) {
        const i = t || new se(),
          n = 2 * Math.PI;
        let s = this.aEndAngle - this.aStartAngle;
        const r = Math.abs(s) < Number.EPSILON;
        for (; s < 0; ) s += n;
        for (; s > n; ) s -= n;
        s < Number.EPSILON && (s = r ? 0 : n), !0 !== this.aClockwise || r || (s === n ? (s = -n) : (s -= n));
        const a = this.aStartAngle + e * s;
        let o = this.aX + this.xRadius * Math.cos(a),
          l = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
          const e = Math.cos(this.aRotation),
            t = Math.sin(this.aRotation),
            i = o - this.aX,
            n = l - this.aY;
          (o = i * e - n * t + this.aX), (l = i * t + n * e + this.aY);
        }
        return i.set(o, l);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.aX = e.aX),
          (this.aY = e.aY),
          (this.xRadius = e.xRadius),
          (this.yRadius = e.yRadius),
          (this.aStartAngle = e.aStartAngle),
          (this.aEndAngle = e.aEndAngle),
          (this.aClockwise = e.aClockwise),
          (this.aRotation = e.aRotation),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.aX = this.aX),
          (e.aY = this.aY),
          (e.xRadius = this.xRadius),
          (e.yRadius = this.yRadius),
          (e.aStartAngle = this.aStartAngle),
          (e.aEndAngle = this.aEndAngle),
          (e.aClockwise = this.aClockwise),
          (e.aRotation = this.aRotation),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          (this.aX = e.aX),
          (this.aY = e.aY),
          (this.xRadius = e.xRadius),
          (this.yRadius = e.yRadius),
          (this.aStartAngle = e.aStartAngle),
          (this.aEndAngle = e.aEndAngle),
          (this.aClockwise = e.aClockwise),
          (this.aRotation = e.aRotation),
          this
        );
      }
    }
    class La extends Ea {
      constructor(e, t, i, n, s, r) {
        super(e, t, i, i, n, s, r), (this.isArcCurve = !0), (this.type = 'ArcCurve');
      }
    }
    function Ca() {
      let e = 0,
        t = 0,
        i = 0,
        n = 0;
      function s(s, r, a, o) {
        (e = s), (t = a), (i = -3 * s + 3 * r - 2 * a - o), (n = 2 * s - 2 * r + a + o);
      }
      return {
        initCatmullRom: function (e, t, i, n, r) {
          s(t, i, r * (i - e), r * (n - t));
        },
        initNonuniformCatmullRom: function (e, t, i, n, r, a, o) {
          let l = (t - e) / r - (i - e) / (r + a) + (i - t) / a,
            h = (i - t) / a - (n - t) / (a + o) + (n - i) / o;
          (l *= a), (h *= a), s(t, i, l, h);
        },
        calc: function (s) {
          const r = s * s;
          return e + t * s + i * r + n * (r * s);
        },
      };
    }
    const Pa = new Pe(),
      Da = new Ca(),
      Ia = new Ca(),
      Ra = new Ca();
    function Oa(e, t, i, n, s) {
      const r = 0.5 * (n - t),
        a = 0.5 * (s - i),
        o = e * e;
      return (2 * i - 2 * n + r + a) * (e * o) + (-3 * i + 3 * n - 2 * r - a) * o + r * e + i;
    }
    function Na(e, t, i, n) {
      return (
        (function (e, t) {
          const i = 1 - e;
          return i * i * t;
        })(e, t) +
        (function (e, t) {
          return 2 * (1 - e) * e * t;
        })(e, i) +
        (function (e, t) {
          return e * e * t;
        })(e, n)
      );
    }
    function za(e, t, i, n, s) {
      return (
        (function (e, t) {
          const i = 1 - e;
          return i * i * i * t;
        })(e, t) +
        (function (e, t) {
          const i = 1 - e;
          return 3 * i * i * e * t;
        })(e, i) +
        (function (e, t) {
          return 3 * (1 - e) * e * e * t;
        })(e, n) +
        (function (e, t) {
          return e * e * e * t;
        })(e, s)
      );
    }
    class Fa extends Ta {
      constructor(e = new se(), t = new se(), i = new se(), n = new se()) {
        super(),
          (this.isCubicBezierCurve = !0),
          (this.type = 'CubicBezierCurve'),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = i),
          (this.v3 = n);
      }
      getPoint(e, t = new se()) {
        const i = t,
          n = this.v0,
          s = this.v1,
          r = this.v2,
          a = this.v3;
        return i.set(za(e, n.x, s.x, r.x, a.x), za(e, n.y, s.y, r.y, a.y)), i;
      }
      copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.v0 = this.v0.toArray()),
          (e.v1 = this.v1.toArray()),
          (e.v2 = this.v2.toArray()),
          (e.v3 = this.v3.toArray()),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v0.fromArray(e.v0),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this.v3.fromArray(e.v3),
          this
        );
      }
    }
    class ka extends Ta {
      constructor(e = new se(), t = new se()) {
        super(), (this.isLineCurve = !0), (this.type = 'LineCurve'), (this.v1 = e), (this.v2 = t);
      }
      getPoint(e, t = new se()) {
        const i = t;
        return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
      }
      getPointAt(e, t) {
        return this.getPoint(e, t);
      }
      getTangent(e, t) {
        const i = t || new se();
        return i.copy(this.v2).sub(this.v1).normalize(), i;
      }
      copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }
      toJSON() {
        const e = super.toJSON();
        return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
      }
      fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
      }
    }
    class Ua extends Ta {
      constructor(e = new se(), t = new se(), i = new se()) {
        super(),
          (this.isQuadraticBezierCurve = !0),
          (this.type = 'QuadraticBezierCurve'),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = i);
      }
      getPoint(e, t = new se()) {
        const i = t,
          n = this.v0,
          s = this.v1,
          r = this.v2;
        return i.set(Na(e, n.x, s.x, r.x), Na(e, n.y, s.y, r.y)), i;
      }
      copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }
      toJSON() {
        const e = super.toJSON();
        return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
      }
      fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
      }
    }
    class Ba extends Ta {
      constructor(e = new Pe(), t = new Pe(), i = new Pe()) {
        super(),
          (this.isQuadraticBezierCurve3 = !0),
          (this.type = 'QuadraticBezierCurve3'),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = i);
      }
      getPoint(e, t = new Pe()) {
        const i = t,
          n = this.v0,
          s = this.v1,
          r = this.v2;
        return i.set(Na(e, n.x, s.x, r.x), Na(e, n.y, s.y, r.y), Na(e, n.z, s.z, r.z)), i;
      }
      copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }
      toJSON() {
        const e = super.toJSON();
        return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
      }
      fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
      }
    }
    class Ga extends Ta {
      constructor(e = []) {
        super(), (this.isSplineCurve = !0), (this.type = 'SplineCurve'), (this.points = e);
      }
      getPoint(e, t = new se()) {
        const i = t,
          n = this.points,
          s = (n.length - 1) * e,
          r = Math.floor(s),
          a = s - r,
          o = n[0 === r ? r : r - 1],
          l = n[r],
          h = n[r > n.length - 2 ? n.length - 1 : r + 1],
          c = n[r > n.length - 3 ? n.length - 1 : r + 2];
        return i.set(Oa(a, o.x, l.x, h.x, c.x), Oa(a, o.y, l.y, h.y, c.y)), i;
      }
      copy(e) {
        super.copy(e), (this.points = []);
        for (let t = 0, i = e.points.length; t < i; t++) {
          const i = e.points[t];
          this.points.push(i.clone());
        }
        return this;
      }
      toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
          const i = this.points[t];
          e.points.push(i.toArray());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), (this.points = []);
        for (let t = 0, i = e.points.length; t < i; t++) {
          const i = e.points[t];
          this.points.push(new se().fromArray(i));
        }
        return this;
      }
    }
    var Va = Object.freeze({
      __proto__: null,
      ArcCurve: La,
      CatmullRomCurve3: class extends Ta {
        constructor(e = [], t = !1, i = 'centripetal', n = 0.5) {
          super(),
            (this.isCatmullRomCurve3 = !0),
            (this.type = 'CatmullRomCurve3'),
            (this.points = e),
            (this.closed = t),
            (this.curveType = i),
            (this.tension = n);
        }
        getPoint(e, t = new Pe()) {
          const i = t,
            n = this.points,
            s = n.length,
            r = (s - (this.closed ? 0 : 1)) * e;
          let a,
            o,
            l = Math.floor(r),
            h = r - l;
          this.closed
            ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / s) + 1) * s)
            : 0 === h && l === s - 1 && ((l = s - 2), (h = 1)),
            this.closed || l > 0 ? (a = n[(l - 1) % s]) : (Pa.subVectors(n[0], n[1]).add(n[0]), (a = Pa));
          const c = n[l % s],
            u = n[(l + 1) % s];
          if (
            (this.closed || l + 2 < s
              ? (o = n[(l + 2) % s])
              : (Pa.subVectors(n[s - 1], n[s - 2]).add(n[s - 1]), (o = Pa)),
            'centripetal' === this.curveType || 'chordal' === this.curveType)
          ) {
            const e = 'chordal' === this.curveType ? 0.5 : 0.25;
            let t = Math.pow(a.distanceToSquared(c), e),
              i = Math.pow(c.distanceToSquared(u), e),
              n = Math.pow(u.distanceToSquared(o), e);
            i < 1e-4 && (i = 1),
              t < 1e-4 && (t = i),
              n < 1e-4 && (n = i),
              Da.initNonuniformCatmullRom(a.x, c.x, u.x, o.x, t, i, n),
              Ia.initNonuniformCatmullRom(a.y, c.y, u.y, o.y, t, i, n),
              Ra.initNonuniformCatmullRom(a.z, c.z, u.z, o.z, t, i, n);
          } else
            'catmullrom' === this.curveType &&
              (Da.initCatmullRom(a.x, c.x, u.x, o.x, this.tension),
              Ia.initCatmullRom(a.y, c.y, u.y, o.y, this.tension),
              Ra.initCatmullRom(a.z, c.z, u.z, o.z, this.tension));
          return i.set(Da.calc(h), Ia.calc(h), Ra.calc(h)), i;
        }
        copy(e) {
          super.copy(e), (this.points = []);
          for (let t = 0, i = e.points.length; t < i; t++) {
            const i = e.points[t];
            this.points.push(i.clone());
          }
          return (this.closed = e.closed), (this.curveType = e.curveType), (this.tension = e.tension), this;
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, i = this.points.length; t < i; t++) {
            const i = this.points[t];
            e.points.push(i.toArray());
          }
          return (e.closed = this.closed), (e.curveType = this.curveType), (e.tension = this.tension), e;
        }
        fromJSON(e) {
          super.fromJSON(e), (this.points = []);
          for (let t = 0, i = e.points.length; t < i; t++) {
            const i = e.points[t];
            this.points.push(new Pe().fromArray(i));
          }
          return (this.closed = e.closed), (this.curveType = e.curveType), (this.tension = e.tension), this;
        }
      },
      CubicBezierCurve: Fa,
      CubicBezierCurve3: class extends Ta {
        constructor(e = new Pe(), t = new Pe(), i = new Pe(), n = new Pe()) {
          super(),
            (this.isCubicBezierCurve3 = !0),
            (this.type = 'CubicBezierCurve3'),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = i),
            (this.v3 = n);
        }
        getPoint(e, t = new Pe()) {
          const i = t,
            n = this.v0,
            s = this.v1,
            r = this.v2,
            a = this.v3;
          return i.set(za(e, n.x, s.x, r.x, a.x), za(e, n.y, s.y, r.y, a.y), za(e, n.z, s.z, r.z, a.z)), i;
        }
        copy(e) {
          return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
          );
        }
      },
      EllipseCurve: Ea,
      LineCurve: ka,
      LineCurve3: class extends Ta {
        constructor(e = new Pe(), t = new Pe()) {
          super(), (this.isLineCurve3 = !0), (this.type = 'LineCurve3'), (this.v1 = e), (this.v2 = t);
        }
        getPoint(e, t = new Pe()) {
          const i = t;
          return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
      },
      QuadraticBezierCurve: Ua,
      QuadraticBezierCurve3: Ba,
      SplineCurve: Ga,
    });
    class Ha extends Ta {
      constructor() {
        super(), (this.type = 'CurvePath'), (this.curves = []), (this.autoClose = !1);
      }
      add(e) {
        this.curves.push(e);
      }
      closePath() {
        const e = this.curves[0].getPoint(0),
          t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new ka(t, e));
      }
      getPoint(e, t) {
        const i = e * this.getLength(),
          n = this.getCurveLengths();
        let s = 0;
        for (; s < n.length; ) {
          if (n[s] >= i) {
            const e = n[s] - i,
              r = this.curves[s],
              a = r.getLength(),
              o = 0 === a ? 0 : 1 - e / a;
            return r.getPointAt(o, t);
          }
          s++;
        }
        return null;
      }
      getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1];
      }
      updateArcLengths() {
        (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
      }
      getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let i = 0, n = this.curves.length; i < n; i++) (t += this.curves[i].getLength()), e.push(t);
        return (this.cacheLengths = e), e;
      }
      getSpacedPoints(e = 40) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
        return this.autoClose && t.push(t[0]), t;
      }
      getPoints(e = 12) {
        const t = [];
        let i;
        for (let n = 0, s = this.curves; n < s.length; n++) {
          const r = s[n],
            a = r.isEllipseCurve
              ? 2 * e
              : r.isLineCurve || r.isLineCurve3
              ? 1
              : r.isSplineCurve
              ? e * r.points.length
              : e,
            o = r.getPoints(a);
          for (let e = 0; e < o.length; e++) {
            const n = o[e];
            (i && i.equals(n)) || (t.push(n), (i = n));
          }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
      }
      copy(e) {
        super.copy(e), (this.curves = []);
        for (let t = 0, i = e.curves.length; t < i; t++) {
          const i = e.curves[t];
          this.curves.push(i.clone());
        }
        return (this.autoClose = e.autoClose), this;
      }
      toJSON() {
        const e = super.toJSON();
        (e.autoClose = this.autoClose), (e.curves = []);
        for (let t = 0, i = this.curves.length; t < i; t++) {
          const i = this.curves[t];
          e.curves.push(i.toJSON());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
        for (let t = 0, i = e.curves.length; t < i; t++) {
          const i = e.curves[t];
          this.curves.push(new Va[i.type]().fromJSON(i));
        }
        return this;
      }
    }
    class ja extends Ha {
      constructor(e) {
        super(), (this.type = 'Path'), (this.currentPoint = new se()), e && this.setFromPoints(e);
      }
      setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
        return this;
      }
      moveTo(e, t) {
        return this.currentPoint.set(e, t), this;
      }
      lineTo(e, t) {
        const i = new ka(this.currentPoint.clone(), new se(e, t));
        return this.curves.push(i), this.currentPoint.set(e, t), this;
      }
      quadraticCurveTo(e, t, i, n) {
        const s = new Ua(this.currentPoint.clone(), new se(e, t), new se(i, n));
        return this.curves.push(s), this.currentPoint.set(i, n), this;
      }
      bezierCurveTo(e, t, i, n, s, r) {
        const a = new Fa(this.currentPoint.clone(), new se(e, t), new se(i, n), new se(s, r));
        return this.curves.push(a), this.currentPoint.set(s, r), this;
      }
      splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e),
          i = new Ga(t);
        return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
      }
      arc(e, t, i, n, s, r) {
        const a = this.currentPoint.x,
          o = this.currentPoint.y;
        return this.absarc(e + a, t + o, i, n, s, r), this;
      }
      absarc(e, t, i, n, s, r) {
        return this.absellipse(e, t, i, i, n, s, r), this;
      }
      ellipse(e, t, i, n, s, r, a, o) {
        const l = this.currentPoint.x,
          h = this.currentPoint.y;
        return this.absellipse(e + l, t + h, i, n, s, r, a, o), this;
      }
      absellipse(e, t, i, n, s, r, a, o) {
        const l = new Ea(e, t, i, n, s, r, a, o);
        if (this.curves.length > 0) {
          const e = l.getPoint(0);
          e.equals(this.currentPoint) || this.lineTo(e.x, e.y);
        }
        this.curves.push(l);
        const h = l.getPoint(1);
        return this.currentPoint.copy(h), this;
      }
      copy(e) {
        return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
      }
      toJSON() {
        const e = super.toJSON();
        return (e.currentPoint = this.currentPoint.toArray()), e;
      }
      fromJSON(e) {
        return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
      }
    }
    class Wa extends ai {
      constructor(e = 1, t = 8, i = 0, n = 2 * Math.PI) {
        super(),
          (this.type = 'CircleGeometry'),
          (this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: n }),
          (t = Math.max(3, t));
        const s = [],
          r = [],
          a = [],
          o = [],
          l = new Pe(),
          h = new se();
        r.push(0, 0, 0), a.push(0, 0, 1), o.push(0.5, 0.5);
        for (let s = 0, c = 3; s <= t; s++, c += 3) {
          const u = i + (s / t) * n;
          (l.x = e * Math.cos(u)),
            (l.y = e * Math.sin(u)),
            r.push(l.x, l.y, l.z),
            a.push(0, 0, 1),
            (h.x = (r[c] / e + 1) / 2),
            (h.y = (r[c + 1] / e + 1) / 2),
            o.push(h.x, h.y);
        }
        for (let e = 1; e <= t; e++) s.push(e, e + 1, 0);
        this.setIndex(s),
          this.setAttribute('position', new $t(r, 3)),
          this.setAttribute('normal', new $t(a, 3)),
          this.setAttribute('uv', new $t(o, 2));
      }
      static fromJSON(e) {
        return new Wa(e.radius, e.segments, e.thetaStart, e.thetaLength);
      }
    }
    class Xa extends ja {
      constructor(e) {
        super(e), (this.uuid = J()), (this.type = 'Shape'), (this.holes = []);
      }
      getPointsHoles(e) {
        const t = [];
        for (let i = 0, n = this.holes.length; i < n; i++) t[i] = this.holes[i].getPoints(e);
        return t;
      }
      extractPoints(e) {
        return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
      }
      copy(e) {
        super.copy(e), (this.holes = []);
        for (let t = 0, i = e.holes.length; t < i; t++) {
          const i = e.holes[t];
          this.holes.push(i.clone());
        }
        return this;
      }
      toJSON() {
        const e = super.toJSON();
        (e.uuid = this.uuid), (e.holes = []);
        for (let t = 0, i = this.holes.length; t < i; t++) {
          const i = this.holes[t];
          e.holes.push(i.toJSON());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
        for (let t = 0, i = e.holes.length; t < i; t++) {
          const i = e.holes[t];
          this.holes.push(new ja().fromJSON(i));
        }
        return this;
      }
    }
    const qa = function (e, t, i = 2) {
      const n = t && t.length,
        s = n ? t[0] * i : e.length;
      let r = Ya(e, 0, s, i, !0);
      const a = [];
      if (!r || r.next === r.prev) return a;
      let o, l, h, c, u, d, m;
      if (
        (n &&
          (r = (function (e, t, i, n) {
            const s = [];
            let r, a, o, l, h;
            for (r = 0, a = t.length; r < a; r++)
              (o = t[r] * n),
                (l = r < a - 1 ? t[r + 1] * n : e.length),
                (h = Ya(e, o, l, n, !1)),
                h === h.next && (h.steiner = !0),
                s.push(ro(h));
            for (s.sort(to), r = 0; r < s.length; r++) io(s[r], i), (i = Za(i, i.next));
            return i;
          })(e, t, r, i)),
        e.length > 80 * i)
      ) {
        (o = h = e[0]), (l = c = e[1]);
        for (let t = i; t < s; t += i)
          (u = e[t]), (d = e[t + 1]), u < o && (o = u), d < l && (l = d), u > h && (h = u), d > c && (c = d);
        (m = Math.max(h - o, c - l)), (m = 0 !== m ? 1 / m : 0);
      }
      return Ja(r, a, i, o, l, m), a;
    };
    function Ya(e, t, i, n, s) {
      let r, a;
      if (
        s ===
        (function (e, t, i, n) {
          let s = 0;
          for (let r = t, a = i - n; r < i; r += n) (s += (e[a] - e[r]) * (e[r + 1] + e[a + 1])), (a = r);
          return s;
        })(e, t, i, n) >
          0
      )
        for (r = t; r < i; r += n) a = go(r, e[r], e[r + 1], a);
      else for (r = i - n; r >= t; r -= n) a = go(r, e[r], e[r + 1], a);
      return a && ho(a, a.next) && (_o(a), (a = a.next)), a;
    }
    function Za(e, t) {
      if (!e) return e;
      t || (t = e);
      let i,
        n = e;
      do {
        if (((i = !1), n.steiner || (!ho(n, n.next) && 0 !== lo(n.prev, n, n.next)))) n = n.next;
        else {
          if ((_o(n), (n = t = n.prev), n === n.next)) break;
          i = !0;
        }
      } while (i || n !== t);
      return t;
    }
    function Ja(e, t, i, n, s, r, a) {
      if (!e) return;
      !a &&
        r &&
        (function (e, t, i, n) {
          let s = e;
          do {
            null === s.z && (s.z = so(s.x, s.y, t, i, n)), (s.prevZ = s.prev), (s.nextZ = s.next), (s = s.next);
          } while (s !== e);
          (s.prevZ.nextZ = null),
            (s.prevZ = null),
            (function (e) {
              let t,
                i,
                n,
                s,
                r,
                a,
                o,
                l,
                h = 1;
              do {
                for (i = e, e = null, r = null, a = 0; i; ) {
                  for (a++, n = i, o = 0, t = 0; t < h && (o++, (n = n.nextZ), n); t++);
                  for (l = h; o > 0 || (l > 0 && n); )
                    0 !== o && (0 === l || !n || i.z <= n.z)
                      ? ((s = i), (i = i.nextZ), o--)
                      : ((s = n), (n = n.nextZ), l--),
                      r ? (r.nextZ = s) : (e = s),
                      (s.prevZ = r),
                      (r = s);
                  i = n;
                }
                (r.nextZ = null), (h *= 2);
              } while (a > 1);
            })(s);
        })(e, n, s, r);
      let o,
        l,
        h = e;
      for (; e.prev !== e.next; )
        if (((o = e.prev), (l = e.next), r ? $a(e, n, s, r) : Ka(e)))
          t.push(o.i / i), t.push(e.i / i), t.push(l.i / i), _o(e), (e = l.next), (h = l.next);
        else if ((e = l) === h) {
          a
            ? 1 === a
              ? Ja((e = Qa(Za(e), t, i)), t, i, n, s, r, 2)
              : 2 === a && eo(e, t, i, n, s, r)
            : Ja(Za(e), t, i, n, s, r, 1);
          break;
        }
    }
    function Ka(e) {
      const t = e.prev,
        i = e,
        n = e.next;
      if (lo(t, i, n) >= 0) return !1;
      let s = e.next.next;
      for (; s !== e.prev; ) {
        if (ao(t.x, t.y, i.x, i.y, n.x, n.y, s.x, s.y) && lo(s.prev, s, s.next) >= 0) return !1;
        s = s.next;
      }
      return !0;
    }
    function $a(e, t, i, n) {
      const s = e.prev,
        r = e,
        a = e.next;
      if (lo(s, r, a) >= 0) return !1;
      const o = s.x < r.x ? (s.x < a.x ? s.x : a.x) : r.x < a.x ? r.x : a.x,
        l = s.y < r.y ? (s.y < a.y ? s.y : a.y) : r.y < a.y ? r.y : a.y,
        h = s.x > r.x ? (s.x > a.x ? s.x : a.x) : r.x > a.x ? r.x : a.x,
        c = s.y > r.y ? (s.y > a.y ? s.y : a.y) : r.y > a.y ? r.y : a.y,
        u = so(o, l, t, i, n),
        d = so(h, c, t, i, n);
      let m = e.prevZ,
        p = e.nextZ;
      for (; m && m.z >= u && p && p.z <= d; ) {
        if (m !== e.prev && m !== e.next && ao(s.x, s.y, r.x, r.y, a.x, a.y, m.x, m.y) && lo(m.prev, m, m.next) >= 0)
          return !1;
        if (
          ((m = m.prevZ),
          p !== e.prev && p !== e.next && ao(s.x, s.y, r.x, r.y, a.x, a.y, p.x, p.y) && lo(p.prev, p, p.next) >= 0)
        )
          return !1;
        p = p.nextZ;
      }
      for (; m && m.z >= u; ) {
        if (m !== e.prev && m !== e.next && ao(s.x, s.y, r.x, r.y, a.x, a.y, m.x, m.y) && lo(m.prev, m, m.next) >= 0)
          return !1;
        m = m.prevZ;
      }
      for (; p && p.z <= d; ) {
        if (p !== e.prev && p !== e.next && ao(s.x, s.y, r.x, r.y, a.x, a.y, p.x, p.y) && lo(p.prev, p, p.next) >= 0)
          return !1;
        p = p.nextZ;
      }
      return !0;
    }
    function Qa(e, t, i) {
      let n = e;
      do {
        const s = n.prev,
          r = n.next.next;
        !ho(s, r) &&
          co(s, n, n.next, r) &&
          po(s, r) &&
          po(r, s) &&
          (t.push(s.i / i), t.push(n.i / i), t.push(r.i / i), _o(n), _o(n.next), (n = e = r)),
          (n = n.next);
      } while (n !== e);
      return Za(n);
    }
    function eo(e, t, i, n, s, r) {
      let a = e;
      do {
        let e = a.next.next;
        for (; e !== a.prev; ) {
          if (a.i !== e.i && oo(a, e)) {
            let o = fo(a, e);
            return (a = Za(a, a.next)), (o = Za(o, o.next)), Ja(a, t, i, n, s, r), void Ja(o, t, i, n, s, r);
          }
          e = e.next;
        }
        a = a.next;
      } while (a !== e);
    }
    function to(e, t) {
      return e.x - t.x;
    }
    function io(e, t) {
      if (
        ((t = (function (e, t) {
          let i = t;
          const n = e.x,
            s = e.y;
          let r,
            a = -1 / 0;
          do {
            if (s <= i.y && s >= i.next.y && i.next.y !== i.y) {
              const e = i.x + ((s - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
              if (e <= n && e > a) {
                if (((a = e), e === n)) {
                  if (s === i.y) return i;
                  if (s === i.next.y) return i.next;
                }
                r = i.x < i.next.x ? i : i.next;
              }
            }
            i = i.next;
          } while (i !== t);
          if (!r) return null;
          if (n === a) return r;
          const o = r,
            l = r.x,
            h = r.y;
          let c,
            u = 1 / 0;
          i = r;
          do {
            n >= i.x &&
              i.x >= l &&
              n !== i.x &&
              ao(s < h ? n : a, s, l, h, s < h ? a : n, s, i.x, i.y) &&
              ((c = Math.abs(s - i.y) / (n - i.x)),
              po(i, e) && (c < u || (c === u && (i.x > r.x || (i.x === r.x && no(r, i))))) && ((r = i), (u = c))),
              (i = i.next);
          } while (i !== o);
          return r;
        })(e, t)),
        t)
      ) {
        const i = fo(t, e);
        Za(t, t.next), Za(i, i.next);
      }
    }
    function no(e, t) {
      return lo(e.prev, e, t.prev) < 0 && lo(t.next, e, e.next) < 0;
    }
    function so(e, t, i, n, s) {
      return (
        (e =
          1431655765 &
          ((e =
            858993459 &
            ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * s) | (e << 8))) | (e << 4))) | (e << 2))) |
            (e << 1))) |
        ((t =
          1431655765 &
          ((t =
            858993459 &
            ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * s) | (t << 8))) | (t << 4))) | (t << 2))) |
            (t << 1))) <<
          1)
      );
    }
    function ro(e) {
      let t = e,
        i = e;
      do {
        (t.x < i.x || (t.x === i.x && t.y < i.y)) && (i = t), (t = t.next);
      } while (t !== e);
      return i;
    }
    function ao(e, t, i, n, s, r, a, o) {
      return (
        (s - a) * (t - o) - (e - a) * (r - o) >= 0 &&
        (e - a) * (n - o) - (i - a) * (t - o) >= 0 &&
        (i - a) * (r - o) - (s - a) * (n - o) >= 0
      );
    }
    function oo(e, t) {
      return (
        e.next.i !== t.i &&
        e.prev.i !== t.i &&
        !(function (e, t) {
          let i = e;
          do {
            if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && co(i, i.next, e, t)) return !0;
            i = i.next;
          } while (i !== e);
          return !1;
        })(e, t) &&
        ((po(e, t) &&
          po(t, e) &&
          (function (e, t) {
            let i = e,
              n = !1;
            const s = (e.x + t.x) / 2,
              r = (e.y + t.y) / 2;
            do {
              i.y > r != i.next.y > r &&
                i.next.y !== i.y &&
                s < ((i.next.x - i.x) * (r - i.y)) / (i.next.y - i.y) + i.x &&
                (n = !n),
                (i = i.next);
            } while (i !== e);
            return n;
          })(e, t) &&
          (lo(e.prev, e, t.prev) || lo(e, t.prev, t))) ||
          (ho(e, t) && lo(e.prev, e, e.next) > 0 && lo(t.prev, t, t.next) > 0))
      );
    }
    function lo(e, t, i) {
      return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y);
    }
    function ho(e, t) {
      return e.x === t.x && e.y === t.y;
    }
    function co(e, t, i, n) {
      const s = mo(lo(e, t, i)),
        r = mo(lo(e, t, n)),
        a = mo(lo(i, n, e)),
        o = mo(lo(i, n, t));
      return (
        (s !== r && a !== o) ||
        !(0 !== s || !uo(e, i, t)) ||
        !(0 !== r || !uo(e, n, t)) ||
        !(0 !== a || !uo(i, e, n)) ||
        !(0 !== o || !uo(i, t, n))
      );
    }
    function uo(e, t, i) {
      return (
        t.x <= Math.max(e.x, i.x) && t.x >= Math.min(e.x, i.x) && t.y <= Math.max(e.y, i.y) && t.y >= Math.min(e.y, i.y)
      );
    }
    function mo(e) {
      return e > 0 ? 1 : e < 0 ? -1 : 0;
    }
    function po(e, t) {
      return lo(e.prev, e, e.next) < 0
        ? lo(e, t, e.next) >= 0 && lo(e, e.prev, t) >= 0
        : lo(e, t, e.prev) < 0 || lo(e, e.next, t) < 0;
    }
    function fo(e, t) {
      const i = new vo(e.i, e.x, e.y),
        n = new vo(t.i, t.x, t.y),
        s = e.next,
        r = t.prev;
      return (
        (e.next = t),
        (t.prev = e),
        (i.next = s),
        (s.prev = i),
        (n.next = i),
        (i.prev = n),
        (r.next = n),
        (n.prev = r),
        n
      );
    }
    function go(e, t, i, n) {
      const s = new vo(e, t, i);
      return n ? ((s.next = n.next), (s.prev = n), (n.next.prev = s), (n.next = s)) : ((s.prev = s), (s.next = s)), s;
    }
    function _o(e) {
      (e.next.prev = e.prev),
        (e.prev.next = e.next),
        e.prevZ && (e.prevZ.nextZ = e.nextZ),
        e.nextZ && (e.nextZ.prevZ = e.prevZ);
    }
    function vo(e, t, i) {
      (this.i = e),
        (this.x = t),
        (this.y = i),
        (this.prev = null),
        (this.next = null),
        (this.z = null),
        (this.prevZ = null),
        (this.nextZ = null),
        (this.steiner = !1);
    }
    class xo {
      static area(e) {
        const t = e.length;
        let i = 0;
        for (let n = t - 1, s = 0; s < t; n = s++) i += e[n].x * e[s].y - e[s].x * e[n].y;
        return 0.5 * i;
      }
      static isClockWise(e) {
        return xo.area(e) < 0;
      }
      static triangulateShape(e, t) {
        const i = [],
          n = [],
          s = [];
        yo(e), Mo(i, e);
        let r = e.length;
        t.forEach(yo);
        for (let e = 0; e < t.length; e++) n.push(r), (r += t[e].length), Mo(i, t[e]);
        const a = qa(i, n);
        for (let e = 0; e < a.length; e += 3) s.push(a.slice(e, e + 3));
        return s;
      }
    }
    function yo(e) {
      const t = e.length;
      t > 2 && e[t - 1].equals(e[0]) && e.pop();
    }
    function Mo(e, t) {
      for (let i = 0; i < t.length; i++) e.push(t[i].x), e.push(t[i].y);
    }
    class bo extends ai {
      constructor(e = new Xa([new se(0, 0.5), new se(-0.5, -0.5), new se(0.5, -0.5)]), t = 12) {
        super(), (this.type = 'ShapeGeometry'), (this.parameters = { shapes: e, curveSegments: t });
        const i = [],
          n = [],
          s = [],
          r = [];
        let a = 0,
          o = 0;
        if (!1 === Array.isArray(e)) l(e);
        else for (let t = 0; t < e.length; t++) l(e[t]), this.addGroup(a, o, t), (a += o), (o = 0);
        function l(e) {
          const a = n.length / 3,
            l = e.extractPoints(t);
          let h = l.shape;
          const c = l.holes;
          !1 === xo.isClockWise(h) && (h = h.reverse());
          for (let e = 0, t = c.length; e < t; e++) {
            const t = c[e];
            !0 === xo.isClockWise(t) && (c[e] = t.reverse());
          }
          const u = xo.triangulateShape(h, c);
          for (let e = 0, t = c.length; e < t; e++) {
            const t = c[e];
            h = h.concat(t);
          }
          for (let e = 0, t = h.length; e < t; e++) {
            const t = h[e];
            n.push(t.x, t.y, 0), s.push(0, 0, 1), r.push(t.x, t.y);
          }
          for (let e = 0, t = u.length; e < t; e++) {
            const t = u[e],
              n = t[0] + a,
              s = t[1] + a,
              r = t[2] + a;
            i.push(n, s, r), (o += 3);
          }
        }
        this.setIndex(i),
          this.setAttribute('position', new $t(n, 3)),
          this.setAttribute('normal', new $t(s, 3)),
          this.setAttribute('uv', new $t(r, 2));
      }
      toJSON() {
        const e = super.toJSON();
        return (function (e, t) {
          if (((t.shapes = []), Array.isArray(e)))
            for (let i = 0, n = e.length; i < n; i++) {
              const n = e[i];
              t.shapes.push(n.uuid);
            }
          else t.shapes.push(e.uuid);
          return t;
        })(this.parameters.shapes, e);
      }
      static fromJSON(e, t) {
        const i = [];
        for (let n = 0, s = e.shapes.length; n < s; n++) {
          const s = t[e.shapes[n]];
          i.push(s);
        }
        return new bo(i, e.curveSegments);
      }
    }
    class So extends ai {
      constructor(e = 1, t = 32, i = 16, n = 0, s = 2 * Math.PI, r = 0, a = Math.PI) {
        super(),
          (this.type = 'SphereGeometry'),
          (this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: n,
            phiLength: s,
            thetaStart: r,
            thetaLength: a,
          }),
          (t = Math.max(3, Math.floor(t))),
          (i = Math.max(2, Math.floor(i)));
        const o = Math.min(r + a, Math.PI);
        let l = 0;
        const h = [],
          c = new Pe(),
          u = new Pe(),
          d = [],
          m = [],
          p = [],
          f = [];
        for (let d = 0; d <= i; d++) {
          const g = [],
            _ = d / i;
          let v = 0;
          0 == d && 0 == r ? (v = 0.5 / t) : d == i && o == Math.PI && (v = -0.5 / t);
          for (let i = 0; i <= t; i++) {
            const o = i / t;
            (c.x = -e * Math.cos(n + o * s) * Math.sin(r + _ * a)),
              (c.y = e * Math.cos(r + _ * a)),
              (c.z = e * Math.sin(n + o * s) * Math.sin(r + _ * a)),
              m.push(c.x, c.y, c.z),
              u.copy(c).normalize(),
              p.push(u.x, u.y, u.z),
              f.push(o + v, 1 - _),
              g.push(l++);
          }
          h.push(g);
        }
        for (let e = 0; e < i; e++)
          for (let n = 0; n < t; n++) {
            const t = h[e][n + 1],
              s = h[e][n],
              a = h[e + 1][n],
              l = h[e + 1][n + 1];
            (0 !== e || r > 0) && d.push(t, s, l), (e !== i - 1 || o < Math.PI) && d.push(s, a, l);
          }
        this.setIndex(d),
          this.setAttribute('position', new $t(m, 3)),
          this.setAttribute('normal', new $t(p, 3)),
          this.setAttribute('uv', new $t(f, 2));
      }
      static fromJSON(e) {
        return new So(
          e.radius,
          e.widthSegments,
          e.heightSegments,
          e.phiStart,
          e.phiLength,
          e.thetaStart,
          e.thetaLength,
        );
      }
    }
    class wo extends ai {
      constructor(e = null) {
        if ((super(), (this.type = 'WireframeGeometry'), (this.parameters = { geometry: e }), null !== e)) {
          const t = [],
            i = new Set(),
            n = new Pe(),
            s = new Pe();
          if (null !== e.index) {
            const r = e.attributes.position,
              a = e.index;
            let o = e.groups;
            0 === o.length && (o = [{ start: 0, count: a.count, materialIndex: 0 }]);
            for (let e = 0, l = o.length; e < l; ++e) {
              const l = o[e],
                h = l.start;
              for (let e = h, o = h + l.count; e < o; e += 3)
                for (let o = 0; o < 3; o++) {
                  const l = a.getX(e + o),
                    h = a.getX(e + ((o + 1) % 3));
                  n.fromBufferAttribute(r, l),
                    s.fromBufferAttribute(r, h),
                    !0 === Ao(n, s, i) && (t.push(n.x, n.y, n.z), t.push(s.x, s.y, s.z));
                }
            }
          } else {
            const r = e.attributes.position;
            for (let e = 0, a = r.count / 3; e < a; e++)
              for (let a = 0; a < 3; a++) {
                const o = 3 * e + a,
                  l = 3 * e + ((a + 1) % 3);
                n.fromBufferAttribute(r, o),
                  s.fromBufferAttribute(r, l),
                  !0 === Ao(n, s, i) && (t.push(n.x, n.y, n.z), t.push(s.x, s.y, s.z));
              }
          }
          this.setAttribute('position', new $t(t, 3));
        }
      }
    }
    function Ao(e, t, i) {
      const n = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`,
        s = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
      return !0 !== i.has(n) && !0 !== i.has(s) && (i.add(n), i.add(s), !0);
    }
    class To extends Wt {
      constructor(e) {
        super(),
          (this.isMeshStandardMaterial = !0),
          (this.defines = { STANDARD: '' }),
          (this.type = 'MeshStandardMaterial'),
          (this.color = new ve(16777215)),
          (this.roughness = 1),
          (this.metalness = 0),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new ve(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new se(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.roughnessMap = null),
          (this.metalnessMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.envMapIntensity = 1),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = 'round'),
          (this.wireframeLinejoin = 'round'),
          (this.flatShading = !1),
          (this.fog = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.defines = { STANDARD: '' }),
          this.color.copy(e.color),
          (this.roughness = e.roughness),
          (this.metalness = e.metalness),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.roughnessMap = e.roughnessMap),
          (this.metalnessMap = e.metalnessMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.envMapIntensity = e.envMapIntensity),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.flatShading = e.flatShading),
          (this.fog = e.fog),
          this
        );
      }
    }
    class Eo extends To {
      constructor(e) {
        super(),
          (this.isMeshPhysicalMaterial = !0),
          (this.defines = { STANDARD: '', PHYSICAL: '' }),
          (this.type = 'MeshPhysicalMaterial'),
          (this.clearcoatMap = null),
          (this.clearcoatRoughness = 0),
          (this.clearcoatRoughnessMap = null),
          (this.clearcoatNormalScale = new se(1, 1)),
          (this.clearcoatNormalMap = null),
          (this.ior = 1.5),
          Object.defineProperty(this, 'reflectivity', {
            get: function () {
              return K((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
            },
            set: function (e) {
              this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
            },
          }),
          (this.iridescenceMap = null),
          (this.iridescenceIOR = 1.3),
          (this.iridescenceThicknessRange = [100, 400]),
          (this.iridescenceThicknessMap = null),
          (this.sheenColor = new ve(0)),
          (this.sheenColorMap = null),
          (this.sheenRoughness = 1),
          (this.sheenRoughnessMap = null),
          (this.transmissionMap = null),
          (this.thickness = 0),
          (this.thicknessMap = null),
          (this.attenuationDistance = 0),
          (this.attenuationColor = new ve(1, 1, 1)),
          (this.specularIntensity = 1),
          (this.specularIntensityMap = null),
          (this.specularColor = new ve(1, 1, 1)),
          (this.specularColorMap = null),
          (this._sheen = 0),
          (this._clearcoat = 0),
          (this._iridescence = 0),
          (this._transmission = 0),
          this.setValues(e);
      }
      get sheen() {
        return this._sheen;
      }
      set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
      }
      get clearcoat() {
        return this._clearcoat;
      }
      set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
      }
      get iridescence() {
        return this._iridescence;
      }
      set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
      }
      get transmission() {
        return this._transmission;
      }
      set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.defines = { STANDARD: '', PHYSICAL: '' }),
          (this.clearcoat = e.clearcoat),
          (this.clearcoatMap = e.clearcoatMap),
          (this.clearcoatRoughness = e.clearcoatRoughness),
          (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
          (this.clearcoatNormalMap = e.clearcoatNormalMap),
          this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
          (this.ior = e.ior),
          (this.iridescence = e.iridescence),
          (this.iridescenceMap = e.iridescenceMap),
          (this.iridescenceIOR = e.iridescenceIOR),
          (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
          (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
          (this.sheen = e.sheen),
          this.sheenColor.copy(e.sheenColor),
          (this.sheenColorMap = e.sheenColorMap),
          (this.sheenRoughness = e.sheenRoughness),
          (this.sheenRoughnessMap = e.sheenRoughnessMap),
          (this.transmission = e.transmission),
          (this.transmissionMap = e.transmissionMap),
          (this.thickness = e.thickness),
          (this.thicknessMap = e.thicknessMap),
          (this.attenuationDistance = e.attenuationDistance),
          this.attenuationColor.copy(e.attenuationColor),
          (this.specularIntensity = e.specularIntensity),
          (this.specularIntensityMap = e.specularIntensityMap),
          this.specularColor.copy(e.specularColor),
          (this.specularColorMap = e.specularColorMap),
          this
        );
      }
    }
    class Lo extends Wt {
      constructor(e) {
        super(),
          (this.isMeshPhongMaterial = !0),
          (this.type = 'MeshPhongMaterial'),
          (this.color = new ve(16777215)),
          (this.specular = new ve(1118481)),
          (this.shininess = 30),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new ve(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new se(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = 0),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = 'round'),
          (this.wireframeLinejoin = 'round'),
          (this.flatShading = !1),
          (this.fog = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          this.specular.copy(e.specular),
          (this.shininess = e.shininess),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.specularMap = e.specularMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.combine = e.combine),
          (this.reflectivity = e.reflectivity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.flatShading = e.flatShading),
          (this.fog = e.fog),
          this
        );
      }
    }
    class Co extends la {
      constructor(e) {
        super(),
          (this.isLineDashedMaterial = !0),
          (this.type = 'LineDashedMaterial'),
          (this.scale = 1),
          (this.dashSize = 3),
          (this.gapSize = 1),
          this.setValues(e);
      }
      copy(e) {
        return super.copy(e), (this.scale = e.scale), (this.dashSize = e.dashSize), (this.gapSize = e.gapSize), this;
      }
    }
    const Po = {
      arraySlice: function (e, t, i) {
        return Po.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i);
      },
      convertArray: function (e, t, i) {
        return !e || (!i && e.constructor === t)
          ? e
          : 'number' == typeof t.BYTES_PER_ELEMENT
          ? new t(e)
          : Array.prototype.slice.call(e);
      },
      isTypedArray: function (e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView);
      },
      getKeyframeOrder: function (e) {
        const t = e.length,
          i = new Array(t);
        for (let e = 0; e !== t; ++e) i[e] = e;
        return (
          i.sort(function (t, i) {
            return e[t] - e[i];
          }),
          i
        );
      },
      sortedArray: function (e, t, i) {
        const n = e.length,
          s = new e.constructor(n);
        for (let r = 0, a = 0; a !== n; ++r) {
          const n = i[r] * t;
          for (let i = 0; i !== t; ++i) s[a++] = e[n + i];
        }
        return s;
      },
      flattenJSON: function (e, t, i, n) {
        let s = 1,
          r = e[0];
        for (; void 0 !== r && void 0 === r[n]; ) r = e[s++];
        if (void 0 === r) return;
        let a = r[n];
        if (void 0 !== a)
          if (Array.isArray(a))
            do {
              (a = r[n]), void 0 !== a && (t.push(r.time), i.push.apply(i, a)), (r = e[s++]);
            } while (void 0 !== r);
          else if (void 0 !== a.toArray)
            do {
              (a = r[n]), void 0 !== a && (t.push(r.time), a.toArray(i, i.length)), (r = e[s++]);
            } while (void 0 !== r);
          else
            do {
              (a = r[n]), void 0 !== a && (t.push(r.time), i.push(a)), (r = e[s++]);
            } while (void 0 !== r);
      },
      subclip: function (e, t, i, n, s = 30) {
        const r = e.clone();
        r.name = t;
        const a = [];
        for (let e = 0; e < r.tracks.length; ++e) {
          const t = r.tracks[e],
            o = t.getValueSize(),
            l = [],
            h = [];
          for (let e = 0; e < t.times.length; ++e) {
            const r = t.times[e] * s;
            if (!(r < i || r >= n)) {
              l.push(t.times[e]);
              for (let i = 0; i < o; ++i) h.push(t.values[e * o + i]);
            }
          }
          0 !== l.length &&
            ((t.times = Po.convertArray(l, t.times.constructor)),
            (t.values = Po.convertArray(h, t.values.constructor)),
            a.push(t));
        }
        r.tracks = a;
        let o = 1 / 0;
        for (let e = 0; e < r.tracks.length; ++e) o > r.tracks[e].times[0] && (o = r.tracks[e].times[0]);
        for (let e = 0; e < r.tracks.length; ++e) r.tracks[e].shift(-1 * o);
        return r.resetDuration(), r;
      },
      makeClipAdditive: function (e, t = 0, i = e, n = 30) {
        n <= 0 && (n = 30);
        const s = i.tracks.length,
          r = t / n;
        for (let t = 0; t < s; ++t) {
          const n = i.tracks[t],
            s = n.ValueTypeName;
          if ('bool' === s || 'string' === s) continue;
          const a = e.tracks.find(function (e) {
            return e.name === n.name && e.ValueTypeName === s;
          });
          if (void 0 === a) continue;
          let o = 0;
          const l = n.getValueSize();
          n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
          let h = 0;
          const c = a.getValueSize();
          a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = c / 3);
          const u = n.times.length - 1;
          let d;
          if (r <= n.times[0]) {
            const e = o,
              t = l - o;
            d = Po.arraySlice(n.values, e, t);
          } else if (r >= n.times[u]) {
            const e = u * l + o,
              t = e + l - o;
            d = Po.arraySlice(n.values, e, t);
          } else {
            const e = n.createInterpolant(),
              t = o,
              i = l - o;
            e.evaluate(r), (d = Po.arraySlice(e.resultBuffer, t, i));
          }
          if ('quaternion' === s) {
            new Ce().fromArray(d).normalize().conjugate().toArray(d);
          }
          const m = a.times.length;
          for (let e = 0; e < m; ++e) {
            const t = e * c + h;
            if ('quaternion' === s) Ce.multiplyQuaternionsFlat(a.values, t, d, 0, a.values, t);
            else {
              const e = c - 2 * h;
              for (let i = 0; i < e; ++i) a.values[t + i] -= d[i];
            }
          }
        }
        return (e.blendMode = 2501), e;
      },
    };
    class Do {
      constructor(e, t, i, n) {
        (this.parameterPositions = e),
          (this._cachedIndex = 0),
          (this.resultBuffer = void 0 !== n ? n : new t.constructor(i)),
          (this.sampleValues = t),
          (this.valueSize = i),
          (this.settings = null),
          (this.DefaultSettings_ = {});
      }
      evaluate(e) {
        const t = this.parameterPositions;
        let i = this._cachedIndex,
          n = t[i],
          s = t[i - 1];
        e: {
          t: {
            let r;
            i: {
              n: if (!(e < n)) {
                for (let r = i + 2; ; ) {
                  if (void 0 === n) {
                    if (e < s) break n;
                    return (i = t.length), (this._cachedIndex = i), this.copySampleValue_(i - 1);
                  }
                  if (i === r) break;
                  if (((s = n), (n = t[++i]), e < n)) break t;
                }
                r = t.length;
                break i;
              }
              if (e >= s) break e;
              {
                const a = t[1];
                e < a && ((i = 2), (s = a));
                for (let r = i - 2; ; ) {
                  if (void 0 === s) return (this._cachedIndex = 0), this.copySampleValue_(0);
                  if (i === r) break;
                  if (((n = s), (s = t[--i - 1]), e >= s)) break t;
                }
                (r = i), (i = 0);
              }
            }
            for (; i < r; ) {
              const n = (i + r) >>> 1;
              e < t[n] ? (r = n) : (i = n + 1);
            }
            if (((n = t[i]), (s = t[i - 1]), void 0 === s)) return (this._cachedIndex = 0), this.copySampleValue_(0);
            if (void 0 === n) return (i = t.length), (this._cachedIndex = i), this.copySampleValue_(i - 1);
          }
          (this._cachedIndex = i), this.intervalChanged_(i, s, n);
        }
        return this.interpolate_(i, s, e, n);
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
      copySampleValue_(e) {
        const t = this.resultBuffer,
          i = this.sampleValues,
          n = this.valueSize,
          s = e * n;
        for (let e = 0; e !== n; ++e) t[e] = i[s + e];
        return t;
      }
      interpolate_() {
        throw new Error('call to abstract method');
      }
      intervalChanged_() {}
    }
    class Io extends Do {
      constructor(e, t, i, n) {
        super(e, t, i, n),
          (this._weightPrev = -0),
          (this._offsetPrev = -0),
          (this._weightNext = -0),
          (this._offsetNext = -0),
          (this.DefaultSettings_ = { endingStart: O, endingEnd: O });
      }
      intervalChanged_(e, t, i) {
        const n = this.parameterPositions;
        let s = e - 2,
          r = e + 1,
          a = n[s],
          o = n[r];
        if (void 0 === a)
          switch (this.getSettings_().endingStart) {
            case N:
              (s = e), (a = 2 * t - i);
              break;
            case z:
              (s = n.length - 2), (a = t + n[s] - n[s + 1]);
              break;
            default:
              (s = e), (a = i);
          }
        if (void 0 === o)
          switch (this.getSettings_().endingEnd) {
            case N:
              (r = e), (o = 2 * i - t);
              break;
            case z:
              (r = 1), (o = i + n[1] - n[0]);
              break;
            default:
              (r = e - 1), (o = t);
          }
        const l = 0.5 * (i - t),
          h = this.valueSize;
        (this._weightPrev = l / (t - a)),
          (this._weightNext = l / (o - i)),
          (this._offsetPrev = s * h),
          (this._offsetNext = r * h);
      }
      interpolate_(e, t, i, n) {
        const s = this.resultBuffer,
          r = this.sampleValues,
          a = this.valueSize,
          o = e * a,
          l = o - a,
          h = this._offsetPrev,
          c = this._offsetNext,
          u = this._weightPrev,
          d = this._weightNext,
          m = (i - t) / (n - t),
          p = m * m,
          f = p * m,
          g = -u * f + 2 * u * p - u * m,
          _ = (1 + u) * f + (-1.5 - 2 * u) * p + (-0.5 + u) * m + 1,
          v = (-1 - d) * f + (1.5 + d) * p + 0.5 * m,
          x = d * f - d * p;
        for (let e = 0; e !== a; ++e) s[e] = g * r[h + e] + _ * r[l + e] + v * r[o + e] + x * r[c + e];
        return s;
      }
    }
    class Ro extends Do {
      constructor(e, t, i, n) {
        super(e, t, i, n);
      }
      interpolate_(e, t, i, n) {
        const s = this.resultBuffer,
          r = this.sampleValues,
          a = this.valueSize,
          o = e * a,
          l = o - a,
          h = (i - t) / (n - t),
          c = 1 - h;
        for (let e = 0; e !== a; ++e) s[e] = r[l + e] * c + r[o + e] * h;
        return s;
      }
    }
    class Oo extends Do {
      constructor(e, t, i, n) {
        super(e, t, i, n);
      }
      interpolate_(e) {
        return this.copySampleValue_(e - 1);
      }
    }
    class No {
      constructor(e, t, i, n) {
        if (void 0 === e) throw new Error('THREE.KeyframeTrack: track name is undefined');
        if (void 0 === t || 0 === t.length) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + e);
        (this.name = e),
          (this.times = Po.convertArray(t, this.TimeBufferType)),
          (this.values = Po.convertArray(i, this.ValueBufferType)),
          this.setInterpolation(n || this.DefaultInterpolation);
      }
      static toJSON(e) {
        const t = e.constructor;
        let i;
        if (t.toJSON !== this.toJSON) i = t.toJSON(e);
        else {
          i = { name: e.name, times: Po.convertArray(e.times, Array), values: Po.convertArray(e.values, Array) };
          const t = e.getInterpolation();
          t !== e.DefaultInterpolation && (i.interpolation = t);
        }
        return (i.type = e.ValueTypeName), i;
      }
      InterpolantFactoryMethodDiscrete(e) {
        return new Oo(this.times, this.values, this.getValueSize(), e);
      }
      InterpolantFactoryMethodLinear(e) {
        return new Ro(this.times, this.values, this.getValueSize(), e);
      }
      InterpolantFactoryMethodSmooth(e) {
        return new Io(this.times, this.values, this.getValueSize(), e);
      }
      setInterpolation(e) {
        let t;
        switch (e) {
          case D:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
          case I:
            t = this.InterpolantFactoryMethodLinear;
            break;
          case R:
            t = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 === t) {
          const t = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
          if (void 0 === this.createInterpolant) {
            if (e === this.DefaultInterpolation) throw new Error(t);
            this.setInterpolation(this.DefaultInterpolation);
          }
          return this;
        }
        return (this.createInterpolant = t), this;
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return D;
          case this.InterpolantFactoryMethodLinear:
            return I;
          case this.InterpolantFactoryMethodSmooth:
            return R;
        }
      }
      getValueSize() {
        return this.values.length / this.times.length;
      }
      shift(e) {
        if (0 !== e) {
          const t = this.times;
          for (let i = 0, n = t.length; i !== n; ++i) t[i] += e;
        }
        return this;
      }
      scale(e) {
        if (1 !== e) {
          const t = this.times;
          for (let i = 0, n = t.length; i !== n; ++i) t[i] *= e;
        }
        return this;
      }
      trim(e, t) {
        const i = this.times,
          n = i.length;
        let s = 0,
          r = n - 1;
        for (; s !== n && i[s] < e; ) ++s;
        for (; -1 !== r && i[r] > t; ) --r;
        if ((++r, 0 !== s || r !== n)) {
          s >= r && ((r = Math.max(r, 1)), (s = r - 1));
          const e = this.getValueSize();
          (this.times = Po.arraySlice(i, s, r)), (this.values = Po.arraySlice(this.values, s * e, r * e));
        }
        return this;
      }
      validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) != 0 && (e = !1);
        const i = this.times,
          n = this.values,
          s = i.length;
        0 === s && (e = !1);
        let r = null;
        for (let t = 0; t !== s; t++) {
          const n = i[t];
          if ('number' == typeof n && isNaN(n)) {
            e = !1;
            break;
          }
          if (null !== r && r > n) {
            e = !1;
            break;
          }
          r = n;
        }
        if (void 0 !== n && Po.isTypedArray(n))
          for (let t = 0, i = n.length; t !== i; ++t) {
            const i = n[t];
            if (isNaN(i)) {
              e = !1;
              break;
            }
          }
        return e;
      }
      optimize() {
        const e = Po.arraySlice(this.times),
          t = Po.arraySlice(this.values),
          i = this.getValueSize(),
          n = this.getInterpolation() === R,
          s = e.length - 1;
        let r = 1;
        for (let a = 1; a < s; ++a) {
          let s = !1;
          const o = e[a];
          if (o !== e[a + 1] && (1 !== a || o !== e[0]))
            if (n) s = !0;
            else {
              const e = a * i,
                n = e - i,
                r = e + i;
              for (let a = 0; a !== i; ++a) {
                const i = t[e + a];
                if (i !== t[n + a] || i !== t[r + a]) {
                  s = !0;
                  break;
                }
              }
            }
          if (s) {
            if (a !== r) {
              e[r] = e[a];
              const n = a * i,
                s = r * i;
              for (let e = 0; e !== i; ++e) t[s + e] = t[n + e];
            }
            ++r;
          }
        }
        if (s > 0) {
          e[r] = e[s];
          for (let e = s * i, n = r * i, a = 0; a !== i; ++a) t[n + a] = t[e + a];
          ++r;
        }
        return (
          r !== e.length
            ? ((this.times = Po.arraySlice(e, 0, r)), (this.values = Po.arraySlice(t, 0, r * i)))
            : ((this.times = e), (this.values = t)),
          this
        );
      }
      clone() {
        const e = Po.arraySlice(this.times, 0),
          t = Po.arraySlice(this.values, 0),
          i = new (0, this.constructor)(this.name, e, t);
        return (i.createInterpolant = this.createInterpolant), i;
      }
    }
    (No.prototype.TimeBufferType = Float32Array),
      (No.prototype.ValueBufferType = Float32Array),
      (No.prototype.DefaultInterpolation = I);
    class zo extends No {}
    (zo.prototype.ValueTypeName = 'bool'),
      (zo.prototype.ValueBufferType = Array),
      (zo.prototype.DefaultInterpolation = D),
      (zo.prototype.InterpolantFactoryMethodLinear = void 0),
      (zo.prototype.InterpolantFactoryMethodSmooth = void 0);
    class Fo extends No {}
    Fo.prototype.ValueTypeName = 'color';
    class ko extends No {}
    ko.prototype.ValueTypeName = 'number';
    class Uo extends Do {
      constructor(e, t, i, n) {
        super(e, t, i, n);
      }
      interpolate_(e, t, i, n) {
        const s = this.resultBuffer,
          r = this.sampleValues,
          a = this.valueSize,
          o = (i - t) / (n - t);
        let l = e * a;
        for (let e = l + a; l !== e; l += 4) Ce.slerpFlat(s, 0, r, l - a, r, l, o);
        return s;
      }
    }
    class Bo extends No {
      InterpolantFactoryMethodLinear(e) {
        return new Uo(this.times, this.values, this.getValueSize(), e);
      }
    }
    (Bo.prototype.ValueTypeName = 'quaternion'),
      (Bo.prototype.DefaultInterpolation = I),
      (Bo.prototype.InterpolantFactoryMethodSmooth = void 0);
    class Go extends No {}
    (Go.prototype.ValueTypeName = 'string'),
      (Go.prototype.ValueBufferType = Array),
      (Go.prototype.DefaultInterpolation = D),
      (Go.prototype.InterpolantFactoryMethodLinear = void 0),
      (Go.prototype.InterpolantFactoryMethodSmooth = void 0);
    class Vo extends No {}
    Vo.prototype.ValueTypeName = 'vector';
    class Ho {
      constructor(e, t = -1, i, n = 2500) {
        (this.name = e),
          (this.tracks = i),
          (this.duration = t),
          (this.blendMode = n),
          (this.uuid = J()),
          this.duration < 0 && this.resetDuration();
      }
      static parse(e) {
        const t = [],
          i = e.tracks,
          n = 1 / (e.fps || 1);
        for (let e = 0, s = i.length; e !== s; ++e) t.push(jo(i[e]).scale(n));
        const s = new this(e.name, e.duration, t, e.blendMode);
        return (s.uuid = e.uuid), s;
      }
      static toJSON(e) {
        const t = [],
          i = e.tracks,
          n = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode };
        for (let e = 0, n = i.length; e !== n; ++e) t.push(No.toJSON(i[e]));
        return n;
      }
      static CreateFromMorphTargetSequence(e, t, i, n) {
        const s = t.length,
          r = [];
        for (let e = 0; e < s; e++) {
          let a = [],
            o = [];
          a.push((e + s - 1) % s, e, (e + 1) % s), o.push(0, 1, 0);
          const l = Po.getKeyframeOrder(a);
          (a = Po.sortedArray(a, 1, l)),
            (o = Po.sortedArray(o, 1, l)),
            n || 0 !== a[0] || (a.push(s), o.push(o[0])),
            r.push(new ko('.morphTargetInfluences[' + t[e].name + ']', a, o).scale(1 / i));
        }
        return new this(e, -1, r);
      }
      static findByName(e, t) {
        let i = e;
        if (!Array.isArray(e)) {
          const t = e;
          i = (t.geometry && t.geometry.animations) || t.animations;
        }
        for (let e = 0; e < i.length; e++) if (i[e].name === t) return i[e];
        return null;
      }
      static CreateClipsFromMorphTargetSequences(e, t, i) {
        const n = {},
          s = /^([\w-]*?)([\d]+)$/;
        for (let t = 0, i = e.length; t < i; t++) {
          const i = e[t],
            r = i.name.match(s);
          if (r && r.length > 1) {
            const e = r[1];
            let t = n[e];
            t || (n[e] = t = []), t.push(i);
          }
        }
        const r = [];
        for (const e in n) r.push(this.CreateFromMorphTargetSequence(e, n[e], t, i));
        return r;
      }
      static parseAnimation(e, t) {
        if (!e) return null;
        const i = function (e, t, i, n, s) {
            if (0 !== i.length) {
              const r = [],
                a = [];
              Po.flattenJSON(i, r, a, n), 0 !== r.length && s.push(new e(t, r, a));
            }
          },
          n = [],
          s = e.name || 'default',
          r = e.fps || 30,
          a = e.blendMode;
        let o = e.length || -1;
        const l = e.hierarchy || [];
        for (let e = 0; e < l.length; e++) {
          const s = l[e].keys;
          if (s && 0 !== s.length)
            if (s[0].morphTargets) {
              const e = {};
              let t;
              for (t = 0; t < s.length; t++)
                if (s[t].morphTargets) for (let i = 0; i < s[t].morphTargets.length; i++) e[s[t].morphTargets[i]] = -1;
              for (const i in e) {
                const e = [],
                  r = [];
                for (let n = 0; n !== s[t].morphTargets.length; ++n) {
                  const n = s[t];
                  e.push(n.time), r.push(n.morphTarget === i ? 1 : 0);
                }
                n.push(new ko('.morphTargetInfluence[' + i + ']', e, r));
              }
              o = e.length * r;
            } else {
              const r = '.bones[' + t[e].name + ']';
              i(Vo, r + '.position', s, 'pos', n),
                i(Bo, r + '.quaternion', s, 'rot', n),
                i(Vo, r + '.scale', s, 'scl', n);
            }
        }
        if (0 === n.length) return null;
        return new this(s, o, n, a);
      }
      resetDuration() {
        let e = 0;
        for (let t = 0, i = this.tracks.length; t !== i; ++t) {
          const i = this.tracks[t];
          e = Math.max(e, i.times[i.times.length - 1]);
        }
        return (this.duration = e), this;
      }
      trim() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
        return this;
      }
      validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
        return e;
      }
      optimize() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this;
      }
      clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
        return new this.constructor(this.name, this.duration, e, this.blendMode);
      }
      toJSON() {
        return this.constructor.toJSON(this);
      }
    }
    function jo(e) {
      if (void 0 === e.type) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
      const t = (function (e) {
        switch (e.toLowerCase()) {
          case 'scalar':
          case 'double':
          case 'float':
          case 'number':
          case 'integer':
            return ko;
          case 'vector':
          case 'vector2':
          case 'vector3':
          case 'vector4':
            return Vo;
          case 'color':
            return Fo;
          case 'quaternion':
            return Bo;
          case 'bool':
          case 'boolean':
            return zo;
          case 'string':
            return Go;
        }
        throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + e);
      })(e.type);
      if (void 0 === e.times) {
        const t = [],
          i = [];
        Po.flattenJSON(e.keys, t, i, 'value'), (e.times = t), (e.values = i);
      }
      return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation);
    }
    const Wo = {
      enabled: !1,
      files: {},
      add: function (e, t) {
        !1 !== this.enabled && (this.files[e] = t);
      },
      get: function (e) {
        if (!1 !== this.enabled) return this.files[e];
      },
      remove: function (e) {
        delete this.files[e];
      },
      clear: function () {
        this.files = {};
      },
    };
    class Xo {
      constructor(e, t, i) {
        const n = this;
        let s,
          r = !1,
          a = 0,
          o = 0;
        const l = [];
        (this.onStart = void 0),
          (this.onLoad = e),
          (this.onProgress = t),
          (this.onError = i),
          (this.itemStart = function (e) {
            o++, !1 === r && void 0 !== n.onStart && n.onStart(e, a, o), (r = !0);
          }),
          (this.itemEnd = function (e) {
            a++,
              void 0 !== n.onProgress && n.onProgress(e, a, o),
              a === o && ((r = !1), void 0 !== n.onLoad && n.onLoad());
          }),
          (this.itemError = function (e) {
            void 0 !== n.onError && n.onError(e);
          }),
          (this.resolveURL = function (e) {
            return s ? s(e) : e;
          }),
          (this.setURLModifier = function (e) {
            return (s = e), this;
          }),
          (this.addHandler = function (e, t) {
            return l.push(e, t), this;
          }),
          (this.removeHandler = function (e) {
            const t = l.indexOf(e);
            return -1 !== t && l.splice(t, 2), this;
          }),
          (this.getHandler = function (e) {
            for (let t = 0, i = l.length; t < i; t += 2) {
              const i = l[t],
                n = l[t + 1];
              if ((i.global && (i.lastIndex = 0), i.test(e))) return n;
            }
            return null;
          });
      }
    }
    const qo = new Xo();
    class Yo {
      constructor(e) {
        (this.manager = void 0 !== e ? e : qo),
          (this.crossOrigin = 'anonymous'),
          (this.withCredentials = !1),
          (this.path = ''),
          (this.resourcePath = ''),
          (this.requestHeader = {});
      }
      load() {}
      loadAsync(e, t) {
        const i = this;
        return new Promise(function (n, s) {
          i.load(e, n, t, s);
        });
      }
      parse() {}
      setCrossOrigin(e) {
        return (this.crossOrigin = e), this;
      }
      setWithCredentials(e) {
        return (this.withCredentials = e), this;
      }
      setPath(e) {
        return (this.path = e), this;
      }
      setResourcePath(e) {
        return (this.resourcePath = e), this;
      }
      setRequestHeader(e) {
        return (this.requestHeader = e), this;
      }
    }
    const Zo = {};
    class Jo extends Yo {
      constructor(e) {
        super(e);
      }
      load(e, t, i, n) {
        void 0 === e && (e = ''), void 0 !== this.path && (e = this.path + e), (e = this.manager.resolveURL(e));
        const s = Wo.get(e);
        if (void 0 !== s)
          return (
            this.manager.itemStart(e),
            setTimeout(() => {
              t && t(s), this.manager.itemEnd(e);
            }, 0),
            s
          );
        if (void 0 !== Zo[e]) return void Zo[e].push({ onLoad: t, onProgress: i, onError: n });
        (Zo[e] = []), Zo[e].push({ onLoad: t, onProgress: i, onError: n });
        const r = new Request(e, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? 'include' : 'same-origin',
          }),
          a = this.mimeType,
          o = this.responseType;
        fetch(r)
          .then((t) => {
            if (200 === t.status || 0 === t.status) {
              if ((t.status, 'undefined' == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader))
                return t;
              const i = Zo[e],
                n = t.body.getReader(),
                s = t.headers.get('Content-Length'),
                r = s ? parseInt(s) : 0,
                a = 0 !== r;
              let o = 0;
              const l = new ReadableStream({
                start(e) {
                  !(function t() {
                    n.read().then(({ done: n, value: s }) => {
                      if (n) e.close();
                      else {
                        o += s.byteLength;
                        const n = new ProgressEvent('progress', { lengthComputable: a, loaded: o, total: r });
                        for (let e = 0, t = i.length; e < t; e++) {
                          const t = i[e];
                          t.onProgress && t.onProgress(n);
                        }
                        e.enqueue(s), t();
                      }
                    });
                  })();
                },
              });
              return new Response(l);
            }
            throw Error(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`);
          })
          .then((e) => {
            switch (o) {
              case 'arraybuffer':
                return e.arrayBuffer();
              case 'blob':
                return e.blob();
              case 'document':
                return e.text().then((e) => new DOMParser().parseFromString(e, a));
              case 'json':
                return e.json();
              default:
                if (void 0 === a) return e.text();
                {
                  const t = /charset="?([^;"\s]*)"?/i.exec(a),
                    i = t && t[1] ? t[1].toLowerCase() : void 0,
                    n = new TextDecoder(i);
                  return e.arrayBuffer().then((e) => n.decode(e));
                }
            }
          })
          .then((t) => {
            Wo.add(e, t);
            const i = Zo[e];
            delete Zo[e];
            for (let e = 0, n = i.length; e < n; e++) {
              const n = i[e];
              n.onLoad && n.onLoad(t);
            }
          })
          .catch((t) => {
            const i = Zo[e];
            if (void 0 === i) throw (this.manager.itemError(e), t);
            delete Zo[e];
            for (let e = 0, n = i.length; e < n; e++) {
              const n = i[e];
              n.onError && n.onError(t);
            }
            this.manager.itemError(e);
          })
          .finally(() => {
            this.manager.itemEnd(e);
          }),
          this.manager.itemStart(e);
      }
      setResponseType(e) {
        return (this.responseType = e), this;
      }
      setMimeType(e) {
        return (this.mimeType = e), this;
      }
    }
    class Ko extends Yo {
      constructor(e) {
        super(e);
      }
      load(e, t, i, n) {
        void 0 !== this.path && (e = this.path + e), (e = this.manager.resolveURL(e));
        const s = this,
          r = Wo.get(e);
        if (void 0 !== r)
          return (
            s.manager.itemStart(e),
            setTimeout(function () {
              t && t(r), s.manager.itemEnd(e);
            }, 0),
            r
          );
        const a = oe('img');
        function o() {
          h(), Wo.add(e, this), t && t(this), s.manager.itemEnd(e);
        }
        function l(t) {
          h(), n && n(t), s.manager.itemError(e), s.manager.itemEnd(e);
        }
        function h() {
          a.removeEventListener('load', o, !1), a.removeEventListener('error', l, !1);
        }
        return (
          a.addEventListener('load', o, !1),
          a.addEventListener('error', l, !1),
          'data:' !== e.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
          s.manager.itemStart(e),
          (a.src = e),
          a
        );
      }
    }
    class $o extends Yo {
      constructor(e) {
        super(e);
      }
      load(e, t, i, n) {
        const s = new we(),
          r = new Ko(this.manager);
        return (
          r.setCrossOrigin(this.crossOrigin),
          r.setPath(this.path),
          r.load(
            e,
            function (e) {
              (s.image = e), (s.needsUpdate = !0), void 0 !== t && t(s);
            },
            i,
            n,
          ),
          s
        );
      }
    }
    class Qo extends It {
      constructor(e, t = 1) {
        super(), (this.isLight = !0), (this.type = 'Light'), (this.color = new ve(e)), (this.intensity = t);
      }
      dispose() {}
      copy(e, t) {
        return super.copy(e, t), this.color.copy(e.color), (this.intensity = e.intensity), this;
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.color = this.color.getHex()),
          (t.object.intensity = this.intensity),
          void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
          void 0 !== this.distance && (t.object.distance = this.distance),
          void 0 !== this.angle && (t.object.angle = this.angle),
          void 0 !== this.decay && (t.object.decay = this.decay),
          void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
          void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
          t
        );
      }
    }
    const el = new ot(),
      tl = new Pe(),
      il = new Pe();
    class nl {
      constructor(e) {
        (this.camera = e),
          (this.bias = 0),
          (this.normalBias = 0),
          (this.radius = 1),
          (this.blurSamples = 8),
          (this.mapSize = new se(512, 512)),
          (this.map = null),
          (this.mapPass = null),
          (this.matrix = new ot()),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this._frustum = new Hi()),
          (this._frameExtents = new se(1, 1)),
          (this._viewportCount = 1),
          (this._viewports = [new Ae(0, 0, 1, 1)]);
      }
      getViewportCount() {
        return this._viewportCount;
      }
      getFrustum() {
        return this._frustum;
      }
      updateMatrices(e) {
        const t = this.camera,
          i = this.matrix;
        tl.setFromMatrixPosition(e.matrixWorld),
          t.position.copy(tl),
          il.setFromMatrixPosition(e.target.matrixWorld),
          t.lookAt(il),
          t.updateMatrixWorld(),
          el.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(el),
          i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
          i.multiply(t.projectionMatrix),
          i.multiply(t.matrixWorldInverse);
      }
      getViewport(e) {
        return this._viewports[e];
      }
      getFrameExtents() {
        return this._frameExtents;
      }
      dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
      }
      copy(e) {
        return (
          (this.camera = e.camera.clone()),
          (this.bias = e.bias),
          (this.radius = e.radius),
          this.mapSize.copy(e.mapSize),
          this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const e = {};
        return (
          0 !== this.bias && (e.bias = this.bias),
          0 !== this.normalBias && (e.normalBias = this.normalBias),
          1 !== this.radius && (e.radius = this.radius),
          (512 === this.mapSize.x && 512 === this.mapSize.y) || (e.mapSize = this.mapSize.toArray()),
          (e.camera = this.camera.toJSON(!1).object),
          delete e.camera.matrix,
          e
        );
      }
    }
    class sl extends nl {
      constructor() {
        super(new Ii(50, 1, 0.5, 500)), (this.isSpotLightShadow = !0), (this.focus = 1);
      }
      updateMatrices(e) {
        const t = this.camera,
          i = 2 * Z * e.angle * this.focus,
          n = this.mapSize.width / this.mapSize.height,
          s = e.distance || t.far;
        (i === t.fov && n === t.aspect && s === t.far) ||
          ((t.fov = i), (t.aspect = n), (t.far = s), t.updateProjectionMatrix()),
          super.updateMatrices(e);
      }
      copy(e) {
        return super.copy(e), (this.focus = e.focus), this;
      }
    }
    class rl extends Qo {
      constructor(e, t, i = 0, n = Math.PI / 3, s = 0, r = 1) {
        super(e, t),
          (this.isSpotLight = !0),
          (this.type = 'SpotLight'),
          this.position.copy(It.DefaultUp),
          this.updateMatrix(),
          (this.target = new It()),
          (this.distance = i),
          (this.angle = n),
          (this.penumbra = s),
          (this.decay = r),
          (this.shadow = new sl());
      }
      get power() {
        return this.intensity * Math.PI;
      }
      set power(e) {
        this.intensity = e / Math.PI;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.distance = e.distance),
          (this.angle = e.angle),
          (this.penumbra = e.penumbra),
          (this.decay = e.decay),
          (this.target = e.target.clone()),
          (this.shadow = e.shadow.clone()),
          this
        );
      }
    }
    const al = new ot(),
      ol = new Pe(),
      ll = new Pe();
    class hl extends nl {
      constructor() {
        super(new Ii(90, 1, 0.5, 500)),
          (this.isPointLightShadow = !0),
          (this._frameExtents = new se(4, 2)),
          (this._viewportCount = 6),
          (this._viewports = [
            new Ae(2, 1, 1, 1),
            new Ae(0, 1, 1, 1),
            new Ae(3, 1, 1, 1),
            new Ae(1, 1, 1, 1),
            new Ae(3, 0, 1, 1),
            new Ae(1, 0, 1, 1),
          ]),
          (this._cubeDirections = [
            new Pe(1, 0, 0),
            new Pe(-1, 0, 0),
            new Pe(0, 0, 1),
            new Pe(0, 0, -1),
            new Pe(0, 1, 0),
            new Pe(0, -1, 0),
          ]),
          (this._cubeUps = [
            new Pe(0, 1, 0),
            new Pe(0, 1, 0),
            new Pe(0, 1, 0),
            new Pe(0, 1, 0),
            new Pe(0, 0, 1),
            new Pe(0, 0, -1),
          ]);
      }
      updateMatrices(e, t = 0) {
        const i = this.camera,
          n = this.matrix,
          s = e.distance || i.far;
        s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
          ol.setFromMatrixPosition(e.matrixWorld),
          i.position.copy(ol),
          ll.copy(i.position),
          ll.add(this._cubeDirections[t]),
          i.up.copy(this._cubeUps[t]),
          i.lookAt(ll),
          i.updateMatrixWorld(),
          n.makeTranslation(-ol.x, -ol.y, -ol.z),
          al.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(al);
      }
    }
    class cl extends Qo {
      constructor(e, t, i = 0, n = 1) {
        super(e, t),
          (this.isPointLight = !0),
          (this.type = 'PointLight'),
          (this.distance = i),
          (this.decay = n),
          (this.shadow = new hl());
      }
      get power() {
        return 4 * this.intensity * Math.PI;
      }
      set power(e) {
        this.intensity = e / (4 * Math.PI);
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e, t) {
        return (
          super.copy(e, t), (this.distance = e.distance), (this.decay = e.decay), (this.shadow = e.shadow.clone()), this
        );
      }
    }
    class ul extends nl {
      constructor() {
        super(new nn(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
      }
    }
    class dl extends Qo {
      constructor(e, t) {
        super(e, t),
          (this.isDirectionalLight = !0),
          (this.type = 'DirectionalLight'),
          this.position.copy(It.DefaultUp),
          this.updateMatrix(),
          (this.target = new It()),
          (this.shadow = new ul());
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e) {
        return super.copy(e), (this.target = e.target.clone()), (this.shadow = e.shadow.clone()), this;
      }
    }
    class ml extends Qo {
      constructor(e, t) {
        super(e, t), (this.isAmbientLight = !0), (this.type = 'AmbientLight');
      }
    }
    class pl {
      static decodeText(e) {
        if ('undefined' != typeof TextDecoder) return new TextDecoder().decode(e);
        let t = '';
        for (let i = 0, n = e.length; i < n; i++) t += String.fromCharCode(e[i]);
        try {
          return decodeURIComponent(escape(t));
        } catch (e) {
          return t;
        }
      }
      static extractUrlBase(e) {
        const t = e.lastIndexOf('/');
        return -1 === t ? './' : e.slice(0, t + 1);
      }
      static resolveURL(e, t) {
        return 'string' != typeof e || '' === e
          ? ''
          : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
            /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
      }
    }
    class fl extends ai {
      constructor() {
        super(),
          (this.isInstancedBufferGeometry = !0),
          (this.type = 'InstancedBufferGeometry'),
          (this.instanceCount = 1 / 0);
      }
      copy(e) {
        return super.copy(e), (this.instanceCount = e.instanceCount), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const e = super.toJSON(this);
        return (e.instanceCount = this.instanceCount), (e.isInstancedBufferGeometry = !0), e;
      }
    }
    class gl extends Yo {
      constructor(e) {
        super(e), (this.isImageBitmapLoader = !0), (this.options = { premultiplyAlpha: 'none' });
      }
      setOptions(e) {
        return (this.options = e), this;
      }
      load(e, t, i, n) {
        void 0 === e && (e = ''), void 0 !== this.path && (e = this.path + e), (e = this.manager.resolveURL(e));
        const s = this,
          r = Wo.get(e);
        if (void 0 !== r)
          return (
            s.manager.itemStart(e),
            setTimeout(function () {
              t && t(r), s.manager.itemEnd(e);
            }, 0),
            r
          );
        const a = {};
        (a.credentials = 'anonymous' === this.crossOrigin ? 'same-origin' : 'include'),
          (a.headers = this.requestHeader),
          fetch(e, a)
            .then(function (e) {
              return e.blob();
            })
            .then(function (e) {
              return createImageBitmap(e, Object.assign(s.options, { colorSpaceConversion: 'none' }));
            })
            .then(function (i) {
              Wo.add(e, i), t && t(i), s.manager.itemEnd(e);
            })
            .catch(function (t) {
              n && n(t), s.manager.itemError(e), s.manager.itemEnd(e);
            }),
          s.manager.itemStart(e);
      }
    }
    const _l = '\\[\\]\\.:\\/',
      vl = new RegExp('[\\[\\]\\.:\\/]', 'g'),
      xl = '[^\\[\\]\\.:\\/]',
      yl = '[^' + _l.replace('\\.', '') + ']',
      Ml = new RegExp(
        '^' +
          /((?:WC+[\/:])*)/.source.replace('WC', xl) +
          /(WCOD+)?/.source.replace('WCOD', yl) +
          /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', xl) +
          /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', xl) +
          '$',
      ),
      bl = ['material', 'materials', 'bones'];
    class Sl {
      constructor(e, t, i) {
        (this.path = t),
          (this.parsedPath = i || Sl.parseTrackName(t)),
          (this.node = Sl.findNode(e, this.parsedPath.nodeName) || e),
          (this.rootNode = e),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      }
      static create(e, t, i) {
        return e && e.isAnimationObjectGroup ? new Sl.Composite(e, t, i) : new Sl(e, t, i);
      }
      static sanitizeNodeName(e) {
        return e.replace(/\s/g, '_').replace(vl, '');
      }
      static parseTrackName(e) {
        const t = Ml.exec(e);
        if (null === t) throw new Error('PropertyBinding: Cannot parse trackName: ' + e);
        const i = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] },
          n = i.nodeName && i.nodeName.lastIndexOf('.');
        if (void 0 !== n && -1 !== n) {
          const e = i.nodeName.substring(n + 1);
          -1 !== bl.indexOf(e) && ((i.nodeName = i.nodeName.substring(0, n)), (i.objectName = e));
        }
        if (null === i.propertyName || 0 === i.propertyName.length)
          throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + e);
        return i;
      }
      static findNode(e, t) {
        if (void 0 === t || '' === t || '.' === t || -1 === t || t === e.name || t === e.uuid) return e;
        if (e.skeleton) {
          const i = e.skeleton.getBoneByName(t);
          if (void 0 !== i) return i;
        }
        if (e.children) {
          const i = function (e) {
              for (let n = 0; n < e.length; n++) {
                const s = e[n];
                if (s.name === t || s.uuid === t) return s;
                const r = i(s.children);
                if (r) return r;
              }
              return null;
            },
            n = i(e.children);
          if (n) return n;
        }
        return null;
      }
      _getValue_unavailable() {}
      _setValue_unavailable() {}
      _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName];
      }
      _getValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let n = 0, s = i.length; n !== s; ++n) e[t++] = i[n];
      }
      _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t);
      }
      _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t];
      }
      _setValue_direct_setNeedsUpdate(e, t) {
        (this.targetObject[this.propertyName] = e[t]), (this.targetObject.needsUpdate = !0);
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        (this.targetObject[this.propertyName] = e[t]), (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _setValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let n = 0, s = i.length; n !== s; ++n) i[n] = e[t++];
      }
      _setValue_array_setNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let n = 0, s = i.length; n !== s; ++n) i[n] = e[t++];
        this.targetObject.needsUpdate = !0;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let n = 0, s = i.length; n !== s; ++n) i[n] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
      }
      _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t];
      }
      _setValue_arrayElement_setNeedsUpdate(e, t) {
        (this.resolvedProperty[this.propertyIndex] = e[t]), (this.targetObject.needsUpdate = !0);
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        (this.resolvedProperty[this.propertyIndex] = e[t]), (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t);
      }
      _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _getValue_unbound(e, t) {
        this.bind(), this.getValue(e, t);
      }
      _setValue_unbound(e, t) {
        this.bind(), this.setValue(e, t);
      }
      bind() {
        let e = this.node;
        const t = this.parsedPath,
          i = t.objectName,
          n = t.propertyName;
        let s = t.propertyIndex;
        if (
          (e || ((e = Sl.findNode(this.rootNode, t.nodeName) || this.rootNode), (this.node = e)),
          (this.getValue = this._getValue_unavailable),
          (this.setValue = this._setValue_unavailable),
          !e)
        )
          return;
        if (i) {
          let n = t.objectIndex;
          switch (i) {
            case 'materials':
              if (!e.material) return;
              if (!e.material.materials) return;
              e = e.material.materials;
              break;
            case 'bones':
              if (!e.skeleton) return;
              e = e.skeleton.bones;
              for (let t = 0; t < e.length; t++)
                if (e[t].name === n) {
                  n = t;
                  break;
                }
              break;
            default:
              if (void 0 === e[i]) return;
              e = e[i];
          }
          if (void 0 !== n) {
            if (void 0 === e[n]) return;
            e = e[n];
          }
        }
        const r = e[n];
        if (void 0 === r) {
          t.nodeName;
          return;
        }
        let a = this.Versioning.None;
        (this.targetObject = e),
          void 0 !== e.needsUpdate
            ? (a = this.Versioning.NeedsUpdate)
            : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let o = this.BindingType.Direct;
        if (void 0 !== s) {
          if ('morphTargetInfluences' === n) {
            if (!e.geometry) return;
            if (!e.geometry.morphAttributes) return;
            void 0 !== e.morphTargetDictionary[s] && (s = e.morphTargetDictionary[s]);
          }
          (o = this.BindingType.ArrayElement), (this.resolvedProperty = r), (this.propertyIndex = s);
        } else
          void 0 !== r.fromArray && void 0 !== r.toArray
            ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = r))
            : Array.isArray(r)
            ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = r))
            : (this.propertyName = n);
        (this.getValue = this.GetterByBindingType[o]), (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
      }
      unbind() {
        (this.node = null), (this.getValue = this._getValue_unbound), (this.setValue = this._setValue_unbound);
      }
    }
    (Sl.Composite = class {
      constructor(e, t, i) {
        const n = i || Sl.parseTrackName(t);
        (this._targetGroup = e), (this._bindings = e.subscribe_(t, n));
      }
      getValue(e, t) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_,
          n = this._bindings[i];
        void 0 !== n && n.getValue(e, t);
      }
      setValue(e, t) {
        const i = this._bindings;
        for (let n = this._targetGroup.nCachedObjects_, s = i.length; n !== s; ++n) i[n].setValue(e, t);
      }
      bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind();
      }
      unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind();
      }
    }),
      (Sl.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }),
      (Sl.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }),
      (Sl.prototype.GetterByBindingType = [
        Sl.prototype._getValue_direct,
        Sl.prototype._getValue_array,
        Sl.prototype._getValue_arrayElement,
        Sl.prototype._getValue_toArray,
      ]),
      (Sl.prototype.SetterByBindingTypeAndVersioning = [
        [
          Sl.prototype._setValue_direct,
          Sl.prototype._setValue_direct_setNeedsUpdate,
          Sl.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
        ],
        [
          Sl.prototype._setValue_array,
          Sl.prototype._setValue_array_setNeedsUpdate,
          Sl.prototype._setValue_array_setMatrixWorldNeedsUpdate,
        ],
        [
          Sl.prototype._setValue_arrayElement,
          Sl.prototype._setValue_arrayElement_setNeedsUpdate,
          Sl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ],
        [
          Sl.prototype._setValue_fromArray,
          Sl.prototype._setValue_fromArray_setNeedsUpdate,
          Sl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
        ],
      ]);
    class wl extends Tr {
      constructor(e, t, i = 1) {
        super(e, t), (this.isInstancedInterleavedBuffer = !0), (this.meshPerAttribute = i);
      }
      copy(e) {
        return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
      }
      clone(e) {
        const t = super.clone(e);
        return (t.meshPerAttribute = this.meshPerAttribute), t;
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (t.isInstancedInterleavedBuffer = !0), (t.meshPerAttribute = this.meshPerAttribute), t;
      }
    }
    class Al {
      constructor(e, t, i = 0, n = 1 / 0) {
        (this.ray = new at(e, t)),
          (this.near = i),
          (this.far = n),
          (this.camera = null),
          (this.layers = new vt()),
          (this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} });
      }
      set(e, t) {
        this.ray.set(e, t);
      }
      setFromCamera(e, t) {
        t.isPerspectiveCamera
          ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
            this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(),
            (this.camera = t))
          : t.isOrthographicCamera &&
            (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
            this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
            (this.camera = t));
      }
      intersectObject(e, t = !0, i = []) {
        return El(e, this, i, t), i.sort(Tl), i;
      }
      intersectObjects(e, t = !0, i = []) {
        for (let n = 0, s = e.length; n < s; n++) El(e[n], this, i, t);
        return i.sort(Tl), i;
      }
    }
    function Tl(e, t) {
      return e.distance - t.distance;
    }
    function El(e, t, i, n) {
      if ((e.layers.test(t.layers) && e.raycast(t, i), !0 === n)) {
        const n = e.children;
        for (let e = 0, s = n.length; e < s; e++) El(n[e], t, i, !0);
      }
    }
    const Ll = new Pe(),
      Cl = new Pe();
    class Pl {
      constructor(e = new Pe(), t = new Pe()) {
        (this.start = e), (this.end = t);
      }
      set(e, t) {
        return this.start.copy(e), this.end.copy(t), this;
      }
      copy(e) {
        return this.start.copy(e.start), this.end.copy(e.end), this;
      }
      getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(0.5);
      }
      delta(e) {
        return e.subVectors(this.end, this.start);
      }
      distanceSq() {
        return this.start.distanceToSquared(this.end);
      }
      distance() {
        return this.start.distanceTo(this.end);
      }
      at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start);
      }
      closestPointToPointParameter(e, t) {
        Ll.subVectors(e, this.start), Cl.subVectors(this.end, this.start);
        const i = Cl.dot(Cl);
        let n = Cl.dot(Ll) / i;
        return t && (n = K(n, 0, 1)), n;
      }
      closestPointToPoint(e, t, i) {
        const n = this.closestPointToPointParameter(e, t);
        return this.delta(i).multiplyScalar(n).add(this.start);
      }
      applyMatrix4(e) {
        return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
      }
      equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end);
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    const Dl = new Re();
    class Il extends _a {
      constructor(e, t = 16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
          n = new Float32Array(24),
          s = new ai();
        s.setIndex(new Zt(i, 1)),
          s.setAttribute('position', new Zt(n, 3)),
          super(s, new la({ color: t, toneMapped: !1 })),
          (this.object = e),
          (this.type = 'BoxHelper'),
          (this.matrixAutoUpdate = !1),
          this.update();
      }
      update(e) {
        if ((void 0 !== this.object && Dl.setFromObject(this.object), Dl.isEmpty())) return;
        const t = Dl.min,
          i = Dl.max,
          n = this.geometry.attributes.position,
          s = n.array;
        (s[0] = i.x),
          (s[1] = i.y),
          (s[2] = i.z),
          (s[3] = t.x),
          (s[4] = i.y),
          (s[5] = i.z),
          (s[6] = t.x),
          (s[7] = t.y),
          (s[8] = i.z),
          (s[9] = i.x),
          (s[10] = t.y),
          (s[11] = i.z),
          (s[12] = i.x),
          (s[13] = i.y),
          (s[14] = t.z),
          (s[15] = t.x),
          (s[16] = i.y),
          (s[17] = t.z),
          (s[18] = t.x),
          (s[19] = t.y),
          (s[20] = t.z),
          (s[21] = i.x),
          (s[22] = t.y),
          (s[23] = t.z),
          (n.needsUpdate = !0),
          this.geometry.computeBoundingSphere();
      }
      setFromObject(e) {
        return (this.object = e), this.update(), this;
      }
      copy(e, t) {
        return super.copy(e, t), (this.object = e.object), this;
      }
    }
    class Rl extends _a {
      constructor(e, t = 16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
          n = new ai();
        n.setIndex(new Zt(i, 1)),
          n.setAttribute(
            'position',
            new $t([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3),
          ),
          super(n, new la({ color: t, toneMapped: !1 })),
          (this.box = e),
          (this.type = 'Box3Helper'),
          this.geometry.computeBoundingSphere();
      }
      updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() ||
          (t.getCenter(this.position),
          t.getSize(this.scale),
          this.scale.multiplyScalar(0.5),
          super.updateMatrixWorld(e));
      }
    }
    class Ol extends _a {
      constructor(e = 1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
          i = new ai();
        i.setAttribute('position', new $t(t, 3)),
          i.setAttribute('color', new $t([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3));
        super(i, new la({ vertexColors: !0, toneMapped: !1 })), (this.type = 'AxesHelper');
      }
      setColors(e, t, i) {
        const n = new ve(),
          s = this.geometry.attributes.color.array;
        return (
          n.set(e),
          n.toArray(s, 0),
          n.toArray(s, 3),
          n.set(t),
          n.toArray(s, 6),
          n.toArray(s, 9),
          n.set(i),
          n.toArray(s, 12),
          n.toArray(s, 15),
          (this.geometry.attributes.color.needsUpdate = !0),
          this
        );
      }
      dispose() {
        this.geometry.dispose(), this.material.dispose();
      }
    }
    const {
      floatView: Nl,
      uint32View: zl,
      baseTable: Fl,
      shiftTable: kl,
      mantissaTable: Ul,
      exponentTable: Bl,
      offsetTable: Gl,
    } = Vl();
    function Vl() {
      const e = new ArrayBuffer(4),
        t = new Float32Array(e),
        i = new Uint32Array(e),
        n = new Uint32Array(512),
        s = new Uint32Array(512);
      for (let e = 0; e < 256; ++e) {
        const t = e - 127;
        t < -27
          ? ((n[e] = 0), (n[256 | e] = 32768), (s[e] = 24), (s[256 | e] = 24))
          : t < -14
          ? ((n[e] = 1024 >> (-t - 14)),
            (n[256 | e] = (1024 >> (-t - 14)) | 32768),
            (s[e] = -t - 1),
            (s[256 | e] = -t - 1))
          : t <= 15
          ? ((n[e] = (t + 15) << 10), (n[256 | e] = ((t + 15) << 10) | 32768), (s[e] = 13), (s[256 | e] = 13))
          : t < 128
          ? ((n[e] = 31744), (n[256 | e] = 64512), (s[e] = 24), (s[256 | e] = 24))
          : ((n[e] = 31744), (n[256 | e] = 64512), (s[e] = 13), (s[256 | e] = 13));
      }
      const r = new Uint32Array(2048),
        a = new Uint32Array(64),
        o = new Uint32Array(64);
      for (let e = 1; e < 1024; ++e) {
        let t = e << 13,
          i = 0;
        for (; 0 == (8388608 & t); ) (t <<= 1), (i -= 8388608);
        (t &= -8388609), (i += 947912704), (r[e] = t | i);
      }
      for (let e = 1024; e < 2048; ++e) r[e] = 939524096 + ((e - 1024) << 13);
      for (let e = 1; e < 31; ++e) a[e] = e << 23;
      (a[31] = 1199570944), (a[32] = 2147483648);
      for (let e = 33; e < 63; ++e) a[e] = 2147483648 + ((e - 32) << 23);
      a[63] = 3347054592;
      for (let e = 1; e < 64; ++e) 32 !== e && (o[e] = 1024);
      return {
        floatView: t,
        uint32View: i,
        baseTable: n,
        shiftTable: s,
        mantissaTable: r,
        exponentTable: a,
        offsetTable: o,
      };
    }
    'undefined' != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', { detail: { revision: n } })),
      'undefined' != typeof window && (window.__THREE__ || (window.__THREE__ = n));
    class Hl extends Yo {
      constructor(e) {
        super(e),
          (this.dracoLoader = null),
          (this.ktx2Loader = null),
          (this.meshoptDecoder = null),
          (this.pluginCallbacks = []),
          this.register(function (e) {
            return new Zl(e);
          }),
          this.register(function (e) {
            return new ih(e);
          }),
          this.register(function (e) {
            return new nh(e);
          }),
          this.register(function (e) {
            return new Kl(e);
          }),
          this.register(function (e) {
            return new $l(e);
          }),
          this.register(function (e) {
            return new Ql(e);
          }),
          this.register(function (e) {
            return new eh(e);
          }),
          this.register(function (e) {
            return new Yl(e);
          }),
          this.register(function (e) {
            return new th(e);
          }),
          this.register(function (e) {
            return new Jl(e);
          }),
          this.register(function (e) {
            return new Xl(e);
          }),
          this.register(function (e) {
            return new sh(e);
          });
      }
      load(e, t, i, n) {
        const s = this;
        let r;
        (r = '' !== this.resourcePath ? this.resourcePath : '' !== this.path ? this.path : pl.extractUrlBase(e)),
          this.manager.itemStart(e);
        const a = function (t) {
            n && n(t), s.manager.itemError(e), s.manager.itemEnd(e);
          },
          o = new Jo(this.manager);
        o.setPath(this.path),
          o.setResponseType('arraybuffer'),
          o.setRequestHeader(this.requestHeader),
          o.setWithCredentials(this.withCredentials),
          o.load(
            e,
            function (i) {
              try {
                s.parse(
                  i,
                  r,
                  function (i) {
                    t(i), s.manager.itemEnd(e);
                  },
                  a,
                );
              } catch (e) {
                a(e);
              }
            },
            i,
            a,
          );
      }
      setDRACOLoader(e) {
        return (this.dracoLoader = e), this;
      }
      setDDSLoader() {
        throw new Error(
          'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".',
        );
      }
      setKTX2Loader(e) {
        return (this.ktx2Loader = e), this;
      }
      setMeshoptDecoder(e) {
        return (this.meshoptDecoder = e), this;
      }
      register(e) {
        return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this;
      }
      unregister(e) {
        return (
          -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
          this
        );
      }
      parse(e, t, i, n) {
        let s;
        const r = {},
          a = {};
        if ('string' == typeof e) s = e;
        else {
          if (pl.decodeText(new Uint8Array(e, 0, 4)) === rh) {
            try {
              r[Wl.KHR_BINARY_GLTF] = new lh(e);
            } catch (e) {
              return void (n && n(e));
            }
            s = r[Wl.KHR_BINARY_GLTF].content;
          } else s = pl.decodeText(new Uint8Array(e));
        }
        const o = JSON.parse(s);
        if (void 0 === o.asset || o.asset.version[0] < 2)
          return void (n && n(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.')));
        const l = new Bh(o, {
          path: t || this.resourcePath || '',
          crossOrigin: this.crossOrigin,
          requestHeader: this.requestHeader,
          manager: this.manager,
          ktx2Loader: this.ktx2Loader,
          meshoptDecoder: this.meshoptDecoder,
        });
        l.fileLoader.setRequestHeader(this.requestHeader);
        for (let e = 0; e < this.pluginCallbacks.length; e++) {
          const t = this.pluginCallbacks[e](l);
          (a[t.name] = t), (r[t.name] = !0);
        }
        if (o.extensionsUsed)
          for (let e = 0; e < o.extensionsUsed.length; ++e) {
            const t = o.extensionsUsed[e],
              i = o.extensionsRequired || [];
            switch (t) {
              case Wl.KHR_MATERIALS_UNLIT:
                r[t] = new ql();
                break;
              case Wl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                r[t] = new dh();
                break;
              case Wl.KHR_DRACO_MESH_COMPRESSION:
                r[t] = new hh(o, this.dracoLoader);
                break;
              case Wl.KHR_TEXTURE_TRANSFORM:
                r[t] = new ch();
                break;
              case Wl.KHR_MESH_QUANTIZATION:
                r[t] = new mh();
                break;
              default:
                i.indexOf(t) >= 0 && a[t];
            }
          }
        l.setExtensions(r), l.setPlugins(a), l.parse(i, n);
      }
      parseAsync(e, t) {
        const i = this;
        return new Promise(function (n, s) {
          i.parse(e, t, n, s);
        });
      }
    }
    function jl() {
      let e = {};
      return {
        get: function (t) {
          return e[t];
        },
        add: function (t, i) {
          e[t] = i;
        },
        remove: function (t) {
          delete e[t];
        },
        removeAll: function () {
          e = {};
        },
      };
    }
    const Wl = {
      KHR_BINARY_GLTF: 'KHR_binary_glTF',
      KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
      KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
      KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
      KHR_MATERIALS_IOR: 'KHR_materials_ior',
      KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
      KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
      KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
      KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
      KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
      KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
      KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
      KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
      KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
      KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
      KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
      EXT_TEXTURE_WEBP: 'EXT_texture_webp',
      EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
    };
    class Xl {
      constructor(e) {
        (this.parser = e), (this.name = Wl.KHR_LIGHTS_PUNCTUAL), (this.cache = { refs: {}, uses: {} });
      }
      _markDefs() {
        const e = this.parser,
          t = this.parser.json.nodes || [];
        for (let i = 0, n = t.length; i < n; i++) {
          const n = t[i];
          n.extensions &&
            n.extensions[this.name] &&
            void 0 !== n.extensions[this.name].light &&
            e._addNodeRef(this.cache, n.extensions[this.name].light);
        }
      }
      _loadLight(e) {
        const t = this.parser,
          i = 'light:' + e;
        let n = t.cache.get(i);
        if (n) return n;
        const s = t.json,
          r = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
        let a;
        const o = new ve(16777215);
        void 0 !== r.color && o.fromArray(r.color);
        const l = void 0 !== r.range ? r.range : 0;
        switch (r.type) {
          case 'directional':
            (a = new dl(o)), a.target.position.set(0, 0, -1), a.add(a.target);
            break;
          case 'point':
            (a = new cl(o)), (a.distance = l);
            break;
          case 'spot':
            (a = new rl(o)),
              (a.distance = l),
              (r.spot = r.spot || {}),
              (r.spot.innerConeAngle = void 0 !== r.spot.innerConeAngle ? r.spot.innerConeAngle : 0),
              (r.spot.outerConeAngle = void 0 !== r.spot.outerConeAngle ? r.spot.outerConeAngle : Math.PI / 4),
              (a.angle = r.spot.outerConeAngle),
              (a.penumbra = 1 - r.spot.innerConeAngle / r.spot.outerConeAngle),
              a.target.position.set(0, 0, -1),
              a.add(a.target);
            break;
          default:
            throw new Error('THREE.GLTFLoader: Unexpected light type: ' + r.type);
        }
        return (
          a.position.set(0, 0, 0),
          (a.decay = 2),
          void 0 !== r.intensity && (a.intensity = r.intensity),
          (a.name = t.createUniqueName(r.name || 'light_' + e)),
          (n = Promise.resolve(a)),
          t.cache.add(i, n),
          n
        );
      }
      createNodeAttachment(e) {
        const t = this,
          i = this.parser,
          n = i.json.nodes[e],
          s = ((n.extensions && n.extensions[this.name]) || {}).light;
        return void 0 === s
          ? null
          : this._loadLight(s).then(function (e) {
              return i._getNodeRef(t.cache, s, e);
            });
      }
    }
    class ql {
      constructor() {
        this.name = Wl.KHR_MATERIALS_UNLIT;
      }
      getMaterialType() {
        return Xt;
      }
      extendParams(e, t, i) {
        const n = [];
        (e.color = new ve(1, 1, 1)), (e.opacity = 1);
        const s = t.pbrMetallicRoughness;
        if (s) {
          if (Array.isArray(s.baseColorFactor)) {
            const t = s.baseColorFactor;
            e.color.fromArray(t), (e.opacity = t[3]);
          }
          void 0 !== s.baseColorTexture && n.push(i.assignTexture(e, 'map', s.baseColorTexture, k));
        }
        return Promise.all(n);
      }
    }
    class Yl {
      constructor(e) {
        (this.parser = e), (this.name = Wl.KHR_MATERIALS_EMISSIVE_STRENGTH);
      }
      extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const n = i.extensions[this.name].emissiveStrength;
        return void 0 !== n && (t.emissiveIntensity = n), Promise.resolve();
      }
    }
    class Zl {
      constructor(e) {
        (this.parser = e), (this.name = Wl.KHR_MATERIALS_CLEARCOAT);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Eo : null;
      }
      extendMaterialParams(e, t) {
        const i = this.parser,
          n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const s = [],
          r = n.extensions[this.name];
        if (
          (void 0 !== r.clearcoatFactor && (t.clearcoat = r.clearcoatFactor),
          void 0 !== r.clearcoatTexture && s.push(i.assignTexture(t, 'clearcoatMap', r.clearcoatTexture)),
          void 0 !== r.clearcoatRoughnessFactor && (t.clearcoatRoughness = r.clearcoatRoughnessFactor),
          void 0 !== r.clearcoatRoughnessTexture &&
            s.push(i.assignTexture(t, 'clearcoatRoughnessMap', r.clearcoatRoughnessTexture)),
          void 0 !== r.clearcoatNormalTexture &&
            (s.push(i.assignTexture(t, 'clearcoatNormalMap', r.clearcoatNormalTexture)),
            void 0 !== r.clearcoatNormalTexture.scale))
        ) {
          const e = r.clearcoatNormalTexture.scale;
          t.clearcoatNormalScale = new se(e, e);
        }
        return Promise.all(s);
      }
    }
    class Jl {
      constructor(e) {
        (this.parser = e), (this.name = Wl.KHR_MATERIALS_IRIDESCENCE);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Eo : null;
      }
      extendMaterialParams(e, t) {
        const i = this.parser,
          n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const s = [],
          r = n.extensions[this.name];
        return (
          void 0 !== r.iridescenceFactor && (t.iridescence = r.iridescenceFactor),
          void 0 !== r.iridescenceTexture && s.push(i.assignTexture(t, 'iridescenceMap', r.iridescenceTexture)),
          void 0 !== r.iridescenceIor && (t.iridescenceIOR = r.iridescenceIor),
          void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]),
          void 0 !== r.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = r.iridescenceThicknessMinimum),
          void 0 !== r.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = r.iridescenceThicknessMaximum),
          void 0 !== r.iridescenceThicknessTexture &&
            s.push(i.assignTexture(t, 'iridescenceThicknessMap', r.iridescenceThicknessTexture)),
          Promise.all(s)
        );
      }
    }
    class Kl {
      constructor(e) {
        (this.parser = e), (this.name = Wl.KHR_MATERIALS_SHEEN);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Eo : null;
      }
      extendMaterialParams(e, t) {
        const i = this.parser,
          n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const s = [];
        (t.sheenColor = new ve(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
        const r = n.extensions[this.name];
        return (
          void 0 !== r.sheenColorFactor && t.sheenColor.fromArray(r.sheenColorFactor),
          void 0 !== r.sheenRoughnessFactor && (t.sheenRoughness = r.sheenRoughnessFactor),
          void 0 !== r.sheenColorTexture && s.push(i.assignTexture(t, 'sheenColorMap', r.sheenColorTexture, k)),
          void 0 !== r.sheenRoughnessTexture &&
            s.push(i.assignTexture(t, 'sheenRoughnessMap', r.sheenRoughnessTexture)),
          Promise.all(s)
        );
      }
    }
    class $l {
      constructor(e) {
        (this.parser = e), (this.name = Wl.KHR_MATERIALS_TRANSMISSION);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Eo : null;
      }
      extendMaterialParams(e, t) {
        const i = this.parser,
          n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const s = [],
          r = n.extensions[this.name];
        return (
          void 0 !== r.transmissionFactor && (t.transmission = r.transmissionFactor),
          void 0 !== r.transmissionTexture && s.push(i.assignTexture(t, 'transmissionMap', r.transmissionTexture)),
          Promise.all(s)
        );
      }
    }
    class Ql {
      constructor(e) {
        (this.parser = e), (this.name = Wl.KHR_MATERIALS_VOLUME);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Eo : null;
      }
      extendMaterialParams(e, t) {
        const i = this.parser,
          n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const s = [],
          r = n.extensions[this.name];
        (t.thickness = void 0 !== r.thicknessFactor ? r.thicknessFactor : 0),
          void 0 !== r.thicknessTexture && s.push(i.assignTexture(t, 'thicknessMap', r.thicknessTexture)),
          (t.attenuationDistance = r.attenuationDistance || 0);
        const a = r.attenuationColor || [1, 1, 1];
        return (t.attenuationColor = new ve(a[0], a[1], a[2])), Promise.all(s);
      }
    }
    class eh {
      constructor(e) {
        (this.parser = e), (this.name = Wl.KHR_MATERIALS_IOR);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Eo : null;
      }
      extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const n = i.extensions[this.name];
        return (t.ior = void 0 !== n.ior ? n.ior : 1.5), Promise.resolve();
      }
    }
    class th {
      constructor(e) {
        (this.parser = e), (this.name = Wl.KHR_MATERIALS_SPECULAR);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Eo : null;
      }
      extendMaterialParams(e, t) {
        const i = this.parser,
          n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const s = [],
          r = n.extensions[this.name];
        (t.specularIntensity = void 0 !== r.specularFactor ? r.specularFactor : 1),
          void 0 !== r.specularTexture && s.push(i.assignTexture(t, 'specularIntensityMap', r.specularTexture));
        const a = r.specularColorFactor || [1, 1, 1];
        return (
          (t.specularColor = new ve(a[0], a[1], a[2])),
          void 0 !== r.specularColorTexture &&
            s.push(i.assignTexture(t, 'specularColorMap', r.specularColorTexture, k)),
          Promise.all(s)
        );
      }
    }
    class ih {
      constructor(e) {
        (this.parser = e), (this.name = Wl.KHR_TEXTURE_BASISU);
      }
      loadTexture(e) {
        const t = this.parser,
          i = t.json,
          n = i.textures[e];
        if (!n.extensions || !n.extensions[this.name]) return null;
        const s = n.extensions[this.name],
          r = t.options.ktx2Loader;
        if (!r) {
          if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
            throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');
          return null;
        }
        return t.loadTextureImage(e, s.source, r);
      }
    }
    class nh {
      constructor(e) {
        (this.parser = e), (this.name = Wl.EXT_TEXTURE_WEBP), (this.isSupported = null);
      }
      loadTexture(e) {
        const t = this.name,
          i = this.parser,
          n = i.json,
          s = n.textures[e];
        if (!s.extensions || !s.extensions[t]) return null;
        const r = s.extensions[t],
          a = n.images[r.source];
        let o = i.textureLoader;
        if (a.uri) {
          const e = i.options.manager.getHandler(a.uri);
          null !== e && (o = e);
        }
        return this.detectSupport().then(function (s) {
          if (s) return i.loadTextureImage(e, r.source, o);
          if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
            throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');
          return i.loadTexture(e);
        });
      }
      detectSupport() {
        return (
          this.isSupported ||
            (this.isSupported = new Promise(function (e) {
              const t = new Image();
              (t.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'),
                (t.onload = t.onerror =
                  function () {
                    e(1 === t.height);
                  });
            })),
          this.isSupported
        );
      }
    }
    class sh {
      constructor(e) {
        (this.name = Wl.EXT_MESHOPT_COMPRESSION), (this.parser = e);
      }
      loadBufferView(e) {
        const t = this.parser.json,
          i = t.bufferViews[e];
        if (i.extensions && i.extensions[this.name]) {
          const e = i.extensions[this.name],
            n = this.parser.getDependency('buffer', e.buffer),
            s = this.parser.options.meshoptDecoder;
          if (!s || !s.supported) {
            if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
              throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');
            return null;
          }
          return Promise.all([n, s.ready]).then(function (t) {
            const i = e.byteOffset || 0,
              n = e.byteLength || 0,
              r = e.count,
              a = e.byteStride,
              o = new ArrayBuffer(r * a),
              l = new Uint8Array(t[0], i, n);
            return s.decodeGltfBuffer(new Uint8Array(o), r, a, l, e.mode, e.filter), o;
          });
        }
        return null;
      }
    }
    const rh = 'glTF',
      ah = 1313821514,
      oh = 5130562;
    class lh {
      constructor(e) {
        (this.name = Wl.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
        const t = new DataView(e, 0, 12);
        if (
          ((this.header = {
            magic: pl.decodeText(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0),
          }),
          this.header.magic !== rh)
        )
          throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
        if (this.header.version < 2) throw new Error('THREE.GLTFLoader: Legacy binary file detected.');
        const i = this.header.length - 12,
          n = new DataView(e, 12);
        let s = 0;
        for (; s < i; ) {
          const t = n.getUint32(s, !0);
          s += 4;
          const i = n.getUint32(s, !0);
          if (((s += 4), i === ah)) {
            const i = new Uint8Array(e, 12 + s, t);
            this.content = pl.decodeText(i);
          } else if (i === oh) {
            const i = 12 + s;
            this.body = e.slice(i, i + t);
          }
          s += t;
        }
        if (null === this.content) throw new Error('THREE.GLTFLoader: JSON content not found.');
      }
    }
    class hh {
      constructor(e, t) {
        if (!t) throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
        (this.name = Wl.KHR_DRACO_MESH_COMPRESSION),
          (this.json = e),
          (this.dracoLoader = t),
          this.dracoLoader.preload();
      }
      decodePrimitive(e, t) {
        const i = this.json,
          n = this.dracoLoader,
          s = e.extensions[this.name].bufferView,
          r = e.extensions[this.name].attributes,
          a = {},
          o = {},
          l = {};
        for (const e in r) {
          const t = Lh[e] || e.toLowerCase();
          a[t] = r[e];
        }
        for (const t in e.attributes) {
          const n = Lh[t] || t.toLowerCase();
          if (void 0 !== r[t]) {
            const s = i.accessors[e.attributes[t]],
              r = wh[s.componentType];
            (l[n] = r), (o[n] = !0 === s.normalized);
          }
        }
        return t.getDependency('bufferView', s).then(function (e) {
          return new Promise(function (t) {
            n.decodeDracoFile(
              e,
              function (e) {
                for (const t in e.attributes) {
                  const i = e.attributes[t],
                    n = o[t];
                  void 0 !== n && (i.normalized = n);
                }
                t(e);
              },
              a,
              l,
            );
          });
        });
      }
    }
    class ch {
      constructor() {
        this.name = Wl.KHR_TEXTURE_TRANSFORM;
      }
      extendTexture(e, t) {
        return (
          t.texCoord,
          (void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale) ||
            ((e = e.clone()),
            void 0 !== t.offset && e.offset.fromArray(t.offset),
            void 0 !== t.rotation && (e.rotation = t.rotation),
            void 0 !== t.scale && e.repeat.fromArray(t.scale),
            (e.needsUpdate = !0)),
          e
        );
      }
    }
    class uh extends To {
      constructor(e) {
        super(), (this.isGLTFSpecularGlossinessMaterial = !0);
        const t = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\n'),
          i = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\n'),
          n = [
            'vec3 specularFactor = specular;',
            '#ifdef USE_SPECULARMAP',
            '\tvec4 texelSpecular = texture2D( specularMap, vUv );',
            '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
            '\tspecularFactor *= texelSpecular.rgb;',
            '#endif',
          ].join('\n'),
          s = [
            'float glossinessFactor = glossiness;',
            '#ifdef USE_GLOSSINESSMAP',
            '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',
            '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
            '\tglossinessFactor *= texelGlossiness.a;',
            '#endif',
          ].join('\n'),
          r = [
            'PhysicalMaterial material;',
            'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
            'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
            'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
            'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
            'material.roughness += geometryRoughness;',
            'material.roughness = min( material.roughness, 1.0 );',
            'material.specularColor = specularFactor;',
          ].join('\n'),
          a = {
            specular: { value: new ve().setHex(16777215) },
            glossiness: { value: 1 },
            specularMap: { value: null },
            glossinessMap: { value: null },
          };
        (this._extraUniforms = a),
          (this.onBeforeCompile = function (e) {
            for (const t in a) e.uniforms[t] = a[t];
            e.fragmentShader = e.fragmentShader
              .replace('uniform float roughness;', 'uniform vec3 specular;')
              .replace('uniform float metalness;', 'uniform float glossiness;')
              .replace('#include <roughnessmap_pars_fragment>', t)
              .replace('#include <metalnessmap_pars_fragment>', i)
              .replace('#include <roughnessmap_fragment>', n)
              .replace('#include <metalnessmap_fragment>', s)
              .replace('#include <lights_physical_fragment>', r);
          }),
          Object.defineProperties(this, {
            specular: {
              get: function () {
                return a.specular.value;
              },
              set: function (e) {
                a.specular.value = e;
              },
            },
            specularMap: {
              get: function () {
                return a.specularMap.value;
              },
              set: function (e) {
                (a.specularMap.value = e),
                  e ? (this.defines.USE_SPECULARMAP = '') : delete this.defines.USE_SPECULARMAP;
              },
            },
            glossiness: {
              get: function () {
                return a.glossiness.value;
              },
              set: function (e) {
                a.glossiness.value = e;
              },
            },
            glossinessMap: {
              get: function () {
                return a.glossinessMap.value;
              },
              set: function (e) {
                (a.glossinessMap.value = e),
                  e
                    ? ((this.defines.USE_GLOSSINESSMAP = ''), (this.defines.USE_UV = ''))
                    : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
              },
            },
          }),
          delete this.metalness,
          delete this.roughness,
          delete this.metalnessMap,
          delete this.roughnessMap,
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.specularMap = e.specularMap),
          this.specular.copy(e.specular),
          (this.glossinessMap = e.glossinessMap),
          (this.glossiness = e.glossiness),
          delete this.metalness,
          delete this.roughness,
          delete this.metalnessMap,
          delete this.roughnessMap,
          this
        );
      }
    }
    class dh {
      constructor() {
        (this.name = Wl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
          (this.specularGlossinessParams = [
            'color',
            'map',
            'lightMap',
            'lightMapIntensity',
            'aoMap',
            'aoMapIntensity',
            'emissive',
            'emissiveIntensity',
            'emissiveMap',
            'bumpMap',
            'bumpScale',
            'normalMap',
            'normalMapType',
            'displacementMap',
            'displacementScale',
            'displacementBias',
            'specularMap',
            'specular',
            'glossinessMap',
            'glossiness',
            'alphaMap',
            'envMap',
            'envMapIntensity',
          ]);
      }
      getMaterialType() {
        return uh;
      }
      extendParams(e, t, i) {
        const n = t.extensions[this.name];
        (e.color = new ve(1, 1, 1)), (e.opacity = 1);
        const s = [];
        if (Array.isArray(n.diffuseFactor)) {
          const t = n.diffuseFactor;
          e.color.fromArray(t), (e.opacity = t[3]);
        }
        if (
          (void 0 !== n.diffuseTexture && s.push(i.assignTexture(e, 'map', n.diffuseTexture, k)),
          (e.emissive = new ve(0, 0, 0)),
          (e.glossiness = void 0 !== n.glossinessFactor ? n.glossinessFactor : 1),
          (e.specular = new ve(1, 1, 1)),
          Array.isArray(n.specularFactor) && e.specular.fromArray(n.specularFactor),
          void 0 !== n.specularGlossinessTexture)
        ) {
          const t = n.specularGlossinessTexture;
          s.push(i.assignTexture(e, 'glossinessMap', t)), s.push(i.assignTexture(e, 'specularMap', t, k));
        }
        return Promise.all(s);
      }
      createMaterial(e) {
        const t = new uh(e);
        return (
          (t.fog = !0),
          (t.color = e.color),
          (t.map = void 0 === e.map ? null : e.map),
          (t.lightMap = null),
          (t.lightMapIntensity = 1),
          (t.aoMap = void 0 === e.aoMap ? null : e.aoMap),
          (t.aoMapIntensity = 1),
          (t.emissive = e.emissive),
          (t.emissiveIntensity = void 0 === e.emissiveIntensity ? 1 : e.emissiveIntensity),
          (t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap),
          (t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap),
          (t.bumpScale = 1),
          (t.normalMap = void 0 === e.normalMap ? null : e.normalMap),
          (t.normalMapType = 0),
          e.normalScale && (t.normalScale = e.normalScale),
          (t.displacementMap = null),
          (t.displacementScale = 1),
          (t.displacementBias = 0),
          (t.specularMap = void 0 === e.specularMap ? null : e.specularMap),
          (t.specular = e.specular),
          (t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap),
          (t.glossiness = e.glossiness),
          (t.alphaMap = null),
          (t.envMap = void 0 === e.envMap ? null : e.envMap),
          (t.envMapIntensity = 1),
          t
        );
      }
    }
    class mh {
      constructor() {
        this.name = Wl.KHR_MESH_QUANTIZATION;
      }
    }
    class ph extends Do {
      constructor(e, t, i, n) {
        super(e, t, i, n);
      }
      copySampleValue_(e) {
        const t = this.resultBuffer,
          i = this.sampleValues,
          n = this.valueSize,
          s = e * n * 3 + n;
        for (let e = 0; e !== n; e++) t[e] = i[s + e];
        return t;
      }
      interpolate_(e, t, i, n) {
        const s = this.resultBuffer,
          r = this.sampleValues,
          a = this.valueSize,
          o = 2 * a,
          l = 3 * a,
          h = n - t,
          c = (i - t) / h,
          u = c * c,
          d = u * c,
          m = e * l,
          p = m - l,
          f = -2 * d + 3 * u,
          g = d - u,
          _ = 1 - f,
          v = g - u + c;
        for (let e = 0; e !== a; e++) {
          const t = r[p + e + a],
            i = r[p + e + o] * h,
            n = r[m + e + a],
            l = r[m + e] * h;
          s[e] = _ * t + v * i + f * n + g * l;
        }
        return s;
      }
    }
    const fh = new Ce();
    class gh extends ph {
      interpolate_(e, t, i, n) {
        const s = super.interpolate_(e, t, i, n);
        return fh.fromArray(s).normalize().toArray(s), s;
      }
    }
    const _h = 0,
      vh = 1,
      xh = 2,
      yh = 3,
      Mh = 4,
      bh = 5,
      Sh = 6,
      wh = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array,
      },
      Ah = { 9728: m, 9729: g, 9984: p, 9985: _, 9986: f, 9987: v },
      Th = { 33071: u, 33648: d, 10497: c },
      Eh = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
      Lh = {
        POSITION: 'position',
        NORMAL: 'normal',
        TANGENT: 'tangent',
        TEXCOORD_0: 'uv',
        TEXCOORD_1: 'uv2',
        COLOR_0: 'color',
        WEIGHTS_0: 'skinWeight',
        JOINTS_0: 'skinIndex',
      },
      Ch = { scale: 'scale', translation: 'position', rotation: 'quaternion', weights: 'morphTargetInfluences' },
      Ph = { CUBICSPLINE: void 0, LINEAR: I, STEP: D },
      Dh = 'OPAQUE',
      Ih = 'MASK',
      Rh = 'BLEND';
    function Oh(e, t, i) {
      for (const n in i.extensions)
        void 0 === e[n] &&
          ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
          (t.userData.gltfExtensions[n] = i.extensions[n]));
    }
    function Nh(e, t) {
      void 0 !== t.extras && 'object' == typeof t.extras && Object.assign(e.userData, t.extras);
    }
    function zh(e, t) {
      if ((e.updateMorphTargets(), void 0 !== t.weights))
        for (let i = 0, n = t.weights.length; i < n; i++) e.morphTargetInfluences[i] = t.weights[i];
      if (t.extras && Array.isArray(t.extras.targetNames)) {
        const i = t.extras.targetNames;
        if (e.morphTargetInfluences.length === i.length) {
          e.morphTargetDictionary = {};
          for (let t = 0, n = i.length; t < n; t++) e.morphTargetDictionary[i[t]] = t;
        }
      }
    }
    function Fh(e) {
      const t = e.extensions && e.extensions[Wl.KHR_DRACO_MESH_COMPRESSION];
      let i;
      return (
        (i = t
          ? 'draco:' + t.bufferView + ':' + t.indices + ':' + kh(t.attributes)
          : e.indices + ':' + kh(e.attributes) + ':' + e.mode),
        i
      );
    }
    function kh(e) {
      let t = '';
      const i = Object.keys(e).sort();
      for (let n = 0, s = i.length; n < s; n++) t += i[n] + ':' + e[i[n]] + ';';
      return t;
    }
    function Uh(e) {
      switch (e) {
        case Int8Array:
          return 1 / 127;
        case Uint8Array:
          return 1 / 255;
        case Int16Array:
          return 1 / 32767;
        case Uint16Array:
          return 1 / 65535;
        default:
          throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');
      }
    }
    class Bh {
      constructor(e = {}, t = {}) {
        (this.json = e),
          (this.extensions = {}),
          (this.plugins = {}),
          (this.options = t),
          (this.cache = new jl()),
          (this.associations = new Map()),
          (this.primitiveCache = {}),
          (this.meshCache = { refs: {}, uses: {} }),
          (this.cameraCache = { refs: {}, uses: {} }),
          (this.lightCache = { refs: {}, uses: {} }),
          (this.sourceCache = {}),
          (this.textureCache = {}),
          (this.nodeNamesUsed = {});
        const i = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
          n = navigator.userAgent.indexOf('Firefox') > -1,
          s = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
        'undefined' == typeof createImageBitmap || i || (n && s < 98)
          ? (this.textureLoader = new $o(this.options.manager))
          : (this.textureLoader = new gl(this.options.manager)),
          this.textureLoader.setCrossOrigin(this.options.crossOrigin),
          this.textureLoader.setRequestHeader(this.options.requestHeader),
          (this.fileLoader = new Jo(this.options.manager)),
          this.fileLoader.setResponseType('arraybuffer'),
          'use-credentials' === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0);
      }
      setExtensions(e) {
        this.extensions = e;
      }
      setPlugins(e) {
        this.plugins = e;
      }
      parse(e, t) {
        const i = this,
          n = this.json,
          s = this.extensions;
        this.cache.removeAll(),
          this._invokeAll(function (e) {
            return e._markDefs && e._markDefs();
          }),
          Promise.all(
            this._invokeAll(function (e) {
              return e.beforeRoot && e.beforeRoot();
            }),
          )
            .then(function () {
              return Promise.all([
                i.getDependencies('scene'),
                i.getDependencies('animation'),
                i.getDependencies('camera'),
              ]);
            })
            .then(function (t) {
              const r = {
                scene: t[0][n.scene || 0],
                scenes: t[0],
                animations: t[1],
                cameras: t[2],
                asset: n.asset,
                parser: i,
                userData: {},
              };
              Oh(s, r, n),
                Nh(r, n),
                Promise.all(
                  i._invokeAll(function (e) {
                    return e.afterRoot && e.afterRoot(r);
                  }),
                ).then(function () {
                  e(r);
                });
            })
            .catch(t);
      }
      _markDefs() {
        const e = this.json.nodes || [],
          t = this.json.skins || [],
          i = this.json.meshes || [];
        for (let i = 0, n = t.length; i < n; i++) {
          const n = t[i].joints;
          for (let t = 0, i = n.length; t < i; t++) e[n[t]].isBone = !0;
        }
        for (let t = 0, n = e.length; t < n; t++) {
          const n = e[t];
          void 0 !== n.mesh &&
            (this._addNodeRef(this.meshCache, n.mesh), void 0 !== n.skin && (i[n.mesh].isSkinnedMesh = !0)),
            void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera);
        }
      }
      _addNodeRef(e, t) {
        void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
      }
      _getNodeRef(e, t, i) {
        if (e.refs[t] <= 1) return i;
        const n = i.clone(),
          s = (e, t) => {
            const i = this.associations.get(e);
            null != i && this.associations.set(t, i);
            for (const [i, n] of e.children.entries()) s(n, t.children[i]);
          };
        return s(i, n), (n.name += '_instance_' + e.uses[t]++), n;
      }
      _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let i = 0; i < t.length; i++) {
          const n = e(t[i]);
          if (n) return n;
        }
        return null;
      }
      _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const i = [];
        for (let n = 0; n < t.length; n++) {
          const s = e(t[n]);
          s && i.push(s);
        }
        return i;
      }
      getDependency(e, t) {
        const i = e + ':' + t;
        let n = this.cache.get(i);
        if (!n) {
          switch (e) {
            case 'scene':
              n = this.loadScene(t);
              break;
            case 'node':
              n = this.loadNode(t);
              break;
            case 'mesh':
              n = this._invokeOne(function (e) {
                return e.loadMesh && e.loadMesh(t);
              });
              break;
            case 'accessor':
              n = this.loadAccessor(t);
              break;
            case 'bufferView':
              n = this._invokeOne(function (e) {
                return e.loadBufferView && e.loadBufferView(t);
              });
              break;
            case 'buffer':
              n = this.loadBuffer(t);
              break;
            case 'material':
              n = this._invokeOne(function (e) {
                return e.loadMaterial && e.loadMaterial(t);
              });
              break;
            case 'texture':
              n = this._invokeOne(function (e) {
                return e.loadTexture && e.loadTexture(t);
              });
              break;
            case 'skin':
              n = this.loadSkin(t);
              break;
            case 'animation':
              n = this._invokeOne(function (e) {
                return e.loadAnimation && e.loadAnimation(t);
              });
              break;
            case 'camera':
              n = this.loadCamera(t);
              break;
            default:
              throw new Error('Unknown type: ' + e);
          }
          this.cache.add(i, n);
        }
        return n;
      }
      getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
          const i = this,
            n = this.json[e + ('mesh' === e ? 'es' : 's')] || [];
          (t = Promise.all(
            n.map(function (t, n) {
              return i.getDependency(e, n);
            }),
          )),
            this.cache.add(e, t);
        }
        return t;
      }
      loadBuffer(e) {
        const t = this.json.buffers[e],
          i = this.fileLoader;
        if (t.type && 'arraybuffer' !== t.type)
          throw new Error('THREE.GLTFLoader: ' + t.type + ' buffer type is not supported.');
        if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[Wl.KHR_BINARY_GLTF].body);
        const n = this.options;
        return new Promise(function (e, s) {
          i.load(pl.resolveURL(t.uri, n.path), e, void 0, function () {
            s(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
          });
        });
      }
      loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency('buffer', t.buffer).then(function (e) {
          const i = t.byteLength || 0,
            n = t.byteOffset || 0;
          return e.slice(n, n + i);
        });
      }
      loadAccessor(e) {
        const t = this,
          i = this.json,
          n = this.json.accessors[e];
        if (void 0 === n.bufferView && void 0 === n.sparse) return Promise.resolve(null);
        const s = [];
        return (
          void 0 !== n.bufferView ? s.push(this.getDependency('bufferView', n.bufferView)) : s.push(null),
          void 0 !== n.sparse &&
            (s.push(this.getDependency('bufferView', n.sparse.indices.bufferView)),
            s.push(this.getDependency('bufferView', n.sparse.values.bufferView))),
          Promise.all(s).then(function (e) {
            const s = e[0],
              r = Eh[n.type],
              a = wh[n.componentType],
              o = a.BYTES_PER_ELEMENT,
              l = o * r,
              h = n.byteOffset || 0,
              c = void 0 !== n.bufferView ? i.bufferViews[n.bufferView].byteStride : void 0,
              u = !0 === n.normalized;
            let d, m;
            if (c && c !== l) {
              const e = Math.floor(h / c),
                i = 'InterleavedBuffer:' + n.bufferView + ':' + n.componentType + ':' + e + ':' + n.count;
              let l = t.cache.get(i);
              l || ((d = new a(s, e * c, (n.count * c) / o)), (l = new Tr(d, c / o)), t.cache.add(i, l)),
                (m = new Lr(l, r, (h % c) / o, u));
            } else (d = null === s ? new a(n.count * r) : new a(s, h, n.count * r)), (m = new Zt(d, r, u));
            if (void 0 !== n.sparse) {
              const t = Eh.SCALAR,
                i = wh[n.sparse.indices.componentType],
                o = n.sparse.indices.byteOffset || 0,
                l = n.sparse.values.byteOffset || 0,
                h = new i(e[1], o, n.sparse.count * t),
                c = new a(e[2], l, n.sparse.count * r);
              null !== s && (m = new Zt(m.array.slice(), m.itemSize, m.normalized));
              for (let e = 0, t = h.length; e < t; e++) {
                const t = h[e];
                if (
                  (m.setX(t, c[e * r]),
                  r >= 2 && m.setY(t, c[e * r + 1]),
                  r >= 3 && m.setZ(t, c[e * r + 2]),
                  r >= 4 && m.setW(t, c[e * r + 3]),
                  r >= 5)
                )
                  throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
              }
            }
            return m;
          })
        );
      }
      loadTexture(e) {
        const t = this.json,
          i = this.options,
          n = t.textures[e].source,
          s = t.images[n];
        let r = this.textureLoader;
        if (s.uri) {
          const e = i.manager.getHandler(s.uri);
          null !== e && (r = e);
        }
        return this.loadTextureImage(e, n, r);
      }
      loadTextureImage(e, t, i) {
        const n = this,
          s = this.json,
          r = s.textures[e],
          a = s.images[t],
          o = (a.uri || a.bufferView) + ':' + r.sampler;
        if (this.textureCache[o]) return this.textureCache[o];
        const l = this.loadImageSource(t, i)
          .then(function (t) {
            (t.flipY = !1), r.name && (t.name = r.name);
            const i = (s.samplers || {})[r.sampler] || {};
            return (
              (t.magFilter = Ah[i.magFilter] || g),
              (t.minFilter = Ah[i.minFilter] || v),
              (t.wrapS = Th[i.wrapS] || c),
              (t.wrapT = Th[i.wrapT] || c),
              n.associations.set(t, { textures: e }),
              t
            );
          })
          .catch(function () {
            return null;
          });
        return (this.textureCache[o] = l), l;
      }
      loadImageSource(e, t) {
        const i = this,
          n = this.json,
          s = this.options;
        if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((e) => e.clone());
        const r = n.images[e],
          a = self.URL || self.webkitURL;
        let o = r.uri || '',
          l = !1;
        if (void 0 !== r.bufferView)
          o = i.getDependency('bufferView', r.bufferView).then(function (e) {
            l = !0;
            const t = new Blob([e], { type: r.mimeType });
            return (o = a.createObjectURL(t)), o;
          });
        else if (void 0 === r.uri) throw new Error('THREE.GLTFLoader: Image ' + e + ' is missing URI and bufferView');
        const h = Promise.resolve(o)
          .then(function (e) {
            return new Promise(function (i, n) {
              let r = i;
              !0 === t.isImageBitmapLoader &&
                (r = function (e) {
                  const t = new we(e);
                  (t.needsUpdate = !0), i(t);
                }),
                t.load(pl.resolveURL(e, s.path), r, void 0, n);
            });
          })
          .then(function (e) {
            var t;
            return (
              !0 === l && a.revokeObjectURL(o),
              (e.userData.mimeType =
                r.mimeType ||
                ((t = r.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/)
                  ? 'image/jpeg'
                  : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/)
                  ? 'image/webp'
                  : 'image/png')),
              e
            );
          })
          .catch(function (e) {
            throw e;
          });
        return (this.sourceCache[e] = h), h;
      }
      assignTexture(e, t, i, n) {
        const s = this;
        return this.getDependency('texture', i.index).then(function (r) {
          if (
            (void 0 !== i.texCoord && 0 != i.texCoord && ('aoMap' !== t || i.texCoord),
            s.extensions[Wl.KHR_TEXTURE_TRANSFORM])
          ) {
            const e = void 0 !== i.extensions ? i.extensions[Wl.KHR_TEXTURE_TRANSFORM] : void 0;
            if (e) {
              const t = s.associations.get(r);
              (r = s.extensions[Wl.KHR_TEXTURE_TRANSFORM].extendTexture(r, e)), s.associations.set(r, t);
            }
          }
          return void 0 !== n && (r.encoding = n), (e[t] = r), r;
        });
      }
      assignFinalMaterial(e) {
        const t = e.geometry;
        let i = e.material;
        const n = void 0 === t.attributes.tangent,
          s = void 0 !== t.attributes.color,
          r = void 0 === t.attributes.normal;
        if (e.isPoints) {
          const e = 'PointsMaterial:' + i.uuid;
          let t = this.cache.get(e);
          t ||
            ((t = new xa()),
            Wt.prototype.copy.call(t, i),
            t.color.copy(i.color),
            (t.map = i.map),
            (t.sizeAttenuation = !1),
            this.cache.add(e, t)),
            (i = t);
        } else if (e.isLine) {
          const e = 'LineBasicMaterial:' + i.uuid;
          let t = this.cache.get(e);
          t || ((t = new la()), Wt.prototype.copy.call(t, i), t.color.copy(i.color), this.cache.add(e, t)), (i = t);
        }
        if (n || s || r) {
          let e = 'ClonedMaterial:' + i.uuid + ':';
          i.isGLTFSpecularGlossinessMaterial && (e += 'specular-glossiness:'),
            n && (e += 'derivative-tangents:'),
            s && (e += 'vertex-colors:'),
            r && (e += 'flat-shading:');
          let t = this.cache.get(e);
          t ||
            ((t = i.clone()),
            s && (t.vertexColors = !0),
            r && (t.flatShading = !0),
            n && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
            this.cache.add(e, t),
            this.associations.set(t, this.associations.get(i))),
            (i = t);
        }
        i.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute('uv2', t.attributes.uv),
          (e.material = i);
      }
      getMaterialType() {
        return To;
      }
      loadMaterial(e) {
        const t = this,
          i = this.json,
          n = this.extensions,
          s = i.materials[e];
        let r;
        const a = {},
          o = s.extensions || {},
          l = [];
        if (o[Wl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
          const e = n[Wl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
          (r = e.getMaterialType()), l.push(e.extendParams(a, s, t));
        } else if (o[Wl.KHR_MATERIALS_UNLIT]) {
          const e = n[Wl.KHR_MATERIALS_UNLIT];
          (r = e.getMaterialType()), l.push(e.extendParams(a, s, t));
        } else {
          const i = s.pbrMetallicRoughness || {};
          if (((a.color = new ve(1, 1, 1)), (a.opacity = 1), Array.isArray(i.baseColorFactor))) {
            const e = i.baseColorFactor;
            a.color.fromArray(e), (a.opacity = e[3]);
          }
          void 0 !== i.baseColorTexture && l.push(t.assignTexture(a, 'map', i.baseColorTexture, k)),
            (a.metalness = void 0 !== i.metallicFactor ? i.metallicFactor : 1),
            (a.roughness = void 0 !== i.roughnessFactor ? i.roughnessFactor : 1),
            void 0 !== i.metallicRoughnessTexture &&
              (l.push(t.assignTexture(a, 'metalnessMap', i.metallicRoughnessTexture)),
              l.push(t.assignTexture(a, 'roughnessMap', i.metallicRoughnessTexture))),
            (r = this._invokeOne(function (t) {
              return t.getMaterialType && t.getMaterialType(e);
            })),
            l.push(
              Promise.all(
                this._invokeAll(function (t) {
                  return t.extendMaterialParams && t.extendMaterialParams(e, a);
                }),
              ),
            );
        }
        !0 === s.doubleSided && (a.side = 2);
        const h = s.alphaMode || Dh;
        if (
          (h === Rh
            ? ((a.transparent = !0), (a.depthWrite = !1))
            : ((a.transparent = !1), h === Ih && (a.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
          void 0 !== s.normalTexture &&
            r !== Xt &&
            (l.push(t.assignTexture(a, 'normalMap', s.normalTexture)),
            (a.normalScale = new se(1, 1)),
            void 0 !== s.normalTexture.scale))
        ) {
          const e = s.normalTexture.scale;
          a.normalScale.set(e, e);
        }
        return (
          void 0 !== s.occlusionTexture &&
            r !== Xt &&
            (l.push(t.assignTexture(a, 'aoMap', s.occlusionTexture)),
            void 0 !== s.occlusionTexture.strength && (a.aoMapIntensity = s.occlusionTexture.strength)),
          void 0 !== s.emissiveFactor && r !== Xt && (a.emissive = new ve().fromArray(s.emissiveFactor)),
          void 0 !== s.emissiveTexture && r !== Xt && l.push(t.assignTexture(a, 'emissiveMap', s.emissiveTexture, k)),
          Promise.all(l).then(function () {
            let i;
            return (
              (i = r === uh ? n[Wl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new r(a)),
              s.name && (i.name = s.name),
              Nh(i, s),
              t.associations.set(i, { materials: e }),
              s.extensions && Oh(n, i, s),
              i
            );
          })
        );
      }
      createUniqueName(e) {
        const t = Sl.sanitizeNodeName(e || '');
        let i = t;
        for (let e = 1; this.nodeNamesUsed[i]; ++e) i = t + '_' + e;
        return (this.nodeNamesUsed[i] = !0), i;
      }
      loadGeometries(e) {
        const t = this,
          i = this.extensions,
          n = this.primitiveCache;
        function s(e) {
          return i[Wl.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then(function (i) {
            return Vh(i, e, t);
          });
        }
        const r = [];
        for (let i = 0, a = e.length; i < a; i++) {
          const a = e[i],
            o = Fh(a),
            l = n[o];
          if (l) r.push(l.promise);
          else {
            let e;
            (e = a.extensions && a.extensions[Wl.KHR_DRACO_MESH_COMPRESSION] ? s(a) : Vh(new ai(), a, t)),
              (n[o] = { primitive: a, promise: e }),
              r.push(e);
          }
        }
        return Promise.all(r);
      }
      loadMesh(e) {
        const t = this,
          i = this.json,
          n = this.extensions,
          s = i.meshes[e],
          r = s.primitives,
          a = [];
        for (let e = 0, t = r.length; e < t; e++) {
          const t =
            void 0 === r[e].material
              ? (void 0 === (o = this.cache).DefaultMaterial &&
                  (o.DefaultMaterial = new To({
                    color: 16777215,
                    emissive: 0,
                    metalness: 1,
                    roughness: 1,
                    transparent: !1,
                    depthTest: !0,
                    side: 0,
                  })),
                o.DefaultMaterial)
              : this.getDependency('material', r[e].material);
          a.push(t);
        }
        var o;
        return (
          a.push(t.loadGeometries(r)),
          Promise.all(a).then(function (i) {
            const a = i.slice(0, i.length - 1),
              o = i[i.length - 1],
              l = [];
            for (let i = 0, h = o.length; i < h; i++) {
              const h = o[i],
                c = r[i];
              let u;
              const d = a[i];
              if (c.mode === Mh || c.mode === bh || c.mode === Sh || void 0 === c.mode)
                (u = !0 === s.isSkinnedMesh ? new Jr(h, d) : new wi(h, d)),
                  !0 !== u.isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(),
                  c.mode === bh ? (u.geometry = Hh(u.geometry, 1)) : c.mode === Sh && (u.geometry = Hh(u.geometry, 2));
              else if (c.mode === vh) u = new _a(h, d);
              else if (c.mode === yh) u = new pa(h, d);
              else if (c.mode === xh) u = new va(h, d);
              else {
                if (c.mode !== _h) throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + c.mode);
                u = new wa(h, d);
              }
              Object.keys(u.geometry.morphAttributes).length > 0 && zh(u, s),
                (u.name = t.createUniqueName(s.name || 'mesh_' + e)),
                Nh(u, s),
                c.extensions && Oh(n, u, c),
                t.assignFinalMaterial(u),
                l.push(u);
            }
            for (let i = 0, n = l.length; i < n; i++) t.associations.set(l[i], { meshes: e, primitives: i });
            if (1 === l.length) return l[0];
            const h = new vr();
            t.associations.set(h, { meshes: e });
            for (let e = 0, t = l.length; e < t; e++) h.add(l[e]);
            return h;
          })
        );
      }
      loadCamera(e) {
        let t;
        const i = this.json.cameras[e],
          n = i[i.type];
        if (n)
          return (
            'perspective' === i.type
              ? (t = new Ii(ne.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6))
              : 'orthographic' === i.type && (t = new nn(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)),
            i.name && (t.name = this.createUniqueName(i.name)),
            Nh(t, i),
            Promise.resolve(t)
          );
      }
      loadSkin(e) {
        const t = this.json.skins[e],
          i = { joints: t.joints };
        return void 0 === t.inverseBindMatrices
          ? Promise.resolve(i)
          : this.getDependency('accessor', t.inverseBindMatrices).then(function (e) {
              return (i.inverseBindMatrices = e), i;
            });
      }
      loadAnimation(e) {
        const t = this.json.animations[e],
          i = [],
          n = [],
          s = [],
          r = [],
          a = [];
        for (let e = 0, o = t.channels.length; e < o; e++) {
          const o = t.channels[e],
            l = t.samplers[o.sampler],
            h = o.target,
            c = void 0 !== h.node ? h.node : h.id,
            u = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
            d = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
          i.push(this.getDependency('node', c)),
            n.push(this.getDependency('accessor', u)),
            s.push(this.getDependency('accessor', d)),
            r.push(l),
            a.push(h);
        }
        return Promise.all([Promise.all(i), Promise.all(n), Promise.all(s), Promise.all(r), Promise.all(a)]).then(
          function (i) {
            const n = i[0],
              s = i[1],
              r = i[2],
              a = i[3],
              o = i[4],
              l = [];
            for (let e = 0, t = n.length; e < t; e++) {
              const t = n[e],
                i = s[e],
                h = r[e],
                c = a[e],
                u = o[e];
              if (void 0 === t) continue;
              let d;
              switch ((t.updateMatrix(), (t.matrixAutoUpdate = !0), Ch[u.path])) {
                case Ch.weights:
                  d = ko;
                  break;
                case Ch.rotation:
                  d = Bo;
                  break;
                default:
                  d = Vo;
              }
              const m = t.name ? t.name : t.uuid,
                p = void 0 !== c.interpolation ? Ph[c.interpolation] : I,
                f = [];
              Ch[u.path] === Ch.weights
                ? t.traverse(function (e) {
                    e.morphTargetInfluences && f.push(e.name ? e.name : e.uuid);
                  })
                : f.push(m);
              let g = h.array;
              if (h.normalized) {
                const e = Uh(g.constructor),
                  t = new Float32Array(g.length);
                for (let i = 0, n = g.length; i < n; i++) t[i] = g[i] * e;
                g = t;
              }
              for (let e = 0, t = f.length; e < t; e++) {
                const t = new d(f[e] + '.' + Ch[u.path], i.array, g, p);
                'CUBICSPLINE' === c.interpolation &&
                  ((t.createInterpolant = function (e) {
                    return new (this instanceof Bo ? gh : ph)(this.times, this.values, this.getValueSize() / 3, e);
                  }),
                  (t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0)),
                  l.push(t);
              }
            }
            const h = t.name ? t.name : 'animation_' + e;
            return new Ho(h, void 0, l);
          },
        );
      }
      createNodeMesh(e) {
        const t = this.json,
          i = this,
          n = t.nodes[e];
        return void 0 === n.mesh
          ? null
          : i.getDependency('mesh', n.mesh).then(function (e) {
              const t = i._getNodeRef(i.meshCache, n.mesh, e);
              return (
                void 0 !== n.weights &&
                  t.traverse(function (e) {
                    if (e.isMesh)
                      for (let t = 0, i = n.weights.length; t < i; t++) e.morphTargetInfluences[t] = n.weights[t];
                  }),
                t
              );
            });
      }
      loadNode(e) {
        const t = this.json,
          i = this.extensions,
          n = this,
          s = t.nodes[e],
          r = s.name ? n.createUniqueName(s.name) : '';
        return (function () {
          const t = [],
            i = n._invokeOne(function (t) {
              return t.createNodeMesh && t.createNodeMesh(e);
            });
          return (
            i && t.push(i),
            void 0 !== s.camera &&
              t.push(
                n.getDependency('camera', s.camera).then(function (e) {
                  return n._getNodeRef(n.cameraCache, s.camera, e);
                }),
              ),
            n
              ._invokeAll(function (t) {
                return t.createNodeAttachment && t.createNodeAttachment(e);
              })
              .forEach(function (e) {
                t.push(e);
              }),
            Promise.all(t)
          );
        })().then(function (t) {
          let a;
          if (
            ((a = !0 === s.isBone ? new Kr() : t.length > 1 ? new vr() : 1 === t.length ? t[0] : new It()), a !== t[0])
          )
            for (let e = 0, i = t.length; e < i; e++) a.add(t[e]);
          if (
            (s.name && ((a.userData.name = s.name), (a.name = r)),
            Nh(a, s),
            s.extensions && Oh(i, a, s),
            void 0 !== s.matrix)
          ) {
            const e = new ot();
            e.fromArray(s.matrix), a.applyMatrix4(e);
          } else void 0 !== s.translation && a.position.fromArray(s.translation), void 0 !== s.rotation && a.quaternion.fromArray(s.rotation), void 0 !== s.scale && a.scale.fromArray(s.scale);
          return n.associations.has(a) || n.associations.set(a, {}), (n.associations.get(a).nodes = e), a;
        });
      }
      loadScene(e) {
        const t = this.json,
          i = this.extensions,
          n = this.json.scenes[e],
          s = this,
          r = new vr();
        n.name && (r.name = s.createUniqueName(n.name)), Nh(r, n), n.extensions && Oh(i, r, n);
        const a = n.nodes || [],
          o = [];
        for (let e = 0, i = a.length; e < i; e++) o.push(Gh(a[e], r, t, s));
        return Promise.all(o).then(function () {
          return (
            (s.associations = ((e) => {
              const t = new Map();
              for (const [e, i] of s.associations) (e instanceof Wt || e instanceof we) && t.set(e, i);
              return (
                e.traverse((e) => {
                  const i = s.associations.get(e);
                  null != i && t.set(e, i);
                }),
                t
              );
            })(r)),
            r
          );
        });
      }
    }
    function Gh(e, t, i, n) {
      const s = i.nodes[e];
      return n
        .getDependency('node', e)
        .then(function (e) {
          if (void 0 === s.skin) return e;
          let t;
          return n
            .getDependency('skin', s.skin)
            .then(function (e) {
              t = e;
              const i = [];
              for (let e = 0, s = t.joints.length; e < s; e++) i.push(n.getDependency('node', t.joints[e]));
              return Promise.all(i);
            })
            .then(function (i) {
              return (
                e.traverse(function (e) {
                  if (!e.isMesh) return;
                  const n = [],
                    s = [];
                  for (let e = 0, r = i.length; e < r; e++) {
                    const r = i[e];
                    if (r) {
                      n.push(r);
                      const i = new ot();
                      void 0 !== t.inverseBindMatrices && i.fromArray(t.inverseBindMatrices.array, 16 * e), s.push(i);
                    }
                  }
                  e.bind(new ta(n, s), e.matrixWorld);
                }),
                e
              );
            });
        })
        .then(function (e) {
          t.add(e);
          const r = [];
          if (s.children) {
            const t = s.children;
            for (let s = 0, a = t.length; s < a; s++) {
              const a = t[s];
              r.push(Gh(a, e, i, n));
            }
          }
          return Promise.all(r);
        });
    }
    function Vh(e, t, i) {
      const n = t.attributes,
        s = [];
      function r(t, n) {
        return i.getDependency('accessor', t).then(function (t) {
          e.setAttribute(n, t);
        });
      }
      for (const t in n) {
        const i = Lh[t] || t.toLowerCase();
        i in e.attributes || s.push(r(n[t], i));
      }
      if (void 0 !== t.indices && !e.index) {
        const n = i.getDependency('accessor', t.indices).then(function (t) {
          e.setIndex(t);
        });
        s.push(n);
      }
      return (
        Nh(e, t),
        (function (e, t, i) {
          const n = t.attributes,
            s = new Re();
          if (void 0 === n.POSITION) return;
          {
            const e = i.json.accessors[n.POSITION],
              t = e.min,
              r = e.max;
            if (void 0 === t || void 0 === r) return;
            if ((s.set(new Pe(t[0], t[1], t[2]), new Pe(r[0], r[1], r[2])), e.normalized)) {
              const t = Uh(wh[e.componentType]);
              s.min.multiplyScalar(t), s.max.multiplyScalar(t);
            }
          }
          const r = t.targets;
          if (void 0 !== r) {
            const e = new Pe(),
              t = new Pe();
            for (let n = 0, s = r.length; n < s; n++) {
              const s = r[n];
              if (void 0 !== s.POSITION) {
                const n = i.json.accessors[s.POSITION],
                  r = n.min,
                  a = n.max;
                if (void 0 !== r && void 0 !== a) {
                  if (
                    (t.setX(Math.max(Math.abs(r[0]), Math.abs(a[0]))),
                    t.setY(Math.max(Math.abs(r[1]), Math.abs(a[1]))),
                    t.setZ(Math.max(Math.abs(r[2]), Math.abs(a[2]))),
                    n.normalized)
                  ) {
                    const e = Uh(wh[n.componentType]);
                    t.multiplyScalar(e);
                  }
                  e.max(t);
                }
              }
            }
            s.expandByVector(e);
          }
          e.boundingBox = s;
          const a = new $e();
          s.getCenter(a.center), (a.radius = s.min.distanceTo(s.max) / 2), (e.boundingSphere = a);
        })(e, t, i),
        Promise.all(s).then(function () {
          return void 0 !== t.targets
            ? (function (e, t, i) {
                let n = !1,
                  s = !1,
                  r = !1;
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e];
                  if (
                    (void 0 !== i.POSITION && (n = !0),
                    void 0 !== i.NORMAL && (s = !0),
                    void 0 !== i.COLOR_0 && (r = !0),
                    n && s && r)
                  )
                    break;
                }
                if (!n && !s && !r) return Promise.resolve(e);
                const a = [],
                  o = [],
                  l = [];
                for (let h = 0, c = t.length; h < c; h++) {
                  const c = t[h];
                  if (n) {
                    const t = void 0 !== c.POSITION ? i.getDependency('accessor', c.POSITION) : e.attributes.position;
                    a.push(t);
                  }
                  if (s) {
                    const t = void 0 !== c.NORMAL ? i.getDependency('accessor', c.NORMAL) : e.attributes.normal;
                    o.push(t);
                  }
                  if (r) {
                    const t = void 0 !== c.COLOR_0 ? i.getDependency('accessor', c.COLOR_0) : e.attributes.color;
                    l.push(t);
                  }
                }
                return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then(function (t) {
                  const i = t[0],
                    a = t[1],
                    o = t[2];
                  return (
                    n && (e.morphAttributes.position = i),
                    s && (e.morphAttributes.normal = a),
                    r && (e.morphAttributes.color = o),
                    (e.morphTargetsRelative = !0),
                    e
                  );
                });
              })(e, t.targets, i)
            : e;
        })
      );
    }
    function Hh(e, t) {
      let i = e.getIndex();
      if (null === i) {
        const t = [],
          n = e.getAttribute('position');
        if (void 0 === n) return e;
        for (let e = 0; e < n.count; e++) t.push(e);
        e.setIndex(t), (i = e.getIndex());
      }
      const n = i.count - 2,
        s = [];
      if (2 === t) for (let e = 1; e <= n; e++) s.push(i.getX(0)), s.push(i.getX(e)), s.push(i.getX(e + 1));
      else
        for (let e = 0; e < n; e++)
          e % 2 == 0
            ? (s.push(i.getX(e)), s.push(i.getX(e + 1)), s.push(i.getX(e + 2)))
            : (s.push(i.getX(e + 2)), s.push(i.getX(e + 1)), s.push(i.getX(e)));
      s.length;
      const r = e.clone();
      return r.setIndex(s), r;
    }
    class jh {
      constructor() {
        this.events = {};
      }
      addEventListener(e, t) {
        this.events[e] || (this.events[e] = []), -1 === this.events[e].indexOf(t) && this.events[e].push(t);
      }
      removeEventListener(e, t) {
        if (this.events[e]) {
          let i = this.events[e].indexOf(t);
          -1 !== i && this.events[e].splice(i, 1);
        }
      }
      dispatchEvent(e, t) {
        this.events[e] &&
          this.events[e].forEach((e) => {
            e(t);
          });
      }
      ClearListener(e) {
        this.events[e] && (this.events[e] = []);
      }
    }
    class Wh {
      constructor() {}
      load(e, t, i, n) {
        (this.m_model = i), this.loadProc(e, t, n);
      }
      loadProc(t, i, n) {
        const s = new Worker(new URL(e.p + e.u(593), e.b));
        s.postMessage({ command: 'load', url: t }),
          (s.onmessage = ({ data: { lines: e, meshs: t, layers: r, blocks: a, instances: o, complete: l } }) => {
            e && this.m_model.addlines(e, i),
              t && this.m_model.addMeshs(t, i),
              r && this.m_model.addLayers(r),
              a && this.m_model.addBlocks(a),
              o && this.m_model.addInstances(o),
              l ? (this.m_model.OnComplete(), n(l), s.terminate()) : l || (this.m_model.OnComplete(), n(l));
          });
      }
    }
    class Xh extends i {
      constructor(e) {
        super(e),
          (this.m_modelLayer = this.m_context.SceneManager.ModelLayer),
          (this.m_threeLayer = this.m_context.SceneManager.ThreeLayer),
          (this.m_eventManager = new jh());
      }
      LoadModel(e) {
        switch (e.type) {
          case 'gltf':
            this.LoadGLTF(e.url);
          case 'p2d':
            this.LoadP2d(e.url, e.canEdit);
        }
      }
      LoadP2d(e, t) {
        new Wh().load(e, t, this.m_context.ModelManager, (e) => {
          this.m_eventManager.dispatchEvent(Xh.loadFinish, { isComplete: e, modelManger: this.m_context.ModelManager }),
            this.m_context.ViewManager.Render();
        });
      }
      LoadBlockP2d(e, t, i) {
        new Wh().load(e, t, this.m_context.ModelManager, (e) => {
          this.m_context.ViewManager.Render(), i && i();
        });
      }
      LoadGLTF(e) {
        new Hl().load(e, (e) => {
          let t = new ot();
          t.makeBasis(new Pe(1, 0, 0), new Pe(0, 0, 1), new Pe(0, 1, 0)),
            t.scale(new Pe(0.001, 0.001, 0.001)),
            e.scene.applyMatrix4(t),
            this.m_threeLayer.add(e.scene),
            this.m_eventManager.dispatchEvent(Xh.loadFinish, e.scene);
        });
      }
      addEventListener(e, t) {
        this.m_eventManager.addEventListener(e, t);
      }
      removeEventListener(e, t) {
        this.m_eventManager.removeEventListener(e, t);
      }
    }
    (Xh.loadFinish = 'finish'), (Xh.loadStart = 'start');
    class qh extends jh {
      constructor(e) {
        super(),
          (this.m_pressPoint = new Pe()),
          (this.m_tempPoint = new Pe()),
          (this.raycaster = new Al()),
          (this.m_plane = new Bi(new Pe(0, 0, 1), 0)),
          (this.m_isPan = !1),
          (this.MouseLeftPan = !0),
          (this.m_enablePan = !0),
          (this.m_pressCameraPosition = new Pe()),
          (this.m_pressScreenPoint = new se()),
          (this.m_camera = e);
      }
      set EnablePan(e) {
        this.m_enablePan = e;
      }
      get IsPan() {
        return this.m_isPan;
      }
      ZoomToBox(e) {
        let t = new Pe();
        e.getCenter(t);
        let i = new Pe();
        return (
          e.getSize(i),
          this.m_camera.position.copy(new Pe(t.x, t.y, i.length())),
          this.m_camera.lookAt(new Pe(t.x, t.y, 0)),
          this.dispatchEvent('zoom', this.m_camera),
          e
        );
      }
      listenToKeyEvents(e) {
        (this.domElement = e),
          e.addEventListener('pointerdown', this.onPointerDown.bind(this)),
          e.addEventListener('pointermove', this.onPointerMove.bind(this)),
          e.addEventListener('pointerup', this.onPointerUp.bind(this)),
          e.addEventListener('mousewheel', this.onMouseWheel.bind(this)),
          (e.oncontextmenu = () => !1);
      }
      getScreenCoordinates(e, t) {
        let i = t;
        return { x: (e / this.domElement.clientWidth) * 2 - 1, y: (-i / this.domElement.clientHeight) * 2 + 1 };
      }
      onPointerUp(e) {
        this.m_isPan = !1;
      }
      onPointerMove(e) {
        if (this.m_isPan && this.m_enablePan) {
          {
            let { x: t, y: i } = this.getScreenCoordinates(e.offsetX, e.offsetY);
            this.raycaster.setFromCamera(new se(t, i), this.m_camera),
              this.raycaster.ray.intersectPlane(this.m_plane, this.m_tempPoint);
          }
          {
            let { x: e, y: t } = this.getScreenCoordinates(this.m_pressScreenPoint.x, this.m_pressScreenPoint.y);
            this.raycaster.setFromCamera(new se(e, t), this.m_camera),
              this.raycaster.ray.intersectPlane(this.m_plane, this.m_pressPoint);
          }
          let t = this.m_pressPoint.sub(this.m_tempPoint);
          this.m_camera.position.copy(this.m_pressCameraPosition.clone().add(t)),
            this.m_camera.lookAt(new Pe(this.m_camera.position.x, this.m_camera.position.y, 0));
        }
      }
      onPointerDown(e) {
        ((0 == e.button && this.MouseLeftPan) || 1 == e.button || 2 == e.button) &&
          ((this.m_pressScreenPoint = new se(e.offsetX, e.offsetY)),
          this.m_pressCameraPosition.copy(this.m_camera.position),
          (this.m_isPan = !0));
      }
      get DownPointXY() {
        return this.m_pressScreenPoint;
      }
      onMouseWheel(e) {
        if (this.m_isPan) return;
        let { x: t, y: i } = this.getScreenCoordinates(e.offsetX, e.offsetY);
        this.raycaster.setFromCamera(new se(t, i), this.m_camera), this.m_plane.set(new Pe(0, 0, 1), 0);
        let n = new Pe();
        this.raycaster.ray.intersectPlane(this.m_plane, n);
        let s = this.m_camera.position.clone(),
          r = n.clone().sub(s).normalize(),
          a = n.distanceTo(s);
        if (e.deltaY < 0) {
          let e = r.clone().multiplyScalar(0.1 * a);
          this.m_camera.position.add(e),
            this.m_camera.lookAt(new Pe(this.m_camera.position.x, this.m_camera.position.y, 0));
        }
        if (e.deltaY > 0) {
          let e = r.clone().multiplyScalar(0.1 * -a);
          this.m_camera.position.add(e),
            this.m_camera.lookAt(new Pe(this.m_camera.position.x, this.m_camera.position.y, 0));
        }
        this.dispatchEvent('zoom', this.m_camera);
      }
    }
    class Yh {
      static GetScale(e, t) {
        let i = 0.5 * e.fov * (Math.PI / 180);
        return (Math.tan(i) * e.position.z * 2) / t;
      }
    }
    new _a();
    class Zh {
      constructor(e, t, i, n) {
        (this.m_frustum = new Hi()),
          (this.m_center = new Pe()),
          (this.m_tmpPoint = new Pe()),
          (this.m_vecNear = new Pe()),
          (this.m_vecTopLeft = new Pe()),
          (this.m_vecTopRight = new Pe()),
          (this.m_vecDownRight = new Pe()),
          (this.m_vecDownLeft = new Pe()),
          (this.m_vecFarTopLeft = new Pe()),
          (this.m_vecFarTopRight = new Pe()),
          (this.m_vecFarDownRight = new Pe()),
          (this.m_vecFarDownLeft = new Pe()),
          (this.m_vectemp1 = new Pe()),
          (this.m_vectemp2 = new Pe()),
          (this.m_vectemp3 = new Pe()),
          (this.m_matrix = new ot()),
          (this.m_quaternion = new Ce()),
          (this.m_scale = new Pe()),
          (this.m_collection = []),
          (this.m_camera = e),
          (this.m_model = t),
          (this.m_startPoint = new Pe()),
          (this.m_endPoint = new Pe()),
          (this.m_threeModel = i),
          (this.m_auxModel = n),
          (this.m_deep = Number.MAX_VALUE);
      }
      select(e, t) {
        (this.m_startPoint = e || this.m_startPoint),
          (this.m_endPoint = t || this.m_endPoint),
          this.updateFrustum(this.m_startPoint, this.m_endPoint),
          this.searchChildInFrustum(this.m_frustum, this.m_threeModel),
          this.searchChildInFrustum(this.m_frustum, this.m_auxModel),
          this.searchChildInFrustum(this.m_frustum, this.m_model);
      }
      updateFrustum(e, t) {
        if (
          (e.x === t.x && (t.x += Number.EPSILON), e.y === t.y && (t.y += Number.EPSILON), this.m_camera instanceof Ii)
        ) {
          this.m_camera.updateProjectionMatrix(),
            this.m_camera.updateMatrixWorld(),
            this.m_tmpPoint.copy(e),
            (this.m_tmpPoint.x = Math.min(e.x, t.x)),
            (this.m_tmpPoint.y = Math.max(e.y, t.y)),
            (t.x = Math.max(e.x, t.x)),
            (t.y = Math.min(e.y, t.y)),
            this.m_vecNear.setFromMatrixPosition(this.m_camera.matrixWorld),
            this.m_vecTopLeft.set(this.m_tmpPoint.x, this.m_tmpPoint.y, 0.5),
            this.m_vecTopRight.set(t.x, this.m_tmpPoint.y, 0),
            this.m_vecDownRight.set(t.x, t.y, 0.5),
            this.m_vecDownLeft.set(this.m_tmpPoint.x, t.y, 0),
            this.m_vecTopLeft.unproject(this.m_camera),
            this.m_vecTopRight.unproject(this.m_camera),
            this.m_vecDownRight.unproject(this.m_camera),
            this.m_vecDownLeft.unproject(this.m_camera),
            this.m_vectemp1.copy(this.m_vecTopLeft).sub(this.m_vecNear),
            this.m_vectemp2.copy(this.m_vecTopRight).sub(this.m_vecNear),
            this.m_vectemp3.copy(this.m_vecDownRight).sub(this.m_vecNear),
            this.m_vectemp1.normalize(),
            this.m_vectemp2.normalize(),
            this.m_vectemp3.normalize(),
            this.m_vectemp1.multiplyScalar(this.m_deep),
            this.m_vectemp2.multiplyScalar(this.m_deep),
            this.m_vectemp3.multiplyScalar(this.m_deep),
            this.m_vectemp1.add(this.m_vecNear),
            this.m_vectemp2.add(this.m_vecNear),
            this.m_vectemp3.add(this.m_vecNear);
          const i = this.m_frustum.planes;
          i[0].setFromCoplanarPoints(this.m_vecNear, this.m_vecTopLeft, this.m_vecTopRight),
            i[1].setFromCoplanarPoints(this.m_vecNear, this.m_vecTopRight, this.m_vecDownRight),
            i[2].setFromCoplanarPoints(this.m_vecDownRight, this.m_vecDownLeft, this.m_vecNear),
            i[3].setFromCoplanarPoints(this.m_vecDownLeft, this.m_vecTopLeft, this.m_vecNear),
            i[4].setFromCoplanarPoints(this.m_vecTopRight, this.m_vecDownRight, this.m_vecDownLeft),
            i[5].setFromCoplanarPoints(this.m_vectemp3, this.m_vectemp2, this.m_vectemp1),
            i[5].normal.multiplyScalar(-1);
        } else if (this.m_camera instanceof nn) {
          this.m_camera.updateProjectionMatrix(), this.m_camera.updateMatrixWorld();
          const i = Math.min(e.x, t.x),
            n = Math.max(e.y, t.y),
            s = Math.max(e.x, t.x),
            r = Math.min(e.y, t.y);
          this.m_vecTopLeft.set(i, n, -1),
            this.m_vecTopRight.set(s, n, -1),
            this.m_vecDownRight.set(s, r, -1),
            this.m_vecDownLeft.set(i, r, -1),
            this.m_vecFarTopLeft.set(i, n, 1),
            this.m_vecFarTopRight.set(s, n, 1),
            this.m_vecFarDownRight.set(s, r, 1),
            this.m_vecFarDownLeft.set(i, r, 1),
            this.m_vecTopLeft.unproject(this.m_camera),
            this.m_vecTopRight.unproject(this.m_camera),
            this.m_vecDownRight.unproject(this.m_camera),
            this.m_vecDownLeft.unproject(this.m_camera),
            this.m_vecFarTopLeft.unproject(this.m_camera),
            this.m_vecFarTopRight.unproject(this.m_camera),
            this.m_vecFarDownRight.unproject(this.m_camera),
            this.m_vecFarDownLeft.unproject(this.m_camera);
          const a = this.m_frustum.planes;
          a[0].setFromCoplanarPoints(this.m_vecTopLeft, this.m_vecFarTopLeft, this.m_vecFarTopRight),
            a[1].setFromCoplanarPoints(this.m_vecTopRight, this.m_vecFarTopRight, this.m_vecFarDownRight),
            a[2].setFromCoplanarPoints(this.m_vecFarDownRight, this.m_vecFarDownLeft, this.m_vecDownLeft),
            a[3].setFromCoplanarPoints(this.m_vecFarDownLeft, this.m_vecFarTopLeft, this.m_vecTopLeft),
            a[4].setFromCoplanarPoints(this.m_vecTopRight, this.m_vecDownRight, this.m_vecDownLeft),
            a[5].setFromCoplanarPoints(this.m_vecFarDownRight, this.m_vecFarTopRight, this.m_vecFarTopLeft),
            a[5].normal.multiplyScalar(-1);
        }
      }
      searchChildInFrustum(e, t) {
        if (t instanceof It) {
          if (t instanceof wi || t instanceof pa || t instanceof wa || t instanceof Hr)
            if (t instanceof oa) {
              this.instances[t.uuid] = [];
              for (let i = 0; i < t.count; i++)
                t.getMatrixAt(i, this.m_matrix),
                  this.m_matrix.decompose(this.m_center, this.m_quaternion, this.m_scale),
                  this.m_center.applyMatrix4(t.matrixWorld),
                  e.containsPoint(this.m_center) && this.instances[t.uuid].push(i);
            } else
              null === t.geometry.boundingSphere && t.geometry.computeBoundingSphere(),
                this.m_center.copy(t.geometry.boundingSphere.center),
                this.m_center.applyMatrix4(t.matrixWorld),
                e.containsPoint(this.m_center) && this.m_collection.push(t);
          if (t.children.length > 0)
            for (let i = 0; i < t.children.length; i++) this.searchChildInFrustum(e, t.children[i]);
        } else {
          let i = t;
          for (let t in i.Lines) {
            let n = i.Lines[t],
              s = t.split('_')[0];
            i.LayerTable[s].Enabled &&
              i.LayerTable[s].Visible &&
              n.lines.forEach((t) => {
                t.box && e.intersectsBox(t.box) && this.m_collection.push(t);
              });
          }
          for (let t in i.Meshs) {
            let n = i.Meshs[t],
              s = t.split('_')[0];
            i.LayerTable[s].Enabled &&
              i.LayerTable[s].Visible &&
              n.meshs.forEach((t) => {
                t.box && e.intersectsBox(t.box) && this.m_collection.push(t);
              });
          }
          for (let t in i.Instances)
            i.LayerTable[t].Enabled &&
              i.LayerTable[t].Visible &&
              i.Instances[t].forEach((t) => {
                this.m_matrix.decompose(this.m_center, this.m_quaternion, this.m_scale),
                  this.m_center.applyMatrix4(t.matrix),
                  e.containsPoint(this.m_center) && this.m_collection.push(t);
              });
        }
      }
      get Collection() {
        return this.m_collection;
      }
    }
    class Jh {
      constructor(e, t, i, n) {
        (this.location = e), (this.distance = t), (this.code = i), (this.obejct = n), (this.position = Kh.None);
      }
    }
    var Kh;
    function $h(e, t, i, n) {
      let s = new Pe();
      for (let i of e)
        if (i.sphere && t.intersectSphere(i.sphere, s))
          for (let e = 0; e < i.vertexs.length; e += 9) {
            let s = new Pe(i.vertexs[e + 0], i.vertexs[e + 1], i.vertexs[e + 2]),
              r = new Pe(i.vertexs[e + 3], i.vertexs[e + 4], i.vertexs[e + 5]),
              a = new Pe(i.vertexs[e + 6], i.vertexs[e + 7], i.vertexs[e + 8]),
              o = new Pe(),
              l = t.intersectTriangle(s, r, a, !0, o);
            if ((l || (l = t.intersectTriangle(s, r, a, !1, o)), null != l)) {
              let e = [i],
                t = { x: Number(o.x), y: Number(o.y), z: Number(o.z) },
                s = new Jh(t, 0, '', e);
              return (s.adjust = { x: Number(o.x), y: Number(o.y), z: Number(o.z) }), void n(s);
            }
          }
    }
    function Qh(e, t, i, n) {
      let s = i * i,
        r = new Pe(),
        a = new Pe(),
        o = new Pe(),
        l = new Pe();
      for (let h of e)
        if (h.sphere && t.intersectSphere(h.sphere, r))
          for (let e = 0; e < h.points.length; e += 3) {
            o.set(h.points[e + 0], h.points[e + 1], h.points[e + 2]),
              l.set(h.points[e + 3], h.points[e + 4], h.points[e + 5]);
            let c = t.distanceSqToSegment(o, l, r, a);
            if (c <= s) {
              let e = [h],
                t = { x: Number(r.x), y: Number(r.y), z: Number(r.z) },
                s = new Pe(0.5 * (o.x + l.x), 0.5 * (o.y + l.y), 0.5 * (o.z + l.z)),
                u = o.distanceTo(a),
                d = s.distanceTo(a),
                m = l.distanceTo(a),
                p = Kh.None,
                f = Math.min(u, d, m),
                g = a.clone();
              f <= i &&
                (f == u && ((p = Kh.Start), (g = o.clone())),
                f == d && ((p = Kh.Center), (g = s)),
                f == m && ((p = Kh.End), (g = l.clone())));
              let _ = new Jh(t, Math.sqrt(c), '', e);
              if (((_.position = p), (_.adjust = g), (_.geo = new Pl(o.clone(), l.clone())), !n(_))) return;
            }
          }
    }
    function ec(e) {
      (e instanceof pa || e instanceof _a || e instanceof wi) && (e.geometry.dispose(), e.clear());
    }
    function tc(e, t) {
      return [new se(e.x - 0, e.y), new se(t.x, e.y), new se(t.x, t.y), new se(e.x - 0, t.y)];
    }
    !(function (e) {
      (e.Start = 'start'),
        (e.End = 'end'),
        (e.Center = 'center'),
        (e.Insert = 'insert'),
        (e.Cross = 'cross'),
        (e.Vertical = 'vertical'),
        (e.AuxOrthogonal = 'auxOrthogonal'),
        (e.AuxVertical = 'auxVertical'),
        (e.None = 'none');
    })(Kh || (Kh = {}));
    class ic extends It {
      constructor(e = document.createElement('div')) {
        super(),
          (this.isCSS2DObject = !0),
          (this.element = e),
          (this.element.style.position = 'absolute'),
          (this.element.style.userSelect = 'none'),
          this.element.setAttribute('draggable', !1),
          this.addEventListener('removed', function () {
            this.traverse(function (e) {
              e.element instanceof Element &&
                null !== e.element.parentNode &&
                e.element.parentNode.removeChild(e.element);
            });
          });
      }
      copy(e, t) {
        return super.copy(e, t), (this.element = e.element.cloneNode(!0)), this;
      }
    }
    const nc = new Pe(),
      sc = new ot(),
      rc = new ot(),
      ac = new Pe(),
      oc = new Pe();
    class lc {
      constructor(e = {}) {
        const t = this;
        let i, n, s, r;
        const a = { objects: new WeakMap() },
          o = void 0 !== e.element ? e.element : document.createElement('div');
        function l(e, i, n) {
          if (e.isCSS2DObject) {
            nc.setFromMatrixPosition(e.matrixWorld), nc.applyMatrix4(rc);
            const l = !0 === e.visible && nc.z >= -1 && nc.z <= 1 && !0 === e.layers.test(n.layers);
            if (((e.element.style.display = !0 === l ? '' : 'none'), !0 === l)) {
              e.onBeforeRender(t, i, n);
              const a = e.element;
              (a.style.transform =
                'translate(-50%,-50%) translate(' + (nc.x * s + s) + 'px,' + (-nc.y * r + r) + 'px)'),
                a.parentNode !== o && o.appendChild(a),
                e.onAfterRender(t, i, n);
            }
            const c = { distanceToCameraSquared: h(n, e) };
            a.objects.set(e, c);
          }
          for (let t = 0, s = e.children.length; t < s; t++) l(e.children[t], i, n);
        }
        function h(e, t) {
          return (
            ac.setFromMatrixPosition(e.matrixWorld), oc.setFromMatrixPosition(t.matrixWorld), ac.distanceToSquared(oc)
          );
        }
        (o.style.overflow = 'hidden'),
          (this.domElement = o),
          (this.getSize = function () {
            return { width: i, height: n };
          }),
          (this.render = function (e, t) {
            !0 === e.autoUpdate && e.updateMatrixWorld(),
              null === t.parent && t.updateMatrixWorld(),
              sc.copy(t.matrixWorldInverse),
              rc.multiplyMatrices(t.projectionMatrix, sc),
              l(e, e, t),
              (function (e) {
                const t = (function (e) {
                    const t = [];
                    return (
                      e.traverse(function (e) {
                        e.isCSS2DObject && t.push(e);
                      }),
                      t
                    );
                  })(e).sort(function (e, t) {
                    if (e.renderOrder !== t.renderOrder) return t.renderOrder - e.renderOrder;
                    return a.objects.get(e).distanceToCameraSquared - a.objects.get(t).distanceToCameraSquared;
                  }),
                  i = t.length;
                for (let e = 0, n = t.length; e < n; e++) t[e].element.style.zIndex = i - e;
              })(e);
          }),
          (this.setSize = function (e, t) {
            (i = e), (n = t), (s = i / 2), (r = n / 2), (o.style.width = e + 'px'), (o.style.height = t + 'px');
          });
      }
    }
    class hc extends i {
      constructor(e) {
        super(e),
          (this.m_eventManager = new jh()),
          (this.m_canvas = document.createElement('canvas')),
          (this.m_canvas.style.width = '100%'),
          (this.m_canvas.style.height = '100%'),
          (this.m_canvas.style.overflow = 'hidden'),
          this.m_context.Dom.appendChild(this.m_canvas),
          (this.m_renderer = new wr({ antialias: !0, canvas: this.m_canvas, precision: 'highp', alpha: !0 })),
          this.m_renderer.setClearColor(16777215, 0),
          this.m_renderer.setPixelRatio(window.devicePixelRatio),
          (this.m_renderer.shadowMap.enabled = !0),
          (this.m_camera = new Ii(60, this.m_canvas.width / this.m_canvas.height, 1e-5, 1e11)),
          this.m_camera.position.set(0, 0, 100),
          (this.m_scene = this.m_context.SceneManager.Scene),
          (this.m_effectScene = this.m_context.SceneManager.EffectScene),
          (this.m_sceneManger = this.m_context.SceneManager),
          (this.m_controls = new qh(this.m_camera)),
          this.m_controls.addEventListener('zoom', (e) => {
            (this.ScreenModelScale = Yh.GetScale(e, this.m_context.Dom.offsetHeight)),
              this.m_sceneManger.SignModel.children.forEach((e) => {
                e.userData.scale
                  ? e.scale.set(
                      this.ScreenModelScale * e.userData.scale.x,
                      this.ScreenModelScale * e.userData.scale.y,
                      this.ScreenModelScale * e.userData.scale.z,
                    )
                  : e.scale.set(this.ScreenModelScale, this.ScreenModelScale, this.ScreenModelScale);
              }),
              this.m_sceneManger.AuxModel.children.forEach((e) => {
                e.userData.scale &&
                  e.scale.set(
                    this.ScreenModelScale * e.userData.scale.x,
                    this.ScreenModelScale * e.userData.scale.y,
                    this.ScreenModelScale * e.userData.scale.z,
                  );
              });
          }),
          (this.ScreenModelScale = Yh.GetScale(this.m_camera, this.m_context.Dom.offsetHeight)),
          (this.m_renderTarget = new Te(
            this.m_context.Dom.clientWidth * this.m_renderer.getPixelRatio(),
            this.m_context.Dom.clientHeight * this.m_renderer.getPixelRatio(),
          )),
          (this.m_meshDisableMaterial = new Xt({ color: new ve('grey'), side: 2 })),
          (this.m_lineDisableMaterial = new la({ color: new ve('grey') })),
          (this.m_hasPicked = !1),
          (this.m_hasMoved = !1),
          this.m_controls.listenToKeyEvents(this.m_context.Dom),
          this.bindEvent(),
          this.initCss2dRenderer(),
          this.resize(null);
      }
      get Canvas() {
        return this.m_canvas;
      }
      get Controls() {
        return this.m_controls;
      }
      get Camera() {
        return this.m_camera;
      }
      get CameraRay() {
        return this.m_context.SelectionManager.CameraRay;
      }
      get Renderer() {
        return this.m_renderer;
      }
      bindEvent() {
        this.m_renderer.domElement.addEventListener('mousewheel', this.mousewheel.bind(this)),
          this.m_renderer.domElement.addEventListener('pointerdown', this.mousedown.bind(this)),
          this.m_renderer.domElement.addEventListener('pointermove', this.mousemove.bind(this)),
          this.m_renderer.domElement.addEventListener('pointerup', this.mouseup.bind(this)),
          this.m_renderer.domElement.addEventListener('resize', this.resize.bind(this)),
          window.addEventListener('resize', this.resize.bind(this), !1);
      }
      get EventManager() {
        return this.m_eventManager;
      }
      mousedown(e) {
        this.m_eventManager.dispatchEvent('pointerdown', e), this.Render();
      }
      mouseup(e) {
        this.m_eventManager.dispatchEvent('pointerup', e), this.Render();
      }
      mousemove(e) {
        this.m_eventManager.dispatchEvent('pointermove', e), this.Render();
      }
      Resize() {
        (this.m_camera.aspect = this.m_controls.domElement.offsetWidth / this.m_controls.domElement.offsetHeight),
          this.m_camera.updateProjectionMatrix(),
          this.m_renderer.setSize(this.m_context.Dom.clientWidth, this.m_context.Dom.clientHeight),
          this.CSS2DRenderer.setSize(this.m_context.Dom.clientWidth, this.m_context.Dom.clientHeight),
          this.Render();
      }
      resize(e) {
        this.Resize();
      }
      mousewheel(e) {
        this.m_eventManager.dispatchEvent('mousewheel', e), this.Render();
      }
      Render() {
        (wi.prototype.onBeforeRender = cc),
          requestAnimationFrame(() => {
            this.m_renderer.render(this.m_scene, this.m_camera), this.CSS2DRenderer.render(this.m_scene, this.m_camera);
          });
      }
      animate() {
        this.Render(), requestAnimationFrame(this.animate.bind(this));
      }
      AreaOfTriangle(e, t, i) {
        let n = new Pe(),
          s = new Pe();
        (n = e.clone().sub(t)), (s = e.clone().sub(i));
        let r = new Pe();
        return r.crossVectors(n, s), r.length() / 2;
      }
      computeGeoArea(e) {
        let t = 0;
        if (e.index) {
          let i = e.index,
            n = e.attributes.position;
          for (let s = 0; s < e.index.count; s += 3) {
            let e = i.getX(s),
              r = i.getX(s + 1),
              a = i.getX(s + 2),
              o = new Pe(n.getX(e), n.getY(e), n.getZ(e)),
              l = new Pe(n.getX(r), n.getY(r), n.getZ(r)),
              h = new Pe(n.getX(a), n.getY(a), n.getZ(a));
            t += this.AreaOfTriangle(o, l, h);
          }
        }
        return t;
      }
      isDeleteHole(e, t, i, n) {
        for (let s = 0; s < t.length; s++)
          if (e != s) {
            let e = [];
            for (let i = 0; i < t[s].length; i++) e.push(new se(t[s][i].X, t[s][i].Y));
            if (e.length > 2) {
              let t = new Xa(e),
                s = new bo(t);
              s.computeBoundingBox();
              let r = s.boundingBox;
              if (i.intersectsBox(r)) {
                if (this.computeGeoArea(n) < this.computeGeoArea(s)) return !0;
              }
            }
          }
        return !1;
      }
      AddPolygon(e, t, i) {
        let n = [];
        for (let s = 0; s < e.length; s++) {
          const r = e[s];
          let a = [];
          if (!r.Edges || 0 == r.Edges.length) continue;
          for (let e = 0; e < r.Edges.length; e++) {
            let t = r.Edges[e];
            a.push(new se(t.X, t.Y));
          }
          let o = new Xa(a);
          if (r.Holes && r.Holes.length >= 1)
            for (let e = 0; e < r.Holes.length; e++) {
              let t = r.Holes[e];
              if (0 == t.length) continue;
              let i = new ja(),
                n = 0;
              t.forEach((e) => {
                0 == n ? i.moveTo(e.X, e.Y) : i.lineTo(e.X, e.Y), n++;
              }),
                i.lineTo(t[0].X, t[0].Y),
                o.holes.push(i);
            }
          t instanceof Wt
            ? (t.side = 2)
            : (t = new Lo({ color: 4906476, transparent: !0, opacity: 0.41, flatShading: !0 }));
          let l = new bo(o),
            h = new wi(l, t),
            c = new ai();
          c.setFromPoints(a);
          let u = new _a(c, new la({ color: 4906476, linewidth: 2 }));
          h.add(u),
            this.m_context.SceneManager.ThreeLayer.children.push(h),
            i && i(h, r),
            (h.userData.id = r.Id),
            n.push(r.Id);
        }
        return this.Render(), n;
      }
      AddSignPoints(e, t) {
        let i = Yh.GetScale(this.Camera, this.m_context.Dom.offsetHeight),
          n = [];
        e.forEach((e) => {
          n.push(e.x, e.y, e.z);
        });
        let s,
          r = new ai();
        if ((r.setAttribute('position', new Zt(new Float32Array(n), 3)), t)) {
          let e = new $o().load(t);
          s = new xa({ size: i, transparent: !0, color: new ve(16777215), map: e });
        } else s = new xa({ size: i });
        let a = new wa(r, s);
        return this.m_context.SceneManager.ThreeLayer.children.push(a), this.Render(), [a.id.toString()];
      }
      DelPolygonById(...e) {
        e.forEach((e) => {
          for (let t = 0; t < this.m_context.SceneManager.ThreeLayer.children.length; t++)
            this.m_context.SceneManager.ThreeLayer.children[t].userData.id == e &&
              this.m_context.SceneManager.ThreeLayer.children.splice(t, 1);
        }),
          this.m_context.SelectionManager.m_selection.clear(),
          this.Render();
      }
      HidePolygons(e = !1, ...t) {
        t.forEach((t) => {
          for (let i = 0; i < this.m_context.SceneManager.ThreeLayer.children.length; i++)
            this.m_context.SceneManager.ThreeLayer.children[i].userData.id == t &&
              this.m_context.SceneManager.ThreeLayer.children[i].traverse(function (t) {
                t.visible = e;
              });
        }),
          this.Render();
      }
      SetPolygonsColor(e = '0xffffff', ...t) {
        let i = [];
        return (
          t.forEach((t) => {
            for (let n = 0; n < this.m_context.SceneManager.ThreeLayer.children.length; n++)
              this.m_context.SceneManager.ThreeLayer.children[n].userData.id == t &&
                this.m_context.SceneManager.ThreeLayer.children[n].traverse(function (t) {
                  if (t instanceof wi && t.material) {
                    i.length || i.push(t.material.clone());
                    let n = t.material.clone();
                    (n.color = new ve(e)), (t.material = n);
                  }
                });
          }),
          this.Render(),
          i
        );
      }
      DelSignById(e) {
        e.forEach((e) => {
          for (let t = 0; t < this.m_context.SceneManager.SignModel.children.length; t++)
            this.m_context.SceneManager.SignModel.children[t].userData.id == e &&
              this.m_context.SceneManager.SignModel.children.splice(t, 1);
        }),
          this.Render();
      }
      ZoomTo(e) {
        return this.ZoomTobox(e);
      }
      ZoomTobox(e) {
        let t = new Re();
        return e instanceof It ? t.setFromObject(e) : (t = e), this.m_controls.ZoomToBox(t);
      }
      ZoomToFit() {
        let e = this.m_sceneManger.GetBox();
        this.m_controls.ZoomToBox(e), this.Render();
      }
      get Model() {
        return this.m_context.ModelManager;
      }
      SetVisibleLayerByNames(e, ...t) {
        this.SetVisibleLayerByIds(e, ...this.Model.getLayerIdsByNames(...t)), this.Render();
      }
      SetVisibleLayerByIds(e, ...t) {
        t.forEach((t) => {
          this.m_context.ModelManager.LayerTable[t] &&
            ((this.m_context.ModelManager.LayerTable[t].Visible = e),
            this.m_context.ModelManager.LayerTable[t].Objects.forEach((t) => (t.visible = e)));
        }),
          this.Render();
      }
      EnableLayerByNames(e, ...t) {
        this.EnableLayerByIds(e, ...this.Model.getLayerIdsByNames(...t)), this.Render();
      }
      EnableAllLayers(e) {
        let t = Object.keys(this.m_context.ModelManager.LayerTable);
        this.EnableLayerByIds(e, ...t);
      }
      EnableThreeModel(e) {
        this.m_sceneManger.ThreeLayer.userData.disEnable = !e;
      }
      EnableLayerByIds(e, ...t) {
        t.forEach((t) => {
          this.m_context.ModelManager.LayerTable[t] &&
            ((this.m_context.ModelManager.LayerTable[t].Enabled = e),
            this.m_context.ModelManager.LayerTable[t].Objects.forEach((t) => {
              e
                ? ((t instanceof pa || t instanceof _a) &&
                    t.userData.enableColor &&
                    ((t.material = t.userData.enableColor), delete t.userData.enableColor),
                  t instanceof wi &&
                    t.userData.enableColor &&
                    ((t.material = t.userData.enableColor), delete t.userData.enableColor))
                : ((t instanceof pa || t instanceof _a) &&
                    (t.userData.enableColor ||
                      ((t.userData.enableColor = t.material), (t.material = this.m_lineDisableMaterial))),
                  t instanceof wi &&
                    (t.userData.enableColor ||
                      ((t.userData.enableColor = t.material), (t.material = this.m_meshDisableMaterial))));
            }));
        }),
          this.Render();
      }
      DeleteLayerByNames(...e) {
        this.DeleteLayerByIds(...this.Model.getLayerIdsByNames(...e)), this.Render();
      }
      DeleteLayerByIds(...e) {
        this.Model.DeleteLayerByIds(...e), this.Render();
      }
      UpdateColorByLayerNames(e, ...t) {
        this.UpdateColorByLayerIds(e, ...this.Model.getLayerIdsByNames(...t)), this.Render();
      }
      UpdateColorByLayerIds(e, ...t) {
        t.forEach((t) => {
          this.Model.LayerTable[t].Objects.forEach((t) => {
            (t instanceof pa || t instanceof _a) && (t.material = this.m_context.MaterialManager.createLineMaterial(e)),
              t instanceof wi && (t.material = this.m_context.MaterialManager.createMeshBasicMaterial(e));
          });
        }),
          this.Render();
      }
      RecoverColorByLayerNames(...e) {
        this.RecoverColorByLayerIds(...this.Model.getLayerIdsByNames(...e)), this.Render();
      }
      RecoverColorByLayerIds(...e) {
        e.forEach((e) => {
          this.Model.LayerTable[e].Objects.forEach((e) => {
            (e instanceof pa || e instanceof wa || e instanceof wi) &&
              e.userData.originalMaterial &&
              (e.material = e.userData.originalMaterial);
          });
        }),
          this.Render();
      }
      RecoverAllLayerColor() {
        this.RecoverColorByLayerIds(...Object.keys(this.m_context.ModelManager.LayerTable));
      }
      Delete(...e) {
        this.m_context.SceneManager.ThreeLayer.remove(...e),
          this.m_context.SceneManager.SignModel.remove(...e),
          this.m_context.SceneManager.AuxModel.remove(...e),
          this.Render();
      }
      ClearSign() {
        this.m_context.SceneManager.SignModel.clear();
      }
      searchRectangleByIds(e, t, ...i) {
        let n = new Zh(
            this.m_context.ViewManager.Camera,
            this.m_context.ModelManager,
            this.m_context.SceneManager.ThreeLayer,
            this.m_context.SceneManager.SignModel,
          ),
          s = this.screenCoordToStd(e),
          r = this.screenCoordToStd(t);
        null == n || n.select(s, r);
        let a = [];
        if (null == n ? void 0 : n.Collection) {
          let e = null == n ? void 0 : n.Collection;
          i.forEach((t) => {
            for (let i = 0; i < e.length; i++) e[i].layerId == t && a.push(e[i]);
          });
        }
        return a;
      }
      searchRectangleByNames(e, t, ...i) {
        return this.searchRectangleByIds(e, t, ...this.Model.getLayerIdsByNames(...i));
      }
      addSign(e, t, i, n) {
        let s = Yh.GetScale(this.Camera, this.m_context.Dom.offsetHeight),
          r = new $o(),
          a = new Cr({ map: r.load(t) }),
          o = new Hr(a);
        return (
          o.scale.set(i * s, n * s, 1),
          (o.userData.scale = { x: i, y: n, z: 1 }),
          o.position.copy(e),
          this.m_context.SceneManager.SignModel.add(o),
          o
        );
      }
      screenCoordToStd(e) {
        const t = (e.x / this.m_context.Dom.clientWidth) * 2 - 1,
          i = (-e.y / this.m_context.Dom.clientHeight) * 2 + 1;
        let n = new Pe(),
          s = new Al();
        return s.setFromCamera(new se(t, i), this.Camera), s.ray.intersectPlane(new Bi(new Pe(0, 0, 1), 0), n), n;
      }
      EnableMask(e) {
        e = e.expandByScalar(e.min.distanceTo(e.max));
        let t = new se(e.min.x, e.min.y),
          i = new se(e.max.x, e.max.y),
          n = new Xa(tc(i, t)),
          s = new bo(n);
        (s.userData.boxMax = t), (s.userData.boxMin = i);
        let r = new Xt({ color: 2171169, colorWrite: !0, transparent: !0, opacity: 0.7 }),
          a = new wi(s, r);
        return (
          (a.userData.isDisEnableRegion = !0),
          (a.userData.disenable = !0),
          (a.renderOrder = 100),
          this.m_sceneManger.MaskLayer.add(a),
          this.Render(),
          a
        );
      }
      get Mask() {
        return this.m_sceneManger.MaskLayer;
      }
      SetMaskOpacity(e, t) {
        e.material.opacity = t;
      }
      SetMaskHole(e, ...t) {
        if (!e.userData || !e.userData.isDisEnableRegion) throw new Error(`${e}disRegion`);
        if (!(e.geometry.userData && e.geometry.userData.boxMax && e.geometry.userData.boxMin))
          throw new Error(`${e}disRegionboxMax and boxMin`);
        {
          let i = e.geometry.userData.boxMax,
            n = e.geometry.userData.boxMin,
            s = new Xa(tc(n, i));
          t.forEach((e) => {
            let t = new ja(),
              i = tc(e.min, e.max);
            t.moveTo(i[3].x, i[3].y),
              t.lineTo(i[2].x, i[2].y),
              t.lineTo(i[1].x, i[1].y),
              t.lineTo(i[0].x, i[0].y),
              t.lineTo(i[3].x, i[3].y),
              s.holes.push(t);
          }),
            e.geometry.dispose();
          let r = new bo(s);
          (r.userData.boxMax = e.geometry.userData.boxMax),
            (r.userData.boxMin = e.geometry.userData.boxMin),
            (e.geometry = r),
            this.Render();
        }
      }
      initCss2dRenderer() {
        (this.CSS2DRenderer = new lc()),
          this.CSS2DRenderer.setSize(this.m_context.Dom.clientWidth, this.m_context.Dom.clientHeight);
        let e = document.createElement('div');
        e.appendChild(this.CSS2DRenderer.domElement), (e.className = 'cssRender'), this.m_context.Dom.appendChild(e);
      }
    }
    function cc(e, t, i, n, s, r) {
      if ('insert' == this.name) {
      }
    }
    class uc extends It {}
    class dc extends i {
      constructor(e) {
        super(e), (this.m_scene = new Ar());
        let t = new uc();
        (t.name = 'modelLayer'), this.m_scene.add(t), (this.m_modelLayer = t);
        let i = new uc();
        (i.name = 'threejsModel'), this.m_scene.add(i), (this.m_threejsModel = i);
        let n = new uc();
        (n.name = 'auxModel'), this.m_scene.add(n), (this.m_auxModel = n);
        let s = new uc();
        (n.name = 'signModel'), this.m_scene.add(s), (this.m_signModel = s);
        let r = new uc();
        (n.name = 'maskLayer'),
          this.m_scene.add(r),
          (this.m_maskLayer = r),
          (this.m_AxisHelper = new Ol(3e4)),
          (this.m_lightLayer = this.CreateLightLayer()),
          (this.m_scene.background = new ve(2171169)),
          this.m_scene.add(this.m_lightLayer),
          (this.m_effectScene = new Ar()),
          this.m_effectScene.add(this.CreateLightLayer());
      }
      get Scene() {
        return this.m_scene;
      }
      get EffectScene() {
        return this.m_effectScene;
      }
      get AuxModel() {
        return this.m_auxModel;
      }
      get SignModel() {
        return this.m_signModel;
      }
      get ModelLayer() {
        return this.m_modelLayer;
      }
      get ThreeLayer() {
        return this.m_threejsModel;
      }
      get MaskLayer() {
        return this.m_maskLayer;
      }
      GetBox() {
        let e = new Re();
        e.setFromObject(this.ModelLayer);
        let t = new Re();
        return t.setFromObject(this.ThreeLayer), t.isEmpty() || (e.expandByPoint(t.max), e.expandByPoint(t.min)), e;
      }
      CreateLightLayer() {
        let e = new uc();
        e.name = 'lightLayer';
        const t = new dl(16777215);
        t.position.set(1, 1, 1), e.add(t);
        const i = new dl(8840);
        i.position.set(-1, -1, -1), e.add(i);
        const n = new ml(2236962);
        return e.add(n), e;
      }
      ClearThreeLayer() {
        this.ThreeLayer.clear();
      }
      ClearSign() {
        this.SignModel.clear();
      }
    }
    var mc;
    !(function (e) {
      (e.StringToByte = function (e) {
        var t,
          i,
          n = new Array();
        t = e.length;
        for (var s = 0; s < t; s++)
          (i = e.charCodeAt(s)) >= 65536 && i <= 1114111
            ? (n.push(((i >> 18) & 7) | 240),
              n.push(((i >> 12) & 63) | 128),
              n.push(((i >> 6) & 63) | 128),
              n.push((63 & i) | 128))
            : i >= 2048 && i <= 65535
            ? (n.push(((i >> 12) & 15) | 224), n.push(((i >> 6) & 63) | 128), n.push((63 & i) | 128))
            : i >= 128 && i <= 2047
            ? (n.push(((i >> 6) & 31) | 192), n.push((63 & i) | 128))
            : n.push(255 & i);
        return n;
      }),
        (e.BytesToString = function (e) {
          if ('string' == typeof e) return e;
          let t = (function (e) {
            if (e.length > 0 && 0 == e[0]) return !1;
            var t = 0;
            for (; t < e.length; ) {
              var i,
                n = e[t++];
              if (n <= 127) i = 0;
              else if (n >= 194 && n <= 223) i = 1;
              else if (n >= 224 && n <= 239) i = 2;
              else {
                if (!(n >= 240 && n <= 244)) return !1;
                i = 3;
              }
              for (; i > 0 && t < e.length; ) {
                if ((n = e[t++]) < 128 || n > 191) return !1;
                i--;
              }
            }
            return !0;
          })(e);
          if (t) {
            for (var i = '', n = e, s = 0; s < n.length; s++) {
              var r = n[s].toString(2),
                a = r.match(/^1+?(?=0)/);
              if (a && 8 == r.length) {
                for (var o = a[0].length, l = n[s].toString(2).slice(7 - o), h = 1; h < o; h++)
                  l += n[h + s].toString(2).slice(2);
                (i += String.fromCharCode(parseInt(l, 2))), (s += o - 1);
              } else i += String.fromCharCode(n[s]);
            }
            return i;
          }
          return new TextDecoder('gbk').decode(e);
        });
    })(mc || (mc = {}));
    class pc {
      constructor() {
        (this._dataLength = 0),
          (this._bufferLength = 0),
          (this._state = new Int32Array(4)),
          (this._buffer = new ArrayBuffer(68)),
          (this._buffer8 = new Uint8Array(this._buffer, 0, 68)),
          (this._buffer32 = new Uint32Array(this._buffer, 0, 17)),
          this.start();
      }
      static hashStr(e, t = !1) {
        return this.onePassHasher.start().appendStr(e).end(t);
      }
      static hashAsciiStr(e, t = !1) {
        return this.onePassHasher.start().appendAsciiStr(e).end(t);
      }
      static _hex(e) {
        const t = pc.hexChars,
          i = pc.hexOut;
        let n, s, r, a;
        for (a = 0; a < 4; a += 1)
          for (s = 8 * a, n = e[a], r = 0; r < 8; r += 2)
            (i[s + 1 + r] = t.charAt(15 & n)), (n >>>= 4), (i[s + 0 + r] = t.charAt(15 & n)), (n >>>= 4);
        return i.join('');
      }
      static _md5cycle(e, t) {
        let i = e[0],
          n = e[1],
          s = e[2],
          r = e[3];
        (i += (((n & s) | (~n & r)) + t[0] - 680876936) | 0),
          (i = (((i << 7) | (i >>> 25)) + n) | 0),
          (r += (((i & n) | (~i & s)) + t[1] - 389564586) | 0),
          (r = (((r << 12) | (r >>> 20)) + i) | 0),
          (s += (((r & i) | (~r & n)) + t[2] + 606105819) | 0),
          (s = (((s << 17) | (s >>> 15)) + r) | 0),
          (n += (((s & r) | (~s & i)) + t[3] - 1044525330) | 0),
          (n = (((n << 22) | (n >>> 10)) + s) | 0),
          (i += (((n & s) | (~n & r)) + t[4] - 176418897) | 0),
          (i = (((i << 7) | (i >>> 25)) + n) | 0),
          (r += (((i & n) | (~i & s)) + t[5] + 1200080426) | 0),
          (r = (((r << 12) | (r >>> 20)) + i) | 0),
          (s += (((r & i) | (~r & n)) + t[6] - 1473231341) | 0),
          (s = (((s << 17) | (s >>> 15)) + r) | 0),
          (n += (((s & r) | (~s & i)) + t[7] - 45705983) | 0),
          (n = (((n << 22) | (n >>> 10)) + s) | 0),
          (i += (((n & s) | (~n & r)) + t[8] + 1770035416) | 0),
          (i = (((i << 7) | (i >>> 25)) + n) | 0),
          (r += (((i & n) | (~i & s)) + t[9] - 1958414417) | 0),
          (r = (((r << 12) | (r >>> 20)) + i) | 0),
          (s += (((r & i) | (~r & n)) + t[10] - 42063) | 0),
          (s = (((s << 17) | (s >>> 15)) + r) | 0),
          (n += (((s & r) | (~s & i)) + t[11] - 1990404162) | 0),
          (n = (((n << 22) | (n >>> 10)) + s) | 0),
          (i += (((n & s) | (~n & r)) + t[12] + 1804603682) | 0),
          (i = (((i << 7) | (i >>> 25)) + n) | 0),
          (r += (((i & n) | (~i & s)) + t[13] - 40341101) | 0),
          (r = (((r << 12) | (r >>> 20)) + i) | 0),
          (s += (((r & i) | (~r & n)) + t[14] - 1502002290) | 0),
          (s = (((s << 17) | (s >>> 15)) + r) | 0),
          (n += (((s & r) | (~s & i)) + t[15] + 1236535329) | 0),
          (n = (((n << 22) | (n >>> 10)) + s) | 0),
          (i += (((n & r) | (s & ~r)) + t[1] - 165796510) | 0),
          (i = (((i << 5) | (i >>> 27)) + n) | 0),
          (r += (((i & s) | (n & ~s)) + t[6] - 1069501632) | 0),
          (r = (((r << 9) | (r >>> 23)) + i) | 0),
          (s += (((r & n) | (i & ~n)) + t[11] + 643717713) | 0),
          (s = (((s << 14) | (s >>> 18)) + r) | 0),
          (n += (((s & i) | (r & ~i)) + t[0] - 373897302) | 0),
          (n = (((n << 20) | (n >>> 12)) + s) | 0),
          (i += (((n & r) | (s & ~r)) + t[5] - 701558691) | 0),
          (i = (((i << 5) | (i >>> 27)) + n) | 0),
          (r += (((i & s) | (n & ~s)) + t[10] + 38016083) | 0),
          (r = (((r << 9) | (r >>> 23)) + i) | 0),
          (s += (((r & n) | (i & ~n)) + t[15] - 660478335) | 0),
          (s = (((s << 14) | (s >>> 18)) + r) | 0),
          (n += (((s & i) | (r & ~i)) + t[4] - 405537848) | 0),
          (n = (((n << 20) | (n >>> 12)) + s) | 0),
          (i += (((n & r) | (s & ~r)) + t[9] + 568446438) | 0),
          (i = (((i << 5) | (i >>> 27)) + n) | 0),
          (r += (((i & s) | (n & ~s)) + t[14] - 1019803690) | 0),
          (r = (((r << 9) | (r >>> 23)) + i) | 0),
          (s += (((r & n) | (i & ~n)) + t[3] - 187363961) | 0),
          (s = (((s << 14) | (s >>> 18)) + r) | 0),
          (n += (((s & i) | (r & ~i)) + t[8] + 1163531501) | 0),
          (n = (((n << 20) | (n >>> 12)) + s) | 0),
          (i += (((n & r) | (s & ~r)) + t[13] - 1444681467) | 0),
          (i = (((i << 5) | (i >>> 27)) + n) | 0),
          (r += (((i & s) | (n & ~s)) + t[2] - 51403784) | 0),
          (r = (((r << 9) | (r >>> 23)) + i) | 0),
          (s += (((r & n) | (i & ~n)) + t[7] + 1735328473) | 0),
          (s = (((s << 14) | (s >>> 18)) + r) | 0),
          (n += (((s & i) | (r & ~i)) + t[12] - 1926607734) | 0),
          (n = (((n << 20) | (n >>> 12)) + s) | 0),
          (i += ((n ^ s ^ r) + t[5] - 378558) | 0),
          (i = (((i << 4) | (i >>> 28)) + n) | 0),
          (r += ((i ^ n ^ s) + t[8] - 2022574463) | 0),
          (r = (((r << 11) | (r >>> 21)) + i) | 0),
          (s += ((r ^ i ^ n) + t[11] + 1839030562) | 0),
          (s = (((s << 16) | (s >>> 16)) + r) | 0),
          (n += ((s ^ r ^ i) + t[14] - 35309556) | 0),
          (n = (((n << 23) | (n >>> 9)) + s) | 0),
          (i += ((n ^ s ^ r) + t[1] - 1530992060) | 0),
          (i = (((i << 4) | (i >>> 28)) + n) | 0),
          (r += ((i ^ n ^ s) + t[4] + 1272893353) | 0),
          (r = (((r << 11) | (r >>> 21)) + i) | 0),
          (s += ((r ^ i ^ n) + t[7] - 155497632) | 0),
          (s = (((s << 16) | (s >>> 16)) + r) | 0),
          (n += ((s ^ r ^ i) + t[10] - 1094730640) | 0),
          (n = (((n << 23) | (n >>> 9)) + s) | 0),
          (i += ((n ^ s ^ r) + t[13] + 681279174) | 0),
          (i = (((i << 4) | (i >>> 28)) + n) | 0),
          (r += ((i ^ n ^ s) + t[0] - 358537222) | 0),
          (r = (((r << 11) | (r >>> 21)) + i) | 0),
          (s += ((r ^ i ^ n) + t[3] - 722521979) | 0),
          (s = (((s << 16) | (s >>> 16)) + r) | 0),
          (n += ((s ^ r ^ i) + t[6] + 76029189) | 0),
          (n = (((n << 23) | (n >>> 9)) + s) | 0),
          (i += ((n ^ s ^ r) + t[9] - 640364487) | 0),
          (i = (((i << 4) | (i >>> 28)) + n) | 0),
          (r += ((i ^ n ^ s) + t[12] - 421815835) | 0),
          (r = (((r << 11) | (r >>> 21)) + i) | 0),
          (s += ((r ^ i ^ n) + t[15] + 530742520) | 0),
          (s = (((s << 16) | (s >>> 16)) + r) | 0),
          (n += ((s ^ r ^ i) + t[2] - 995338651) | 0),
          (n = (((n << 23) | (n >>> 9)) + s) | 0),
          (i += ((s ^ (n | ~r)) + t[0] - 198630844) | 0),
          (i = (((i << 6) | (i >>> 26)) + n) | 0),
          (r += ((n ^ (i | ~s)) + t[7] + 1126891415) | 0),
          (r = (((r << 10) | (r >>> 22)) + i) | 0),
          (s += ((i ^ (r | ~n)) + t[14] - 1416354905) | 0),
          (s = (((s << 15) | (s >>> 17)) + r) | 0),
          (n += ((r ^ (s | ~i)) + t[5] - 57434055) | 0),
          (n = (((n << 21) | (n >>> 11)) + s) | 0),
          (i += ((s ^ (n | ~r)) + t[12] + 1700485571) | 0),
          (i = (((i << 6) | (i >>> 26)) + n) | 0),
          (r += ((n ^ (i | ~s)) + t[3] - 1894986606) | 0),
          (r = (((r << 10) | (r >>> 22)) + i) | 0),
          (s += ((i ^ (r | ~n)) + t[10] - 1051523) | 0),
          (s = (((s << 15) | (s >>> 17)) + r) | 0),
          (n += ((r ^ (s | ~i)) + t[1] - 2054922799) | 0),
          (n = (((n << 21) | (n >>> 11)) + s) | 0),
          (i += ((s ^ (n | ~r)) + t[8] + 1873313359) | 0),
          (i = (((i << 6) | (i >>> 26)) + n) | 0),
          (r += ((n ^ (i | ~s)) + t[15] - 30611744) | 0),
          (r = (((r << 10) | (r >>> 22)) + i) | 0),
          (s += ((i ^ (r | ~n)) + t[6] - 1560198380) | 0),
          (s = (((s << 15) | (s >>> 17)) + r) | 0),
          (n += ((r ^ (s | ~i)) + t[13] + 1309151649) | 0),
          (n = (((n << 21) | (n >>> 11)) + s) | 0),
          (i += ((s ^ (n | ~r)) + t[4] - 145523070) | 0),
          (i = (((i << 6) | (i >>> 26)) + n) | 0),
          (r += ((n ^ (i | ~s)) + t[11] - 1120210379) | 0),
          (r = (((r << 10) | (r >>> 22)) + i) | 0),
          (s += ((i ^ (r | ~n)) + t[2] + 718787259) | 0),
          (s = (((s << 15) | (s >>> 17)) + r) | 0),
          (n += ((r ^ (s | ~i)) + t[9] - 343485551) | 0),
          (n = (((n << 21) | (n >>> 11)) + s) | 0),
          (e[0] = (i + e[0]) | 0),
          (e[1] = (n + e[1]) | 0),
          (e[2] = (s + e[2]) | 0),
          (e[3] = (r + e[3]) | 0);
      }
      start() {
        return (this._dataLength = 0), (this._bufferLength = 0), this._state.set(pc.stateIdentity), this;
      }
      appendStr(e) {
        const t = this._buffer8,
          i = this._buffer32;
        let n,
          s,
          r = this._bufferLength;
        for (s = 0; s < e.length; s += 1) {
          if (((n = e.charCodeAt(s)), n < 128)) t[r++] = n;
          else if (n < 2048) (t[r++] = 192 + (n >>> 6)), (t[r++] = (63 & n) | 128);
          else if (n < 55296 || n > 56319)
            (t[r++] = 224 + (n >>> 12)), (t[r++] = ((n >>> 6) & 63) | 128), (t[r++] = (63 & n) | 128);
          else {
            if (((n = 1024 * (n - 55296) + (e.charCodeAt(++s) - 56320) + 65536), n > 1114111))
              throw new Error('Unicode standard supports code points up to U+10FFFF');
            (t[r++] = 240 + (n >>> 18)),
              (t[r++] = ((n >>> 12) & 63) | 128),
              (t[r++] = ((n >>> 6) & 63) | 128),
              (t[r++] = (63 & n) | 128);
          }
          r >= 64 && ((this._dataLength += 64), pc._md5cycle(this._state, i), (r -= 64), (i[0] = i[16]));
        }
        return (this._bufferLength = r), this;
      }
      appendAsciiStr(e) {
        const t = this._buffer8,
          i = this._buffer32;
        let n,
          s = this._bufferLength,
          r = 0;
        for (;;) {
          for (n = Math.min(e.length - r, 64 - s); n--; ) t[s++] = e.charCodeAt(r++);
          if (s < 64) break;
          (this._dataLength += 64), pc._md5cycle(this._state, i), (s = 0);
        }
        return (this._bufferLength = s), this;
      }
      appendByteArray(e) {
        const t = this._buffer8,
          i = this._buffer32;
        let n,
          s = this._bufferLength,
          r = 0;
        for (;;) {
          for (n = Math.min(e.length - r, 64 - s); n--; ) t[s++] = e[r++];
          if (s < 64) break;
          (this._dataLength += 64), pc._md5cycle(this._state, i), (s = 0);
        }
        return (this._bufferLength = s), this;
      }
      getState() {
        const e = this._state;
        return {
          buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)),
          buflen: this._bufferLength,
          length: this._dataLength,
          state: [e[0], e[1], e[2], e[3]],
        };
      }
      setState(e) {
        const t = e.buffer,
          i = e.state,
          n = this._state;
        let s;
        for (
          this._dataLength = e.length,
            this._bufferLength = e.buflen,
            n[0] = i[0],
            n[1] = i[1],
            n[2] = i[2],
            n[3] = i[3],
            s = 0;
          s < t.length;
          s += 1
        )
          this._buffer8[s] = t.charCodeAt(s);
      }
      end(e = !1) {
        const t = this._bufferLength,
          i = this._buffer8,
          n = this._buffer32,
          s = 1 + (t >> 2);
        this._dataLength += t;
        const r = 8 * this._dataLength;
        if (
          ((i[t] = 128),
          (i[t + 1] = i[t + 2] = i[t + 3] = 0),
          n.set(pc.buffer32Identity.subarray(s), s),
          t > 55 && (pc._md5cycle(this._state, n), n.set(pc.buffer32Identity)),
          r <= 4294967295)
        )
          n[14] = r;
        else {
          const e = r.toString(16).match(/(.*?)(.{0,8})$/);
          if (null === e) return;
          const t = parseInt(e[2], 16),
            i = parseInt(e[1], 16) || 0;
          (n[14] = t), (n[15] = i);
        }
        return pc._md5cycle(this._state, n), e ? this._state : pc._hex(this._state);
      }
    }
    if (
      ((pc.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878])),
      (pc.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])),
      (pc.hexChars = '0123456789abcdef'),
      (pc.hexOut = []),
      (pc.onePassHasher = new pc()),
      '5d41402abc4b2a76b9719d911017c592' !== pc.hashStr('hello'))
    )
      throw new Error('Md5 self test failed.');
    class fc {
      constructor(e) {
        var t, i;
        (this.root_reference_id = ''),
          (this.block_path = ''),
          (this.root_block_id = ''),
          (this.type = ''),
          (this.id = e.id),
          (this.blockId = e.blockId),
          (this.layerId = e.layerId),
          (this.root_reference_id = e.root_reference_id),
          (null === (t = e.block_path) || void 0 === t ? void 0 : t.length) &&
            e.block_path.forEach((e, t) => {
              this.block_path += mc.BytesToString(e);
            }),
          (this.root_block_id = e.root_block_id);
        const n = new pc();
        (this.block_path = null === (i = this.block_path) || void 0 === i ? void 0 : i.replace(/,/g, '')),
          n.appendAsciiStr(this.block_path),
          (this.block_path = n.end());
      }
    }
    class gc extends fc {
      constructor(e) {
        super(e), (this.index = 0), (this.points = e.points), (this.indexes = e.indexes);
      }
      get V3Points() {
        let e = [];
        for (let t = 0; t < this.points.length; t += 3)
          e.push(new Pe(this.points[t], this.points[t + 1], this.points[t + 2]));
        return e;
      }
      get Lines() {
        let e = this.V3Points,
          t = [];
        for (let i = 0; i < this.indexes.length; i += 2) {
          const n = this.indexes[i],
            s = this.indexes[i + 1];
          t.push(new Pl(e[n], e[s]));
        }
        return t;
      }
      static clone(e) {
        let t = new gc({ id: e.id, blockId: e.blockId, indexes: e.indexes, layerId: e.layerId, points: e.points });
        return (
          (t.sphere = e.sphere),
          (t.box = e.box),
          (t.root_reference_id = e.root_reference_id),
          (t.block_path = e.block_path),
          (t.root_block_id = e.root_block_id),
          t
        );
      }
    }
    class _c extends fc {
      constructor(e) {
        super(e), (this.count = 0), (this.vertexs = e.vertexs), (this.indexes = e.indexes);
      }
      static clone(e) {
        let t = new _c({ id: e.id, blockId: e.blockId, indexes: e.indexes, layerId: e.layerId, vertexs: e.vertexs });
        return (
          (t.sphere = e.sphere),
          (t.box = e.box),
          (t.root_reference_id = e.root_reference_id),
          (t.block_path = e.block_path),
          (t.root_block_id = e.root_block_id),
          t
        );
      }
    }
    class vc extends fc {
      constructor(e) {
        super(e), (this.blockRecord = e.blockRecord), (this.matrix = e.matrix);
      }
    }
    const xc = [
      '00',
      '01',
      '02',
      '03',
      '04',
      '05',
      '06',
      '07',
      '08',
      '09',
      '0a',
      '0b',
      '0c',
      '0d',
      '0e',
      '0f',
      '10',
      '11',
      '12',
      '13',
      '14',
      '15',
      '16',
      '17',
      '18',
      '19',
      '1a',
      '1b',
      '1c',
      '1d',
      '1e',
      '1f',
      '20',
      '21',
      '22',
      '23',
      '24',
      '25',
      '26',
      '27',
      '28',
      '29',
      '2a',
      '2b',
      '2c',
      '2d',
      '2e',
      '2f',
      '30',
      '31',
      '32',
      '33',
      '34',
      '35',
      '36',
      '37',
      '38',
      '39',
      '3a',
      '3b',
      '3c',
      '3d',
      '3e',
      '3f',
      '40',
      '41',
      '42',
      '43',
      '44',
      '45',
      '46',
      '47',
      '48',
      '49',
      '4a',
      '4b',
      '4c',
      '4d',
      '4e',
      '4f',
      '50',
      '51',
      '52',
      '53',
      '54',
      '55',
      '56',
      '57',
      '58',
      '59',
      '5a',
      '5b',
      '5c',
      '5d',
      '5e',
      '5f',
      '60',
      '61',
      '62',
      '63',
      '64',
      '65',
      '66',
      '67',
      '68',
      '69',
      '6a',
      '6b',
      '6c',
      '6d',
      '6e',
      '6f',
      '70',
      '71',
      '72',
      '73',
      '74',
      '75',
      '76',
      '77',
      '78',
      '79',
      '7a',
      '7b',
      '7c',
      '7d',
      '7e',
      '7f',
      '80',
      '81',
      '82',
      '83',
      '84',
      '85',
      '86',
      '87',
      '88',
      '89',
      '8a',
      '8b',
      '8c',
      '8d',
      '8e',
      '8f',
      '90',
      '91',
      '92',
      '93',
      '94',
      '95',
      '96',
      '97',
      '98',
      '99',
      '9a',
      '9b',
      '9c',
      '9d',
      '9e',
      '9f',
      'a0',
      'a1',
      'a2',
      'a3',
      'a4',
      'a5',
      'a6',
      'a7',
      'a8',
      'a9',
      'aa',
      'ab',
      'ac',
      'ad',
      'ae',
      'af',
      'b0',
      'b1',
      'b2',
      'b3',
      'b4',
      'b5',
      'b6',
      'b7',
      'b8',
      'b9',
      'ba',
      'bb',
      'bc',
      'bd',
      'be',
      'bf',
      'c0',
      'c1',
      'c2',
      'c3',
      'c4',
      'c5',
      'c6',
      'c7',
      'c8',
      'c9',
      'ca',
      'cb',
      'cc',
      'cd',
      'ce',
      'cf',
      'd0',
      'd1',
      'd2',
      'd3',
      'd4',
      'd5',
      'd6',
      'd7',
      'd8',
      'd9',
      'da',
      'db',
      'dc',
      'dd',
      'de',
      'df',
      'e0',
      'e1',
      'e2',
      'e3',
      'e4',
      'e5',
      'e6',
      'e7',
      'e8',
      'e9',
      'ea',
      'eb',
      'ec',
      'ed',
      'ee',
      'ef',
      'f0',
      'f1',
      'f2',
      'f3',
      'f4',
      'f5',
      'f6',
      'f7',
      'f8',
      'f9',
      'fa',
      'fb',
      'fc',
      'fd',
      'fe',
      'ff',
    ];
    Math.PI, Math.PI;
    function yc() {
      const e = (4294967295 * Math.random()) | 0,
        t = (4294967295 * Math.random()) | 0,
        i = (4294967295 * Math.random()) | 0,
        n = (4294967295 * Math.random()) | 0;
      return (
        xc[255 & e] +
        xc[(e >> 8) & 255] +
        xc[(e >> 16) & 255] +
        xc[(e >> 24) & 255] +
        '-' +
        xc[255 & t] +
        xc[(t >> 8) & 255] +
        '-' +
        xc[((t >> 16) & 15) | 64] +
        xc[(t >> 24) & 255] +
        '-' +
        xc[(63 & i) | 128] +
        xc[(i >> 8) & 255] +
        '-' +
        xc[(i >> 16) & 255] +
        xc[(i >> 24) & 255] +
        xc[255 & n] +
        xc[(n >> 8) & 255] +
        xc[(n >> 16) & 255] +
        xc[(n >> 24) & 255]
      ).toLowerCase();
    }
    class Mc extends i {
      constructor(e) {
        super(e),
          (this.m_lineGeos = {}),
          (this.m_meshGeos = {}),
          (this.m_references = {}),
          (this.m_blocks = {}),
          (this.m_instances = {}),
          (this.m_lineGeoCount = 0),
          (this.m_meshGeoCount = 0),
          (this.isInsert = !1),
          (this.insertGroup = new vr()),
          (this.insertGeos = { lines: {}, meshs: {} }),
          (this.layerNameCounts = {}),
          (this.m_layers = {}),
          (this.m_model = this.m_context.SceneManager.ModelLayer),
          this.addInsertGroup();
      }
      getInstancesMatrix(e) {
        for (let t of Object.values(this.m_instances)) for (let i of t) if (i.id == e) return i;
        ''.charCodeAt(0);
      }
      get Group() {
        return this.m_references;
      }
      addInsertGroup() {
        (this.insertGroup = new vr()),
          (this.insertGroup.name = 'insertGroup'),
          (this.insertGroup.visible = !1),
          this.m_model.add(this.insertGroup);
      }
      traverse(e) {
        this.m_model.traverse(e), document.addEventListener;
      }
      getLayerIdsByNames(...e) {
        let t = [];
        for (let i in this.m_context.ModelManager.LayerTable) {
          let n = this.m_context.ModelManager.LayerTable[i];
          e.includes(n.Name) && t.push(i);
        }
        return t;
      }
      GetLayerByName(e) {
        for (let t in this.m_context.ModelManager.LayerTable) {
          let i = this.m_context.ModelManager.LayerTable[t];
          if (i.Name == e) return i;
        }
      }
      get LayerTable() {
        return this.m_layers;
      }
      get Layers() {
        let e = [];
        for (const t in this.m_layers) e.push(this.m_layers[t]);
        return e;
      }
      get Lines() {
        return this.m_lineGeos;
      }
      get Meshs() {
        return this.m_meshGeos;
      }
      get Model() {
        return this.m_model;
      }
      addlines(e, t) {
        for (const i in e) {
          let n = e[i],
            s = [];
          if (n) {
            n.forEach((e) => {
              let t = gc.clone(e);
              t.root_reference_id &&
                (this.m_references[t.root_reference_id] ||
                  (this.m_references[t.root_reference_id] = { key: i, lines: [], mesh: [] }),
                this.m_references[t.root_reference_id].lines.push(t)),
                s.push(t);
            });
            let e = i.split('_'),
              r = this.addLinesToModel(e[0], parseInt(e[1]), s);
            this.isInsert
              ? (this.insertGeos.lines[i]
                  ? this.insertGeos.lines[i].lines.push(...s)
                  : (this.insertGeos.lines[i] = { lines: s, model: r, canEdit: t }),
                (this.insertGeos.lines[i].model = r))
              : (this.m_lineGeos[i]
                  ? this.m_lineGeos[i].lines.push(...s)
                  : (this.m_lineGeos[i] = { lines: s, model: r, canEdit: t }),
                (this.m_lineGeos[i].model = r));
          }
        }
        this.m_context.ViewManager.Render();
      }
      addMeshs(e, t) {
        for (const i in e) {
          let n = e[i],
            s = [];
          n.forEach((e) => {
            let t = _c.clone(e);
            t.root_reference_id &&
              (this.m_references[t.root_reference_id] ||
                (this.m_references[t.root_reference_id] = { key: i, lines: [], mesh: [] }),
              this.m_references[t.root_reference_id].mesh.push(t)),
              s.push(t);
          });
          let r = i.split('_'),
            a = this.addMeshToModel(r[0], parseInt(r[1]), s);
          this.isInsert
            ? (this.insertGeos.meshs[i]
                ? this.insertGeos.meshs[i].meshs.push(...s)
                : (this.insertGeos.meshs[i] = { meshs: s, model: a, canEdit: t }),
              (this.insertGeos.meshs[i].model = a))
            : (this.m_meshGeos[i]
                ? this.m_meshGeos[i].meshs.push(...s)
                : (this.m_meshGeos[i] = { meshs: s, canEdit: t, model: a }),
              (this.m_meshGeos[i].model = a),
              delete e[i]);
        }
        this.m_context.ViewManager.Render();
      }
      addLayers(e) {
        e.forEach((e) => {
          this.m_layers[e.Id] || (this.m_layers[e.Id] = e);
        });
      }
      addInstances(e) {
        let t = Object.keys(this.m_instances);
        for (const i in e)
          if (t.includes(i))
            this.isInsert &&
              e[i].forEach((e) => {
                e.type = 'insert';
              }),
              this.m_instances[i].push(...e[i]);
          else {
            let t = e[i];
            this.m_instances[i] = t;
          }
      }
      setInstances(e, t) {
        let i = Object.keys(this.m_instances),
          n = [];
        if (i.length) {
          for (const e in this.m_instances) {
            let t = this.m_instances[e].map((e) => e.id);
            n.push(...t);
          }
          for (const i in this.m_instances)
            this.m_instances[i].forEach((i) => {
              if (n.includes(e))
                if ('insert' == i.type) {
                  (i.type = 'insertEnd'), (i.id = e);
                  let n = new ot();
                  n.setPosition(t), (i.matrix.elements = n.elements);
                } else
                  ('insertEnd' != i.type && '' != i.type) ||
                    (i.id == e &&
                      ((i.matrix.elements[12] = t.x), (i.matrix.elements[13] = t.y), (i.matrix.elements[14] = t.z)));
              else {
                n.push(e);
                let i = new ot();
                i.setPosition(t);
                let s = new vc({ id: e, layerId: '', blockId: '', matrix: i });
                (s.type = 'insertEnd'), (this.m_instances[yc()] = [s]);
              }
            });
        } else {
          let i = new ot();
          i.setPosition(t);
          let n = new vc({ id: e, layerId: '', blockId: '', matrix: i });
          (n.type = 'insertEnd'), (this.m_instances[yc()] = [n]);
        }
      }
      addBlocks(e) {
        for (const t in e) {
          let i = e[t];
          this.m_blocks[t] = i;
        }
      }
      addLayer(e) {
        this.m_layers[e.Id] = e;
      }
      addMeshToModel(e, t, i) {
        let n = this.m_context.MaterialManager.createMeshBasicMaterial(new ve(t));
        n.side = 2;
        let s = [];
        i.forEach((e) => {
          var t;
          null === (t = e.vertexs) ||
            void 0 === t ||
            t.forEach((e) => {
              s.push(e);
            });
        });
        let r = new ai(),
          a = new Float32Array(s);
        r.setAttribute('position', new Zt(a, 3));
        let o = new wi(r, n);
        return (
          (o.userData.layerId = e),
          (o.userData.originalMaterial = o.material),
          (o.renderOrder = -1),
          this.m_layers[e] && this.m_layers[e].Objects.push(o),
          this.isInsert ? this.insertGroup.add(o) : this.m_model.add(o),
          o
        );
      }
      getBlock(e) {
        return this.m_blocks[e];
      }
      getLinesGeometry(e) {
        let t = [],
          i = 0,
          n = [];
        return (
          e.forEach((e) => {
            var s;
            e.points.forEach((e) => {
              t.push(e);
            }),
              null === (s = e.indexes) ||
                void 0 === s ||
                s.forEach((e) => {
                  n.push(e + i);
                }),
              (i += e.points.length / 3);
          }),
          { index: n, position: t }
        );
      }
      addLinesToModel(e, t, i) {
        let n = this.m_context.MaterialManager.createLineMaterial(new ve(t)),
          s = new ai(),
          r = [],
          a = 0,
          o = [];
        i.forEach((e) => {
          var t;
          e.points.forEach((e) => {
            r.push(e);
          }),
            null === (t = e.indexes) ||
              void 0 === t ||
              t.forEach((e) => {
                o.push(e + a);
              }),
            (a += e.points.length / 3);
        });
        let l = new Float32Array(r);
        s.setAttribute('position', new Zt(l, 3)), s.setIndex(o);
        let h = new _a(s, n);
        return (
          (h.renderOrder = -this.m_meshGeoCount),
          (h.userData.layerId = e),
          (h.userData.originalMaterial = h.material),
          this.m_layers[e] && this.m_layers[e].Objects.push(h),
          this.isInsert ? this.insertGroup.add(h) : this.m_model.add(h),
          h
        );
      }
      OnComplete() {
        var e;
        for (let t in this.m_blocks) {
          let i = this.m_blocks[t];
          i.instances.length <= 0 ||
            (null === (e = null == i ? void 0 : i.instances) ||
              void 0 === e ||
              e.forEach((e) => {
                var t;
                null === (t = this.m_layers[e.layerId]) || void 0 === t || t.Color;
                let i = new ot();
                e.matrix.elements.forEach((e, t) => {
                  i.elements[t] = e;
                });
              }),
            i.instances.forEach((e) => {
              let t = new ot();
              e.matrix.elements.forEach((e, i) => {
                t.elements[i] = e;
              });
            }));
        }
      }
      GetBlocks() {
        return [];
      }
      GetDBEntityById(e) {
        for (let t in this.m_lineGeos) {
          let i = this.m_lineGeos[t];
          for (let t of i.lines) if ((t.id = e)) return t;
        }
        for (let t in this.m_meshGeos) {
          let i = this.m_meshGeos[t];
          for (let t of i.meshs) if ((t.id = e)) return t;
        }
      }
      GetInsertObject(e, t, i) {
        let n,
          s = !0;
        for (let r in this.m_lineGeos) {
          let a = this.m_lineGeos[r],
            o = r.split('_')[0];
          if (
            this.LayerTable[o].Visible &&
            this.LayerTable[o].Enabled &&
            (Qh(a.lines, e, t, (e) => ((n = e), (n.code = r), (s = i(n)), s)), n && !s)
          )
            return;
        }
        for (let t in this.m_meshGeos) {
          let r = this.m_meshGeos[t],
            a = t.split('_')[0];
          if (
            this.LayerTable[a].Visible &&
            this.LayerTable[a].Enabled &&
            ($h(r.meshs, e, 0, (e) => ((n = e), (n.code = t), (s = i(n)), s)), !s && n)
          )
            return;
        }
      }
      get Instances() {
        return this.m_instances;
      }
      DeleteLayerByIds(...e) {
        e.forEach((e) => {
          this.LayerTable[e].Objects.forEach((e) => {
            this.m_model.remove(e), ec(e);
          }),
            delete this.LayerTable[e];
          for (let t in this.m_meshGeos) {
            e == t.split('_')[0] && delete this.m_meshGeos[t];
          }
          for (let t in this.m_lineGeos) {
            e == t.split('_')[0] && delete this.m_lineGeos[t];
          }
          for (let t in this.m_blocks) {
            let i = this.m_blocks[t];
            for (let t in i.lines) {
              e == t.split('_')[0] && delete i.lines[t];
            }
            for (let t in i.meshs) {
              e == t.split('_')[0] && delete i.meshs[t];
            }
            for (let t = 0; t < i.instances.length; t++) i.instances[t].layerId == e && i.instances.splice(t, 1);
          }
        }),
          this.m_context.SelectionManager.m_selection.clear();
      }
      DeleteEntity(...e) {
        let t = { lines: [], mesh: [] };
        e.forEach((e) => {
          if (e.root_reference_id) {
            let i = this.m_references[e.root_reference_id];
            i &&
              (i.lines.forEach((e) => {
                t.lines.push(e);
              }),
              i.mesh.forEach((e) => {
                t.mesh.push(e);
              }));
          } else e instanceof gc && t.lines.push(e), e instanceof _c && t.mesh.push(e);
        });
        let i = new Set();
        t.lines.forEach((e) => {
          let t, n;
          for (let s in this.m_lineGeos) {
            let r = this.m_lineGeos[s],
              a = s.split('_')[0];
            r.canEdit &&
              e.layerId == a &&
              this.m_lineGeos[s].lines.indexOf(e) > -1 &&
              (r.lines.splice(this.m_lineGeos[s].lines.indexOf(e), 1), (t = s.split('_')[1]), (n = s), i.add(n));
          }
        }),
          i.forEach((e) => {
            this.m_lineGeos[e];
            let t = this.m_lineGeos[e].lines,
              i = this.m_lineGeos[e].model;
            if (0 == t.length) {
              let t = this.LayerTable[e.split('_')[0]];
              if (t) {
                let e = t.Objects.indexOf(i);
                e > 0 && t.Objects.splice(e, 1);
              }
              this.m_model.remove(i), i.geometry.dispose(), delete this.m_lineGeos[e];
            } else {
              let e = this.getLinesGeometry(t);
              i.geometry.setAttribute('position', new Zt(new Float32Array(e.position), 3)),
                i.geometry.setIndex(e.index);
            }
          }),
          i.clear(),
          t.mesh.forEach((e) => {
            let t, n, s;
            for (let r in this.m_meshGeos) {
              let a = r.split('_')[0];
              (t = this.m_meshGeos[r]),
                t.canEdit &&
                  e.layerId == a &&
                  t.meshs.indexOf(e) > -1 &&
                  (t.meshs.splice(this.m_meshGeos[r].meshs.indexOf(e), 1), (n = r.split('_')[1]), (s = r), i.add(s));
            }
          }),
          i.forEach((e) => {
            if (!this.m_meshGeos[e].canEdit) return;
            let t = this.m_meshGeos[e].meshs,
              i = this.m_meshGeos[e].model;
            if (0 == t.length) {
              let t = this.LayerTable[e.split('_')[0]];
              if (t) {
                let e = t.Objects.indexOf(i);
                e > 0 && t.Objects.splice(e, 1);
              }
              this.m_model.remove(i), i.geometry.dispose(), delete this.m_meshGeos[e];
            } else {
              let e = [];
              t.forEach((t) => {
                var i;
                null === (i = t.vertexs) ||
                  void 0 === i ||
                  i.forEach((t) => {
                    e.push(t);
                  });
              }),
                i.geometry.setAttribute('position', new Zt(new Float32Array(e), 3));
            }
          }),
          this.m_context.ViewManager.Render();
      }
      computeArrItemCount(e) {
        return e.reduce((e, t) => (t in e ? e[t]++ : (e[t] = 1), e), {});
      }
      AddCustomLines(e, t) {
        let i = this.Layers.map((e) => e.Name);
        this.layerNameCounts = this.computeArrItemCount(i);
        let n = 0;
        if (!i.includes(e)) throw new Error('layName');
        this.Layers.forEach((i) => {
          var s, r;
          if (i.Name === e && n < 1) {
            this.layerNameCounts[e] > 1 && n++;
            let a = `${i.Id}_${i.Color}`,
              o =
                null !== (r = null === (s = this.m_lineGeos[a]) || void 0 === s ? void 0 : s.lines) && void 0 !== r
                  ? r
                  : [],
              l = [],
              h = 0,
              c = [];
            t.forEach((e) => {
              l.push(e.x, e.y, e.z), c.push(h), 0 != h && h != t.length - 1 && c.push(h), h++;
            });
            let u = new gc({
                id: yc(),
                layerId: i.Id,
                blockId: '',
                points: new Float32Array(l),
                indexes: new Int32Array(c),
              }),
              d = new $e(),
              m = new Re();
            m.setFromArray(u.points),
              m.getBoundingSphere(d),
              (u.sphere = d),
              (u.box = m),
              o.push(u),
              i.Color &&
                (this.m_lineGeos[a]
                  ? ((this.m_lineGeos[a].canEdit = !0),
                    (this.m_lineGeos[a].lines = o),
                    (this.m_lineGeos[a].model = this.addLinesToModel(i.Id, i.Color, o)))
                  : (this.m_lineGeos[a] = { canEdit: !0, lines: o, model: this.addLinesToModel(i.Id, i.Color, o) }));
          }
        });
      }
      CreateCircle(e, t) {
        let i = t.list,
          n = t.radius;
        for (let t = 0; t < i.length; t++) {
          let s = [];
          for (let e = 0; e <= 36; e++) {
            let r = new Pe(
              i[t].x + n * Math.cos(((2 * Math.PI) / 36) * e),
              i[t].y + n * Math.sin(((2 * Math.PI) / 36) * e),
              0,
            );
            s.push(r);
          }
          this.AddCustomLines(e, s);
          let r = 0;
          this.Layers.forEach((n) => {
            var s, a;
            if (n.Name === e && r < 1) {
              this.layerNameCounts[e] > 1 && r++;
              let o = `${n.Id}_${n.Color}`,
                l =
                  null !== (a = null === (s = this.m_lineGeos[o]) || void 0 === s ? void 0 : s.lines) && void 0 !== a
                    ? a
                    : [];
              if (((l[l.length - 1].block_path = yc()), t !== i.length - 1)) {
                let e = this.m_layers[n.Id].Objects.pop();
                this.m_model.remove(e);
              }
            }
          });
        }
      }
      get Box() {
        let e = new Re();
        return e.setFromObject(this.m_model), e;
      }
      Clear() {
        (this.m_layers = {}),
          (this.m_lineGeos = {}),
          (this.m_meshGeos = {}),
          (this.m_instances = {}),
          (this.m_blocks = {}),
          (this.m_lineGeoCount = 0),
          (this.m_meshGeoCount = 0),
          this.m_model.clear(),
          this.m_context.SceneManager.MaskLayer.clear(),
          this.m_context.ViewManager.Render();
      }
    }
    class bc extends i {
      constructor(e) {
        super(e), (this.items = {}), (this.items = {});
      }
      has(e) {
        return this.items.hasOwnProperty(e);
      }
      set(e, t) {
        this.items[e] = t;
      }
      delete(e) {
        return this.has(e) && delete this.items[e], !1;
      }
      get(e) {
        return this.items[e];
      }
      values() {
        let e = [];
        for (let t in this.items) this.has(t) && e.push(this.items[t]);
        return e;
      }
      createLineMaterial(e, t) {
        let i = e.getHexString();
        return this.items[i] || (this.items[i] = new la({ color: e, side: 2 })), this.items[i];
      }
      createMeshBasicMaterial(e) {
        let t = e.getHexString();
        return this.items[t] || (this.items[t] = new Xt({ color: e, side: 2 })), this.items[t];
      }
    }
    class Sc extends It {
      constructor(e, t = new ve(4442068)) {
        super(),
          (this.m_hightColor = new ve(4906476)),
          (this.m_meshs = []),
          (this.m_lines = []),
          (this.m_instances = []),
          (this.m_threeObjects = []),
          (this.m_hightColor = t),
          (this.m_hightMaterial = new la({ color: this.m_hightColor, transparent: !0 })),
          (this.m_hightMeshMaterial = new Xt({ color: this.m_hightColor, side: 2, transparent: !0 })),
          (this.m_context = e),
          this.m_context.SceneManager.AuxModel.add(this);
      }
      setColor(e, t) {
        (this.m_hightMaterial.color = new ve(e)),
          (this.m_hightMeshMaterial.color = new ve(e)),
          (this.m_hightMaterial.opacity = t),
          (this.m_hightMeshMaterial.opacity = t);
      }
      addObjects(...e) {
        var t, i;
        let n = {};
        e.forEach((e) => {
          let t = this.addObject(e);
          t &&
            t.root_reference_id &&
            (n[t.root_reference_id] = t instanceof gc ? 1 | n[t.root_reference_id] : 16 | n[t.root_reference_id]);
        });
        for (let e of Object.entries(n)) {
          let n = this.m_context.ModelManager.Group[e[0]];
          {
            let e = new ai(),
              i = [],
              s = 0,
              r = [];
            n &&
              (null === (t = n.lines) ||
                void 0 === t ||
                t.forEach((e) => {
                  var t;
                  e.points.forEach((e) => {
                    i.push(e);
                  }),
                    null === (t = e.indexes) ||
                      void 0 === t ||
                      t.forEach((e) => {
                        r.push(e + s);
                      }),
                    (s += e.points.length / 3);
                }));
            let a = new Float32Array(i);
            e.setAttribute('position', new Zt(a, 3)), e.setIndex(r);
            let o = new _a(e, this.m_hightMaterial);
            this.add(o);
          }
          {
            let e = [];
            n &&
              (null === (i = n.mesh) ||
                void 0 === i ||
                i.forEach((t) => {
                  var i;
                  null === (i = t.vertexs) ||
                    void 0 === i ||
                    i.forEach((t) => {
                      e.push(t);
                    });
                }));
            let t = new ai(),
              s = new Float32Array(e);
            t.setAttribute('position', new Zt(s, 3));
            let r = new wi(t, this.m_hightMeshMaterial);
            this.add(r);
          }
        }
      }
      addObject(e) {
        if (e instanceof gc) {
          if ((this.m_lines.push(e), e.root_reference_id)) return e;
          let t = new ai();
          t.setAttribute('position', new Zt(e.points, 3)), t.setIndex(new Kt(e.indexes, 1));
          let i = new _a(t, this.m_hightMaterial);
          (i.renderOrder = 10), (i.userData.obj = e), this.add(i);
        }
        if (e instanceof _c) {
          if ((this.m_meshs.push(e), e.root_reference_id)) return e;
          let t = new ai(),
            i = [];
          for (let t = 0; t < e.vertexs.length; t++) {
            const n = e.vertexs.at(t);
            null != n && i.push(n);
          }
          t.setAttribute('position', new $t(i, 3));
          let n = new wi(t, this.m_hightMeshMaterial);
          (n.renderOrder = 10), (n.position.x = 0), (n.userData.obj = e), this.add(n);
        }
        if (e instanceof vc) {
          this.m_instances.push(e);
          let t = e.blockRecord,
            i = new ai(),
            n = [],
            s = 0,
            r = [];
          t.lines.array.forEach((e) => {
            var t;
            n.push(...(e.points || [])),
              null === (t = e.indexes) ||
                void 0 === t ||
                t.forEach((e) => {
                  r.push(e + s);
                }),
              (s += e.points.length / 3);
          }),
            i.setAttribute('position', new Zt(new Float32Array(n), 3)),
            i.setIndex(r);
          let a = new _a(i, this.m_hightMaterial);
          a.matrix.copy(e.matrix),
            (a.userData.obj = e),
            this.add(a),
            (n.length = 0),
            t.meshs.array.forEach((e) => {
              var t;
              null === (t = e.vertexs) ||
                void 0 === t ||
                t.forEach((e) => {
                  n.push(e);
                });
            });
          let o = new ai();
          o.setAttribute('position', new Zt(new Float32Array(n), 3));
          let l = new wi(o, this.m_hightMeshMaterial);
          this.add(l);
        }
        if (e instanceof It) {
          this.m_threeObjects.push(e);
          let t,
            i = new ai();
          if (
            (e instanceof wi &&
              (i.copy(e.geometry), (t = new wi(i, this.m_hightMeshMaterial)), (t.userData.obj = e), this.add(t)),
            e instanceof Hr)
          ) {
            let t = new Il(e, this.m_hightColor);
            (t.userData.obj = e), this.add(t);
          }
        }
      }
      getObjects() {
        let e = [];
        return (
          this.m_lines.forEach((t) => {
            e.push(t);
          }),
          this.m_meshs.forEach((t) => {
            e.push(t);
          }),
          this.m_instances.forEach((t) => {
            e.push(t);
          }),
          this.m_threeObjects.forEach((t) => {
            e.push(t);
          }),
          e
        );
      }
      clear() {
        return (
          (this.m_lines.length = 0),
          (this.m_meshs.length = 0),
          (this.m_threeObjects.length = 0),
          (this.m_instances.length = 0),
          super.clear(),
          this.children.forEach((e) => {
            e.geometry.dispose(), e.geometry.dispose();
          }),
          this
        );
      }
      Remove(e) {
        for (let t = 0; t < this.children.length; t++)
          if (this.children[t].userData.obj == e) return this.children.splice(t, 1), !0;
        return !1;
      }
      clearObj(e) {
        let t;
        if (e instanceof gc) {
          if (((t = e.points), e.root_reference_id)) {
            let i = [],
              n = [];
            this.m_context.ModelManager.Group[e.root_reference_id].lines.forEach((e) => {
              i.push(...e.points);
            }),
              this.m_context.ModelManager.Group[e.root_reference_id].mesh.forEach((e) => {
                n.push(...e.vertexs);
              }),
              (t = [i, n]);
          }
          let i = this.m_lines.indexOf(e);
          i > -1 && this.m_lines.splice(i, 1);
        }
        if (e instanceof _c) {
          if (((t = e.vertexs), e.root_reference_id)) {
            let i = [],
              n = [];
            this.m_context.ModelManager.Group[e.root_reference_id].lines.forEach((e) => {
              i.push(...e.points);
            }),
              this.m_context.ModelManager.Group[e.root_reference_id].mesh.forEach((e) => {
                n.push(...e.vertexs);
              }),
              (t = [i, n]);
          }
          let i = this.m_meshs.indexOf(e);
          i > -1 && this.m_meshs.splice(i, 1);
        }
        if (e instanceof It && this.m_threeObjects.length > 0) {
          let i;
          (i = this.m_threeObjects.indexOf(e)),
            (t = e.geometry.attributes.position.array),
            i > -1 && this.m_threeObjects.splice(i, 1);
        }
        for (let i = 0; i < this.children.length; i++)
          if (
            this.children[i] instanceof wi ||
            this.children[i] instanceof pa ||
            this.children[i] instanceof _a ||
            this.children[i] instanceof Hr
          ) {
            let n = this.children[i].geometry.attributes.position.array.toString(),
              s = '';
            if (e instanceof gc || e instanceof _c) {
              if (e.root_reference_id) {
                if (Array.isArray(t))
                  for (let e = 0; e < t.length; e++)
                    if (
                      ((s = t[e].toString()),
                      n == s && (this.children.splice(i, 1), t.splice(e, 1), e--, i--, !t.length))
                    )
                      return !0;
              } else if (((s = null == t ? void 0 : t.toString()), n == s)) return this.children.splice(i, 1), !0;
            } else if (((s = null == t ? void 0 : t.toString()), n == s)) return this.children.splice(i, 1), !0;
          }
        return !1;
      }
    }
    class wc {
      constructor(e, t, i) {
        (this.buttonNum = 0),
          (this.parentElement = t),
          (this.element = document.createElement('div')),
          this.element.classList.add(i),
          (this.element.style.pointerEvents = 'none'),
          (this.eventManager = e),
          (this.startPoint = new se()),
          (this.pointTopLeft = new se()),
          (this.pointBottomRight = new se()),
          (this.isDown = !1),
          (this.onPointerDownBind = this.onPointerDown.bind(this)),
          (this.onPointerMoveBind = this.onPointerMove.bind(this)),
          (this.onPointerUpBind = this.onPointerUp.bind(this)),
          this.eventManager.addEventListener('pointerdown', this.onPointerDownBind),
          this.eventManager.addEventListener('pointermove', this.onPointerMoveBind),
          this.eventManager.addEventListener('pointerup', this.onPointerUpBind);
      }
      onPointerMove(e) {
        0 == this.buttonNum && this.isDown && this.onSelectMove(e);
      }
      onPointerDown(e) {
        (this.buttonNum = e.button), (this.isDown = !0), this.onSelectStart(e);
      }
      onPointerUp(e) {
        (this.isDown = !1), this.onSelectOver();
      }
      dispose() {
        this.eventManager.removeEventListener('pointerdown', this.onPointerDownBind),
          this.eventManager.removeEventListener('pointermove', this.onPointerMoveBind),
          this.eventManager.removeEventListener('pointerup', this.onPointerUpBind),
          this.onSelectOver();
      }
      onSelectStart(e) {
        (this.element.style.display = 'none'),
          this.parentElement.appendChild(this.element),
          (this.element.style.left = e.clientX + 'px'),
          (this.element.style.top = e.clientY + 'px'),
          (this.element.style.width = '0px'),
          (this.element.style.height = '0px'),
          (this.startPoint.x = e.clientX),
          (this.startPoint.y = e.clientY);
      }
      onSelectMove(e) {
        (this.element.style.display = 'block'),
          (this.pointBottomRight.x = Math.max(this.startPoint.x, e.clientX)),
          (this.pointBottomRight.y = Math.max(this.startPoint.y, e.clientY)),
          (this.pointTopLeft.x = Math.min(this.startPoint.x, e.clientX)),
          (this.pointTopLeft.y = Math.min(this.startPoint.y, e.clientY)),
          (this.element.style.left = this.pointTopLeft.x + 'px'),
          (this.element.style.top = this.pointTopLeft.y + 'px'),
          (this.element.style.width = this.pointBottomRight.x - this.pointTopLeft.x + 'px'),
          (this.element.style.height = this.pointBottomRight.y - this.pointTopLeft.y + 'px');
      }
      onSelectOver() {
        this.parentElement.removeChild(this.element);
      }
    }
    class Ac {
      static max(e, t) {
        let i, n;
        return e.length > 0
          ? (e.forEach((e) => {
              let s = t(e);
              i ? s > n && ((i = e), (n = s)) : ((i = e), (n = s));
            }),
            i)
          : void 0;
      }
      static min(e, t) {
        let i, n;
        if (e.length > 0) {
          for (let s = 0; s < e.length; s++) {
            if (e[s] instanceof Jh) {
              if (e[s].obejct[0] instanceof _c && e.length > 1) continue;
            }
            let r = t(e[s]);
            i ? r < n && ((i = e[s]), (n = r)) : ((i = e[s]), (n = r));
          }
          return i;
        }
      }
      static angleTo(e, t, i) {
        let n = e.angleTo(t);
        return e.clone().applyAxisAngle(i, n).angleTo(t) < 1e-6 ? n : 2 * Math.PI - n;
      }
    }
    class Tc {
      constructor(e) {
        (this.map = new Map()),
          (this.m_renderOrder = 15),
          (this.m_size = { x: 1, y: 1, z: 1 }),
          (this.material = new la({ color: 16711680 })),
          (this.triangular = this.createTriangular(this.material)),
          (this.square = this.createSquare(this.material)),
          (this.cross = this.createCross(this.material)),
          (this.insert = this.createInsert(this.material)),
          (this.turn = this.createTurn(this.material)),
          e.add(this.triangular),
          e.add(this.square),
          e.add(this.cross),
          e.add(this.insert),
          e.add(this.turn),
          this.map.set(Ec.center, this.triangular),
          this.map.set(Ec.cross, this.cross),
          this.map.set(Ec.end, this.square),
          this.map.set(Ec.insert, this.insert),
          this.map.set(Ec.vertical, this.turn);
      }
      createTriangular(e) {
        return this.createLine([-8.6481, -5.0209, 0, 0, 10, 0, 8.6603, -5, 0], [0, 1, 1, 2, 2, 0], e);
      }
      createSquare(e) {
        return this.createLine(
          [-7.071, -7.071, 0, -7.071, 7.071, 0, 7.071, 7.071, 0, 7.071, -7.071, 0],
          [0, 1, 1, 2, 2, 3, 3, 0],
          e,
        );
      }
      createCross(e) {
        let t = [];
        return (
          t.push(-7.071, -7.071, 0, 7.071, 7.071, 0),
          t.push(-7.071, 7.071, 0, 7.071, -7.071, 0),
          this.createLine(t, void 0, e)
        );
      }
      createInsert(e) {
        let t = [];
        return (
          t.push(-7.071, -7.071, 0, 7.071, 7.071, 0),
          t.push(-7.071, 7.071, 0, 7.071, -7.071, 0),
          t.push(-7.071, 7.071, 0, 7.071, 7.071, 0),
          t.push(-7.071, -7.071, 0, 7.071, -7.071, 0),
          this.createLine(t, void 0, e)
        );
      }
      createTurn(e) {
        let t = [];
        return (
          t.push(-7.071, 7.071, 0, -7.071, -7.071, 0),
          t.push(-7.071, -7.071, 0, 7.071, -7.071, 0),
          t.push(5, 0, 0, -7.071, 0, 0),
          t.push(0, 5, 0, 0, -7.071, 0),
          this.createLine(t, void 0, e)
        );
      }
      createLine(e, t, i) {
        let n = new ai();
        n.setAttribute('position', new Zt(new Float32Array(e), 3)), t && n.setIndex(t);
        let s = new _a(n, i);
        return (s.renderOrder = 15), (s.userData.scale = this.m_size), (s.visible = !1), s;
      }
      set(e, t, i) {
        this.map.forEach((n, s) => {
          e == s
            ? (n.position.copy(t),
              (n.visible = !0),
              n.scale.set(i * n.userData.scale.x, i * n.userData.scale.y, i * n.userData.scale.z))
            : (n.visible = !1);
        });
      }
    }
    var Ec;
    !(function (e) {
      (e[(e.none = 0)] = 'none'),
        (e[(e.center = 1)] = 'center'),
        (e[(e.end = 2)] = 'end'),
        (e[(e.insert = 3)] = 'insert'),
        (e[(e.cross = 4)] = 'cross'),
        (e[(e.vertical = 5)] = 'vertical'),
        (e[(e.other = 6)] = 'other');
    })(Ec || (Ec = {}));
    const Lc = new Re(),
      Cc = new Pe();
    class Pc extends fl {
      constructor() {
        super(), (this.isLineSegmentsGeometry = !0), (this.type = 'LineSegmentsGeometry');
        this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]),
          this.setAttribute(
            'position',
            new $t([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3),
          ),
          this.setAttribute('uv', new $t([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2));
      }
      applyMatrix4(e) {
        const t = this.attributes.instanceStart,
          i = this.attributes.instanceEnd;
        return (
          void 0 !== t && (t.applyMatrix4(e), i.applyMatrix4(e), (t.needsUpdate = !0)),
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          this
        );
      }
      setPositions(e) {
        let t;
        e instanceof Float32Array ? (t = e) : Array.isArray(e) && (t = new Float32Array(e));
        const i = new wl(t, 6, 1);
        return (
          this.setAttribute('instanceStart', new Lr(i, 3, 0)),
          this.setAttribute('instanceEnd', new Lr(i, 3, 3)),
          this.computeBoundingBox(),
          this.computeBoundingSphere(),
          this
        );
      }
      setColors(e) {
        let t;
        e instanceof Float32Array ? (t = e) : Array.isArray(e) && (t = new Float32Array(e));
        const i = new wl(t, 6, 1);
        return (
          this.setAttribute('instanceColorStart', new Lr(i, 3, 0)),
          this.setAttribute('instanceColorEnd', new Lr(i, 3, 3)),
          this
        );
      }
      fromWireframeGeometry(e) {
        return this.setPositions(e.attributes.position.array), this;
      }
      fromEdgesGeometry(e) {
        return this.setPositions(e.attributes.position.array), this;
      }
      fromMesh(e) {
        return this.fromWireframeGeometry(new wo(e.geometry)), this;
      }
      fromLineSegments(e) {
        const t = e.geometry;
        return this.setPositions(t.attributes.position.array), this;
      }
      computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new Re());
        const e = this.attributes.instanceStart,
          t = this.attributes.instanceEnd;
        void 0 !== e &&
          void 0 !== t &&
          (this.boundingBox.setFromBufferAttribute(e), Lc.setFromBufferAttribute(t), this.boundingBox.union(Lc));
      }
      computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new $e()),
          null === this.boundingBox && this.computeBoundingBox();
        const e = this.attributes.instanceStart,
          t = this.attributes.instanceEnd;
        if (void 0 !== e && void 0 !== t) {
          const i = this.boundingSphere.center;
          this.boundingBox.getCenter(i);
          let n = 0;
          for (let s = 0, r = e.count; s < r; s++)
            Cc.fromBufferAttribute(e, s),
              (n = Math.max(n, i.distanceToSquared(Cc))),
              Cc.fromBufferAttribute(t, s),
              (n = Math.max(n, i.distanceToSquared(Cc)));
          (this.boundingSphere.radius = Math.sqrt(n)), isNaN(this.boundingSphere.radius);
        }
      }
      toJSON() {}
      applyMatrix(e) {
        return this.applyMatrix4(e);
      }
    }
    (Yi.line = {
      worldUnits: { value: 1 },
      linewidth: { value: 1 },
      resolution: { value: new se(1, 1) },
      dashOffset: { value: 0 },
      dashScale: { value: 1 },
      dashSize: { value: 1 },
      gapSize: { value: 1 },
    }),
      (Zi.line = {
        uniforms: Ci.merge([Yi.common, Yi.fog, Yi.line]),
        vertexShader:
          "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",
        fragmentShader:
          '\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t',
      });
    class Dc extends Pi {
      constructor(e) {
        super({
          type: 'LineMaterial',
          uniforms: Ci.clone(Zi.line.uniforms),
          vertexShader: Zi.line.vertexShader,
          fragmentShader: Zi.line.fragmentShader,
          clipping: !0,
        }),
          (this.isLineMaterial = !0),
          Object.defineProperties(this, {
            color: {
              enumerable: !0,
              get: function () {
                return this.uniforms.diffuse.value;
              },
              set: function (e) {
                this.uniforms.diffuse.value = e;
              },
            },
            worldUnits: {
              enumerable: !0,
              get: function () {
                return 'WORLD_UNITS' in this.defines;
              },
              set: function (e) {
                !0 === e ? (this.defines.WORLD_UNITS = '') : delete this.defines.WORLD_UNITS;
              },
            },
            linewidth: {
              enumerable: !0,
              get: function () {
                return this.uniforms.linewidth.value;
              },
              set: function (e) {
                this.uniforms.linewidth.value = e;
              },
            },
            dashed: {
              enumerable: !0,
              get: function () {
                return Boolean('USE_DASH' in this.defines);
              },
              set(e) {
                Boolean(e) !== Boolean('USE_DASH' in this.defines) && (this.needsUpdate = !0),
                  !0 === e ? (this.defines.USE_DASH = '') : delete this.defines.USE_DASH;
              },
            },
            dashScale: {
              enumerable: !0,
              get: function () {
                return this.uniforms.dashScale.value;
              },
              set: function (e) {
                this.uniforms.dashScale.value = e;
              },
            },
            dashSize: {
              enumerable: !0,
              get: function () {
                return this.uniforms.dashSize.value;
              },
              set: function (e) {
                this.uniforms.dashSize.value = e;
              },
            },
            dashOffset: {
              enumerable: !0,
              get: function () {
                return this.uniforms.dashOffset.value;
              },
              set: function (e) {
                this.uniforms.dashOffset.value = e;
              },
            },
            gapSize: {
              enumerable: !0,
              get: function () {
                return this.uniforms.gapSize.value;
              },
              set: function (e) {
                this.uniforms.gapSize.value = e;
              },
            },
            opacity: {
              enumerable: !0,
              get: function () {
                return this.uniforms.opacity.value;
              },
              set: function (e) {
                this.uniforms.opacity.value = e;
              },
            },
            resolution: {
              enumerable: !0,
              get: function () {
                return this.uniforms.resolution.value;
              },
              set: function (e) {
                this.uniforms.resolution.value.copy(e);
              },
            },
            alphaToCoverage: {
              enumerable: !0,
              get: function () {
                return Boolean('USE_ALPHA_TO_COVERAGE' in this.defines);
              },
              set: function (e) {
                Boolean(e) !== Boolean('USE_ALPHA_TO_COVERAGE' in this.defines) && (this.needsUpdate = !0),
                  !0 === e
                    ? ((this.defines.USE_ALPHA_TO_COVERAGE = ''), (this.extensions.derivatives = !0))
                    : (delete this.defines.USE_ALPHA_TO_COVERAGE, (this.extensions.derivatives = !1));
              },
            },
          }),
          this.setValues(e);
      }
    }
    const Ic = new Pe(),
      Rc = new Pe(),
      Oc = new Ae(),
      Nc = new Ae(),
      zc = new Ae(),
      Fc = new Pe(),
      kc = new ot(),
      Uc = new Pl(),
      Bc = new Pe(),
      Gc = new Re(),
      Vc = new $e(),
      Hc = new Ae();
    let jc, Wc, Xc, qc;
    function Yc(e, t, i) {
      return (
        Hc.set(0, 0, -t, 1).applyMatrix4(e.projectionMatrix),
        Hc.multiplyScalar(1 / Hc.w),
        (Hc.x = qc / i.width),
        (Hc.y = qc / i.height),
        Hc.applyMatrix4(e.projectionMatrixInverse),
        Hc.multiplyScalar(1 / Hc.w),
        Math.abs(Math.max(Hc.x, Hc.y))
      );
    }
    class Zc extends wi {
      constructor(e = new Pc(), t = new Dc({ color: 16777215 * Math.random() })) {
        super(e, t), (this.isLineSegments2 = !0), (this.type = 'LineSegments2');
      }
      computeLineDistances() {
        const e = this.geometry,
          t = e.attributes.instanceStart,
          i = e.attributes.instanceEnd,
          n = new Float32Array(2 * t.count);
        for (let e = 0, s = 0, r = t.count; e < r; e++, s += 2)
          Ic.fromBufferAttribute(t, e),
            Rc.fromBufferAttribute(i, e),
            (n[s] = 0 === s ? 0 : n[s - 1]),
            (n[s + 1] = n[s] + Ic.distanceTo(Rc));
        const s = new wl(n, 2, 1);
        return (
          e.setAttribute('instanceDistanceStart', new Lr(s, 1, 0)),
          e.setAttribute('instanceDistanceEnd', new Lr(s, 1, 1)),
          this
        );
      }
      raycast(e, t) {
        const i = this.material.worldUnits,
          n = e.camera,
          s = (void 0 !== e.params.Line2 && e.params.Line2.threshold) || 0;
        jc = e.ray;
        const r = this.matrixWorld,
          a = this.geometry,
          o = this.material;
        let l, h;
        if (
          ((qc = o.linewidth + s),
          (Wc = a.attributes.instanceStart),
          (Xc = a.attributes.instanceEnd),
          null === a.boundingSphere && a.computeBoundingSphere(),
          Vc.copy(a.boundingSphere).applyMatrix4(r),
          i)
        )
          l = 0.5 * qc;
        else {
          l = Yc(n, Math.max(n.near, Vc.distanceToPoint(jc.origin)), o.resolution);
        }
        if (((Vc.radius += l), !1 !== jc.intersectsSphere(Vc))) {
          if ((null === a.boundingBox && a.computeBoundingBox(), Gc.copy(a.boundingBox).applyMatrix4(r), i))
            h = 0.5 * qc;
          else {
            h = Yc(n, Math.max(n.near, Gc.distanceToPoint(jc.origin)), o.resolution);
          }
          Gc.expandByScalar(h),
            !1 !== jc.intersectsBox(Gc) &&
              (i
                ? (function (e, t) {
                    for (let i = 0, n = Wc.count; i < n; i++) {
                      Uc.start.fromBufferAttribute(Wc, i), Uc.end.fromBufferAttribute(Xc, i);
                      const n = new Pe(),
                        s = new Pe();
                      jc.distanceSqToSegment(Uc.start, Uc.end, s, n),
                        s.distanceTo(n) < 0.5 * qc &&
                          t.push({
                            point: s,
                            pointOnLine: n,
                            distance: jc.origin.distanceTo(s),
                            object: e,
                            face: null,
                            faceIndex: i,
                            uv: null,
                            uv2: null,
                          });
                    }
                  })(this, t)
                : (function (e, t, i) {
                    const n = t.projectionMatrix,
                      s = e.material.resolution,
                      r = e.matrixWorld,
                      a = e.geometry,
                      o = a.attributes.instanceStart,
                      l = a.attributes.instanceEnd,
                      h = -t.near;
                    jc.at(1, zc),
                      (zc.w = 1),
                      zc.applyMatrix4(t.matrixWorldInverse),
                      zc.applyMatrix4(n),
                      zc.multiplyScalar(1 / zc.w),
                      (zc.x *= s.x / 2),
                      (zc.y *= s.y / 2),
                      (zc.z = 0),
                      Fc.copy(zc),
                      kc.multiplyMatrices(t.matrixWorldInverse, r);
                    for (let t = 0, a = o.count; t < a; t++) {
                      if (
                        (Oc.fromBufferAttribute(o, t),
                        Nc.fromBufferAttribute(l, t),
                        (Oc.w = 1),
                        (Nc.w = 1),
                        Oc.applyMatrix4(kc),
                        Nc.applyMatrix4(kc),
                        Oc.z > h && Nc.z > h)
                      )
                        continue;
                      if (Oc.z > h) {
                        const e = Oc.z - Nc.z,
                          t = (Oc.z - h) / e;
                        Oc.lerp(Nc, t);
                      } else if (Nc.z > h) {
                        const e = Nc.z - Oc.z,
                          t = (Nc.z - h) / e;
                        Nc.lerp(Oc, t);
                      }
                      Oc.applyMatrix4(n),
                        Nc.applyMatrix4(n),
                        Oc.multiplyScalar(1 / Oc.w),
                        Nc.multiplyScalar(1 / Nc.w),
                        (Oc.x *= s.x / 2),
                        (Oc.y *= s.y / 2),
                        (Nc.x *= s.x / 2),
                        (Nc.y *= s.y / 2),
                        Uc.start.copy(Oc),
                        (Uc.start.z = 0),
                        Uc.end.copy(Nc),
                        (Uc.end.z = 0);
                      const a = Uc.closestPointToPointParameter(Fc, !0);
                      Uc.at(a, Bc);
                      const c = ne.lerp(Oc.z, Nc.z, a),
                        u = c >= -1 && c <= 1,
                        d = Fc.distanceTo(Bc) < 0.5 * qc;
                      if (u && d) {
                        Uc.start.fromBufferAttribute(o, t),
                          Uc.end.fromBufferAttribute(l, t),
                          Uc.start.applyMatrix4(r),
                          Uc.end.applyMatrix4(r);
                        const n = new Pe(),
                          s = new Pe();
                        jc.distanceSqToSegment(Uc.start, Uc.end, s, n),
                          i.push({
                            point: s,
                            pointOnLine: n,
                            distance: jc.origin.distanceTo(s),
                            object: e,
                            face: null,
                            faceIndex: t,
                            uv: null,
                            uv2: null,
                          });
                      }
                    }
                  })(this, n, t));
        }
      }
    }
    class Jc extends Pc {
      constructor() {
        super(), (this.isLineGeometry = !0), (this.type = 'LineGeometry');
      }
      setPositions(e) {
        const t = e.length - 3,
          i = new Float32Array(2 * t);
        for (let n = 0; n < t; n += 3)
          (i[2 * n] = e[n]),
            (i[2 * n + 1] = e[n + 1]),
            (i[2 * n + 2] = e[n + 2]),
            (i[2 * n + 3] = e[n + 3]),
            (i[2 * n + 4] = e[n + 4]),
            (i[2 * n + 5] = e[n + 5]);
        return super.setPositions(i), this;
      }
      setColors(e) {
        const t = e.length - 3,
          i = new Float32Array(2 * t);
        for (let n = 0; n < t; n += 3)
          (i[2 * n] = e[n]),
            (i[2 * n + 1] = e[n + 1]),
            (i[2 * n + 2] = e[n + 2]),
            (i[2 * n + 3] = e[n + 3]),
            (i[2 * n + 4] = e[n + 4]),
            (i[2 * n + 5] = e[n + 5]);
        return super.setColors(i), this;
      }
      fromLine(e) {
        const t = e.geometry;
        return this.setPositions(t.attributes.position.array), this;
      }
    }
    class Kc extends Zc {
      constructor(e = new Jc(), t = new Dc({ color: 16777215 * Math.random() })) {
        super(e, t), (this.isLine2 = !0), (this.type = 'Line2');
      }
    }
    class $c {
      constructor(e) {
        (this.isStarted = !1),
          (this.clickCount = 0),
          (this.unit = 'm'),
          (this.raycaster = new Al()),
          (this.isInstanceObject = !1),
          (this.isAuxLabelVisible = !1),
          (this.isLifeMove = !1),
          (this.callback = () => {}),
          (this.precision = 0),
          (this.isDrawLine = !1),
          (this.m_context = e),
          (this.m_auxModel = e.SceneManager.AuxModel),
          (this.auxGroup = new vr()),
          (this.auxGroup.name = 'auxGroup'),
          this.m_auxModel.add(this.auxGroup),
          (this.domElement = e.Dom),
          (this.m_camera = e.ViewManager.Camera),
          (this.updateDashSizeAndGapSizeBind = this.updateDashSizeAndGapSize.bind(this));
      }
      setUnit(e) {
        this.unit = e;
      }
      setPrecision(e) {
        this.precision = e;
      }
      setAuxLabelVisible(e) {
        this.isAuxLabelVisible = e;
      }
      start() {
        (this.clickCount = 1),
          (this.isStarted = !0),
          window.addEventListener('wheel', this.updateDashSizeAndGapSizeBind),
          this.hideOrShowAllGroup(!0);
      }
      stop() {
        (this.isStarted = !1),
          this.changeCursor('default'),
          window.removeEventListener('wheel', this.updateDashSizeAndGapSizeBind),
          this.hideOrShowAllGroup(!1);
      }
      measure(e) {
        if (this.isStarted && !this.isLifeMove)
          if (this.clickCount % 2 != 1 || this.isInstanceObject) {
            if (this.isDrawLine) {
              let e = this.createPoint(this.endLinePoint);
              this.auxGroupItem.add(...e), (this.isDrawLine = !1);
              let t = this.createAuxLine(this.startLinePoint, this.endLinePoint);
              this.auxGroupItem.add(...t);
              let i = this.createDistanceLabel(this.endLinePoint);
              this.auxGroupItem.add(...i), (this.clickCount = 1);
              let n = this.createRadiusLine();
              this.auxGroupItem.add(n);
            }
          } else {
            (this.auxGroupItem = new vr()),
              this.auxGroup.add(this.auxGroupItem),
              (this.auxGroupItem.name = 'measureGroup');
            let t = this.createPoint(e);
            this.auxGroupItem.add(...t),
              this.clickCount++,
              (this.startLinePoint = e),
              (this.line = this.createLine()),
              this.auxGroupItem.add(this.line),
              (this.isDrawLine = !0),
              this.hideAuxLine();
          }
      }
      createPoint(e) {
        let t = document.createElement('div');
        (t.style.width = '30px'),
          (t.style.height = '3px'),
          (t.style.left = '15px'),
          (t.style.backgroundColor = 'rgba(247, 213, 74, 1)');
        let i = new ic(t);
        (i.visible = !1), i.position.copy(e), (i.name = 'measurePoint');
        let n = document.createElement('div');
        (n.style.width = '15px'),
          (n.style.height = '15px'),
          (n.style.background = 'url(./icon/circle.png) no-repeat'),
          (n.style.backgroundSize = '100% 100%');
        let s = new ic(n);
        (s.visible = !0), s.position.copy(e), (s.name = 'measurePointImg');
        let r = new Wa(0.5, 32),
          a = new Xt(),
          o = new wi(r, a);
        return (o.name = 'measurePoint'), o.position.copy(e), (o.visible = !1), [i, s, o];
      }
      createLine() {
        const e = new Jc();
        let t = [this.startLinePoint.x, this.startLinePoint.y, this.startLinePoint.z];
        e.setPositions(t);
        const i = new Dc({ color: 16241994, linewidth: 2 });
        i.resolution.set(window.innerWidth, window.innerHeight);
        let n = new Kc(e, i);
        return n.computeLineDistances(), (n.name = 'measureLine'), n;
      }
      createRadiusLine() {
        const e = new Jc();
        let t = this.startLinePoint.clone().lerp(this.endLinePoint.clone(), 0.1),
          i = this.startLinePoint.clone().lerp(this.endLinePoint.clone(), 0.9),
          n = [t.x, t.y, t.z, i.x, i.y, i.z];
        e.setPositions(n);
        const s = new Dc({ color: 15794235, linewidth: 30 });
        s.resolution.set(window.innerWidth, window.innerHeight);
        let r = new Kc(e, s);
        return r.computeLineDistances(), (r.name = 'measureRadiusLine'), (r.visible = !1), r;
      }
      drawLine(e) {
        if (((this.endLinePoint = e), !this.isStarted)) return;
        if (!this.line || !this.isDrawLine || !e) return;
        let t = [this.startLinePoint.x, this.startLinePoint.y, this.startLinePoint.z, e.x, e.y, e.z];
        this.line.geometry.setPositions(t);
      }
      createAuxLine(e, t) {
        const i = new Jc();
        let n = [e.x, e.y, e.z, t.x, e.y, e.z];
        i.setPositions(n);
        const s = new Dc({
          color: 15608876,
          linewidth: 3,
          dashed: !0,
          gapSize: 0.01 * this.m_camera.position.z,
          dashSize: 0.01 * this.m_camera.position.z,
        });
        s.resolution.set(window.innerWidth, window.innerHeight);
        let r = new Kc(i, s);
        (r.name = 'auxLine'), r.computeLineDistances();
        const a = new Jc();
        let o = [t.x, e.y, t.z, t.x, t.y, t.z];
        a.setPositions(o);
        const l = new Dc({
          color: 65407,
          linewidth: 3,
          dashed: !0,
          gapSize: 0.01 * this.m_camera.position.z,
          dashSize: 0.01 * this.m_camera.position.z,
        });
        l.resolution.set(window.innerWidth, window.innerHeight);
        let h = new Kc(a, l);
        return h.computeLineDistances(), (h.name = 'auxLine'), [r, h];
      }
      createDistanceLabel(e) {
        let t = this.createdDistanceLabelObject(this.startLinePoint, e, 'rgba(247, 213, 74, 1)', 'distanceLabel'),
          i = this.createdDistanceLabelObject(
            new Pe(this.startLinePoint.x, this.startLinePoint.y, this.startLinePoint.z),
            new Pe(e.x, this.startLinePoint.y, this.startLinePoint.z),
            'rgba(238, 44, 44, 1)',
            'distanceLabelAux',
          ),
          n = this.createdDistanceLabelObject(
            new Pe(e.x, e.y, e.z),
            new Pe(e.x, this.startLinePoint.y, e.z),
            'rgba(0, 255, 127, 1)',
            'distanceLabelAux',
            0.7,
          );
        return this.callback(this.getDistanceInfo(e)), [i, n, t];
      }
      createdDistanceLabelObject(e, t, i, n, s = 0.5) {
        let r = this.changeDistanceLabelUnit(e.clone(), t.clone()),
          a = document.createElement('div');
        (a.style.width = '130px'),
          (a.style.height = '30px'),
          (a.style.color = i),
          (a.style.textAlign = 'center'),
          (a.style.lineHeight = '30px'),
          (a.style.fontWeight = '700'),
          (a.style.position = 'absolute'),
          (a.innerHTML = r.toFixed(this.precision) + ' ' + this.unit);
        let o = e.clone().lerp(t, s),
          l = new ic(a);
        return (l.visible = !0), (l.name = n), l.position.copy(o), l;
      }
      changeDistanceLabelUnit(e, t) {
        let i = e.distanceTo(t);
        switch (this.unit) {
          case 'm':
          default:
            break;
          case 'cm':
            i *= 100;
            break;
          case 'mm':
            i *= 1e3;
        }
        return i;
      }
      getDistanceInfo(e) {
        let t = this.startLinePoint.distanceTo(e),
          i = Math.abs(this.startLinePoint.x - e.x),
          n = Math.abs(this.startLinePoint.y - e.y);
        switch (this.unit) {
          case 'm':
          default:
            break;
          case 'cm':
            (t *= 100), (i *= 100), (n *= 100);
            break;
          case 'mm':
            (t *= 1e3), (i *= 1e3), (n *= 1e3);
        }
        return (
          (t = Number(t.toFixed(this.precision))),
          (i = Number(i.toFixed(this.precision))),
          (n = Number(n.toFixed(this.precision))),
          { distance: t, xDistance: i, yDistance: n }
        );
      }
      setCallback(e) {
        this.callback = e;
      }
      hideAuxLine() {
        this.auxGroup.traverse((e) => {
          e instanceof Kc && 'auxLine' === e.name && (e.visible = !1),
            e instanceof Kc && 'measureLine' === e.name && e.material.color.setHSL(0.16, 0.8, 0.5),
            e instanceof ic && 'measurePointImg' === e.name && (e.visible = !0),
            e instanceof ic &&
              e.name.includes('distanceLabel') &&
              ((e.element.style.webkitTextStroke = '0px #ffffff'),
              (e.element.style.zIndex = '1'),
              (e.element.style.opacity = '0.6')),
            e instanceof ic && 'distanceLabelAux' === e.name && (e.visible = !1);
        });
      }
      changeCursor(e) {
        this.domElement.style.cursor = e;
      }
      DetectionLine(e) {
        let t = new se();
        (t.x = this.endLinePoint.clone().project(this.m_camera).x),
          (t.y = this.endLinePoint.clone().project(this.m_camera).y),
          this.raycaster.setFromCamera(t, this.m_camera);
        const i = this.raycaster.intersectObject(this.auxGroup, !0);
        if (i.length > 0) {
          if (
            ((this.isInstanceObject = !0),
            i.some((e) => 'measurePoint' === e.object.name || 'auxLine' === e.object.name) &&
              (this.isInstanceObject = !1),
            -1 === e.button)
          )
            this.onMouseMoveChangeCursor();
          else if (0 === e.button && !this.isDrawLine) {
            if (i.every((e) => 'auxLine' === e.object.name && !e.object.visible)) return;
            let e = i.filter((e) => 'measureLine' === e.object.name && e.object.visible);
            e.length > 0
              ? e.forEach((e) => {
                  var t;
                  null === (t = e.object.parent) ||
                    void 0 === t ||
                    t.traverse((t) => {
                      t instanceof wi &&
                        'measurePoint' === t.name &&
                        t.position.equals(this.startLinePoint) &&
                        this.onMouseClickShowAuxLine(e.object.parent);
                    });
                })
              : this.onMouseClickShowAuxLine(i[0].object.parent);
          }
        } else this.isStarted && this.changeCursor('url(./icon/ruler.png),auto'), (this.isInstanceObject = !1);
      }
      onMouseMoveChangeCursor() {
        this.isStarted &&
          (!this.isDrawLine && this.isInstanceObject
            ? this.changeCursor('pointer')
            : this.changeCursor('url(./icon/ruler.png),auto'));
      }
      onMouseClickShowAuxLine(e) {
        this.isStarted &&
          e.children.length > 0 &&
          (this.hideAuxLine(),
          (this.intersectsGroup = e),
          e.traverse((e) => {
            e instanceof Kc && 'auxLine' === e.name && (e.visible = !0),
              e instanceof Kc && 'measureLine' === e.name && e.material.color.setHSL(0.16, 0.9, 0.8),
              e instanceof ic && 'measurePointImg' === e.name && (e.visible = !0),
              e instanceof ic &&
                e.name.includes('distanceLabel') &&
                ((e.element.style.webkitTextStroke = '0.3px #ffffff'),
                (e.element.style.zIndex = '100'),
                (e.element.style.opacity = '1')),
              e instanceof ic && 'distanceLabelAux' === e.name && (e.visible = this.isAuxLabelVisible);
          }));
      }
      updateDashSizeAndGapSize() {
        this.auxGroup.traverse((e) => {
          e instanceof Kc &&
            'auxLine' === e.name &&
            ((e.material.dashSize = 0.01 * this.m_camera.position.z),
            (e.material.gapSize = 0.01 * this.m_camera.position.z));
        });
      }
      deleteIntersectsGroup() {
        this.intersectsGroup &&
          this.isStarted &&
          (this.intersectsGroup.traverse((e) => {
            e instanceof Kc && ((e.visible = !1), e.geometry.dispose(), e.material.dispose()),
              e instanceof wi && ((e.visible = !1), e.geometry.dispose(), e.material.dispose()),
              e instanceof ic && ((e.element.style.display = 'none'), e.element.remove());
          }),
          this.auxGroup.remove(this.intersectsGroup),
          this.m_context.ViewManager.Render());
      }
      hideOrShowAllGroup(e) {
        let t = document.querySelector('.cssRender');
        this.auxGroup.traverse((i) => {
          i instanceof Kc && 'auxLine' === i.name && (i.visible = !1),
            i instanceof Kc && 'measureLine' === i.name && (i.visible = e),
            (t.style.display = e ? 'block' : 'none');
        }),
          this.intersectsGroup &&
            this.intersectsGroup.traverse((t) => {
              t instanceof Kc && 'auxLine' === t.name && (t.visible = e);
            }),
          this.m_context.ViewManager.Render();
      }
      clearAllMeasure() {
        this.auxGroup.traverse((e) => {
          e instanceof Kc && 'auxLine' === e.name && ((e.visible = !1), e.geometry.dispose(), e.material.dispose()),
            e instanceof wi && ((e.visible = !1), e.geometry.dispose(), e.material.dispose()),
            e instanceof ic && ((e.element.style.display = 'none'), e.element.remove());
        }),
          (this.auxGroup.children.length = 0),
          this.m_context.ViewManager.Render();
      }
      clearMeasure() {
        this.isStarted &&
          (this.auxGroupItem.traverse((e) => {
            e instanceof Kc && 'auxLine' === e.name && ((e.visible = !1), e.geometry.dispose(), e.material.dispose()),
              e instanceof wi && ((e.visible = !1), e.geometry.dispose(), e.material.dispose()),
              e instanceof ic && ((e.element.style.display = 'none'), e.element.remove());
          }),
          (this.clickCount = 1),
          this.auxGroup.remove(this.auxGroupItem),
          this.m_context.ViewManager.Render());
      }
    }
    function Qc(e, t = !1) {
      const i = null !== e[0].index,
        n = new Set(Object.keys(e[0].attributes)),
        s = new Set(Object.keys(e[0].morphAttributes)),
        r = {},
        a = {},
        o = e[0].morphTargetsRelative,
        l = new ai();
      let h = 0;
      for (let c = 0; c < e.length; ++c) {
        const u = e[c];
        let d = 0;
        if (i !== (null !== u.index)) return null;
        for (const e in u.attributes) {
          if (!n.has(e)) return null;
          void 0 === r[e] && (r[e] = []), r[e].push(u.attributes[e]), d++;
        }
        if (d !== n.size) return null;
        if (o !== u.morphTargetsRelative) return null;
        for (const e in u.morphAttributes) {
          if (!s.has(e)) return null;
          void 0 === a[e] && (a[e] = []), a[e].push(u.morphAttributes[e]);
        }
        if (
          ((l.userData.mergedUserData = l.userData.mergedUserData || []), l.userData.mergedUserData.push(u.userData), t)
        ) {
          let e;
          if (i) e = u.index.count;
          else {
            if (void 0 === u.attributes.position) return null;
            e = u.attributes.position.count;
          }
          l.addGroup(h, e, c), (h += e);
        }
      }
      if (i) {
        let t = 0;
        const i = [];
        for (let n = 0; n < e.length; ++n) {
          const s = e[n].index;
          for (let e = 0; e < s.count; ++e) i.push(s.getX(e) + t);
          t += e[n].attributes.position.count;
        }
        l.setIndex(i);
      }
      for (const e in r) {
        const t = eu(r[e]);
        if (!t) return null;
        l.setAttribute(e, t);
      }
      for (const e in a) {
        const t = a[e][0].length;
        if (0 === t) break;
        (l.morphAttributes = l.morphAttributes || {}), (l.morphAttributes[e] = []);
        for (let i = 0; i < t; ++i) {
          const t = [];
          for (let n = 0; n < a[e].length; ++n) t.push(a[e][n][i]);
          const n = eu(t);
          if (!n) return null;
          l.morphAttributes[e].push(n);
        }
      }
      return l;
    }
    function eu(e) {
      let t,
        i,
        n,
        s = 0;
      for (let r = 0; r < e.length; ++r) {
        const a = e[r];
        if (a.isInterleavedBufferAttribute) return null;
        if ((void 0 === t && (t = a.array.constructor), t !== a.array.constructor)) return null;
        if ((void 0 === i && (i = a.itemSize), i !== a.itemSize)) return null;
        if ((void 0 === n && (n = a.normalized), n !== a.normalized)) return null;
        s += a.array.length;
      }
      const r = new t(s);
      let a = 0;
      for (let t = 0; t < e.length; ++t) r.set(e[t].array, a), (a += e[t].array.length);
      return new Zt(r, i, n);
    }
    var tu, iu, nu;
    !(function (e) {
      (e.None = 'none'),
        (e.Pick = 'pick'),
        (e.SelectionBox = 'selectionBox'),
        (e.Place = 'place'),
        (e.drawline = 'drawline');
    })(tu || (tu = {})),
      (function (e) {
        (e.Hover = 'hover'),
          (e.Pick = 'pick'),
          (e.SelectionBox = 'selectBox'),
          (e.Place = 'place'),
          (e.addhole = 'addhole'),
          (e.drawline = 'drawline'),
          (e.snapFilter = 'snapFilter'),
          (e.inserts = 'inserts');
      })(iu || (iu = {}));
    class su extends i {
      constructor(e) {
        super(e),
          (this.m_eventManager = new jh()),
          (this.m_raycaster = new Al()),
          (this.m_plane = new Bi()),
          (this.m_isHover = !0),
          (this.m_enableSnap = !1),
          (this.m_selectionState = tu.None),
          (this.m_hovercolor = 4283096556),
          (this.m_selectcolor = 4283096556),
          (this.holeArr = []),
          (this.drawPoints = []),
          (this.HighLighting = !0),
          (this.preRotateAngle = 0),
          (this.leftMoveNum = 0),
          (this.mouseMovePosition = new Pe(0, 0, 0)),
          (this.insertRotate = Math.PI / 2),
          (this.insertFileRotateOffsetArr = []),
          (this.originCenter = new Pe(0, 0, 0)),
          (this.insertFileRotate = 0),
          (this.moveDbLines = []),
          (this.moverDbMesh = []),
          (this.selectionData = {}),
          (this.selectionDataArr = []),
          (this.isSingleSelect = !1),
          (this.linesModelsAll = this.m_context.ModelManager.Lines),
          (this.meshsModelsAll = this.m_context.ModelManager.Meshs),
          (this.startEditSelect = !1),
          (this.moveMeshSelect = []),
          (this.moveLineAuxStartPoint = new Pe()),
          (this.moveLineAuxPointDownCount = 0),
          (this.moveStart = !1),
          (this.moveLineSelect = []),
          (this.copyStart = !1),
          (this.copyDbLines = []),
          (this.copyDbLinesOrgin = []),
          (this.copyDbMeshs = []),
          (this.copyDbMeshsOrgin = []),
          (this.copyCount = 0),
          (this.insertFileComplete = !1),
          (this.isInsertFile = !1),
          (this.insertMangerCount = 0),
          (this.insertGeos = { lines: {}, meshs: {} }),
          (this.insertRootId = ''),
          (this.isInsertContinuous = !1),
          (this.insertFileScale = 1),
          (this.insertGroupPositions = []),
          (this.InsertFileToPositionNum = 0),
          (this.insertGeosCopy = { lines: {}, meshs: {} }),
          (this.isMultipleInsert = !1),
          (this.isReplaceFile = !1),
          (this.replaceRootId = '0'),
          (this.replaceObjects = { lines: [], meshs: [] }),
          (this.rotateStart = !1),
          (this.m_selection = new Sc(e)),
          (this.m_hoverData = new Sc(e, new ve(4906476))),
          this.m_plane.set(new Pe(0, 0, 1), 0),
          this.m_context.ViewManager.EventManager.addEventListener('pointermove', this.onMouseMove.bind(this)),
          this.m_context.ViewManager.EventManager.addEventListener('pointerup', this.onMouseUp.bind(this)),
          this.m_context.ViewManager.EventManager.addEventListener('pointerdown', this.onMouseDown.bind(this)),
          window.addEventListener('keydown', this.keydown.bind(this)),
          window.addEventListener('keyup', this.keyup.bind(this)),
          (this.multiSelect = !1),
          (this.m_enableShift = !1),
          (this.drawlineEve = void 0),
          (this.sphereTmp = void 0),
          (this.lineObj = void 0),
          (this.m_snapModel = new Tc(this.m_context.ViewManager.m_context.SceneManager.AuxModel)),
          (this.m_measurement = new $c(this.m_context)),
          (this.updateDashSizeAndGapSizeBind = this.updateDashSizeAndGapSize.bind(this));
      }
      get EnableHover() {
        return this.m_isHover;
      }
      set setEnableHover(e) {
        this.m_isHover = e;
      }
      get EventManager() {
        return this.m_eventManager;
      }
      ResetHoverColor() {
        this.m_hoverData.setColor(this.m_hovercolor, 1);
      }
      ResetSelectionColor() {
        this.m_selection.setColor(this.m_selectcolor, 1);
      }
      SetHoverColor(e, t = 1) {
        this.m_hoverData.setColor(e, t);
      }
      SetSelectionColor(e, t = 1) {
        this.m_selection.setColor(e, t);
      }
      OpenSelectBox() {
        (this.selectionBox = new Zh(
          this.m_context.ViewManager.Camera,
          this.m_context.ModelManager,
          this.m_context.SceneManager.ThreeLayer,
          this.m_context.SceneManager.SignModel,
        )),
          (this.helper1 = new wc(this.m_context.ViewManager.EventManager, this.m_context.Dom, 'selectBox'));
      }
      cancelSelectBox() {
        (this.m_selectionState = tu.None), this.helper1 && this.helper1.dispose(), this.m_context.ViewManager.Render();
      }
      onMouseUp(e) {
        var t, i, n, s;
        if (0 == e.button && (this.m_hoverData.clear(), this.HighLighting))
          switch (this.m_selectionState) {
            case tu.SelectionBox:
              if (this.helper1 && this.helper1.isDown) {
                null === (t = this.selectionBox) ||
                  void 0 === t ||
                  t.m_endPoint.set(
                    (e.offsetX / this.m_context.Dom.clientWidth) * 2 - 1,
                    (-e.offsetY / this.m_context.Dom.clientHeight) * 2 + 1,
                    0.5,
                  ),
                  null === (i = this.selectionBox) || void 0 === i || i.select(),
                  (null === (n = this.selectionBox) || void 0 === n ? void 0 : n.Collection) &&
                    this.m_selection.addObjects(
                      ...(null === (s = this.selectionBox) || void 0 === s ? void 0 : s.Collection),
                    );
                let r = new Re();
                this.m_selection && r.setFromObject(this.m_selection),
                  this.m_eventManager.dispatchEvent(iu.SelectionBox, { box: r, entity: this.m_selection.getObjects() });
              }
              this.m_context.ViewManager.Controls.EnablePan = !0;
              break;
            case tu.Place:
              {
                let t = this.m_context.ViewManager.Controls.DownPointXY,
                  i = new se(e.offsetX, e.offsetY);
                if (t.distanceTo(i) > 4) return;
                if (this.m_paceObject) {
                  let t;
                  this.GetInsertObject(e.offsetX, e.offsetY, (e) => {
                    t = e.obejct[0];
                  });
                  let i = this.GetPointByScreenXY(e.offsetX, e.offsetY);
                  if (null == this.PlaceBeforeCallBack || this.PlaceBeforeCallBack({ location: i, entity: t })) {
                    let e = this.m_paceObject.clone();
                    e.position.copy(i), this.m_context.SceneManager.SignModel.children.push(e);
                    let t = { location: { x: Number(i.x), y: Number(i.y), z: Number(i.z) }, entity: e };
                    this.m_eventManager.dispatchEvent(iu.Place, { place: t, next: this.m_paceObject }),
                      (e.userData.id = e.id),
                      this.m_context.ViewManager.Render();
                  }
                }
              }
              break;
            case tu.drawline: {
              let t = this.m_context.ViewManager.Controls.DownPointXY,
                i = new se(e.offsetX, e.offsetY);
              if (t.distanceTo(i) > 4) return;
              let n = this.GetPointByScreenXY(e.offsetX, e.offsetY),
                s = new So(0.49, 30, 30),
                r = new Xt({ color: 'green', side: 1 }),
                a = new wi(s, r);
              if (
                ((a.userData.name = 'drawP'),
                a.position.copy(n),
                this.m_context.SceneManager.ThreeLayer.children.push(a),
                this.sphereTmp ||
                  ((this.sphereTmp = a.clone()),
                  this.m_context.SceneManager.ThreeLayer.children.push(this.sphereTmp),
                  (this.sphereTmp.userData.name = 'drawP2')),
                this.drawPoints.length > 0 && this.drawPoints.splice(this.drawPoints.length - 1, 1),
                this.drawPoints.push(n),
                this.drawPoints.push(n.clone()),
                this.drawPoints.length > 1)
              ) {
                this.clearPointLine('drawL');
                let e = new ai().setFromPoints(this.drawPoints),
                  t = new Xt({ color: 'blue' });
                (this.lineObj = new pa(e, t)),
                  this.m_context.SceneManager.ThreeLayer.children.push(this.lineObj),
                  (this.lineObj.userData.name = 'drawL');
              }
              this.m_eventManager.dispatchEvent(iu.drawline, { points: this.drawPoints }),
                this.m_context.ViewManager.Render();
            }
            case tu.None:
              if (this.m_isHover || this.m_selectionState.toString() == tu.Place) {
                let t = !1,
                  i = this.GetPointByScreenXY(e.offsetX, e.offsetY);
                if (
                  (this.GetInsertObject(e.offsetX, e.offsetY, (e) => {
                    e.adjust && (i = new Pe(e.adjust.x, e.adjust.y, e.adjust.z)),
                      this.m_eventManager.dispatchEvent(iu.inserts, e),
                      (t = !0),
                      this.HighLighting && this.m_hoverData.addObjects(...e.obejct);
                  }),
                  !t)
                ) {
                  let t = this.GetPointByScreenXY(e.offsetX, e.offsetY);
                  this.m_eventManager.dispatchEvent(iu.inserts, new Jh(t, 0, '', []));
                }
                this.m_measurement.measure(i), this.m_measurement.DetectionLine(e);
              }
              this.isInsertFile && 1 == this.insertMangerCount && this.InsetFileEnd();
              break;
            default: {
              let t = this.m_context.ViewManager.Controls.DownPointXY,
                i = new se(e.offsetX, e.offsetY);
              if (t.distanceTo(i) > 4) return;
              if (
                (this.GetInsertObject(e.offsetX, e.offsetY, (e) => {
                  if (this.m_enableShift || this.multiSelect) {
                    let t = this.m_selection.clearObj(e.obejct[0]),
                      i = {
                        location: { x: Number(e.location.x), y: Number(e.location.y), z: Number(e.location.z) },
                        entity: e.obejct[0],
                      };
                    t || this.m_selection.addObjects(...e.obejct), this.m_eventManager.dispatchEvent(iu.Pick, i);
                  } else {
                    let t = {
                      location: { x: Number(e.location.x), y: Number(e.location.y), z: Number(e.location.z) },
                      entity: e.obejct[0],
                      code: e.code,
                    };
                    this.m_eventManager.dispatchEvent(iu.Pick, t),
                      this.m_selection.clear(),
                      this.m_selection.addObjects(...e.obejct);
                  }
                }),
                this.m_selectionState == tu.Pick && this.isReplaceFile)
              ) {
                let e = !1,
                  t = this.m_context.ModelManager.Instances;
                for (const i in t)
                  t[i].forEach((t, i) => {
                    this.selectionData.entity && t.id == this.selectionData.entity.root_reference_id && (e = !0);
                  });
                if (!e)
                  return (
                    (this.insertGroup = this.m_context.SceneManager.ModelLayer.getObjectByName('insertGroup')),
                    (this.insertGeos = this.m_context.ModelManager.insertGeos),
                    (this.insertGroup.visible = !1),
                    (this.isReplaceFile = !1),
                    this.emptyInsertGroup(),
                    (this.insertGeos.lines = {}),
                    (this.insertGeos.meshs = {}),
                    (this.insertRootId = ''),
                    (this.selectionData.entity = void 0),
                    void this.CancelPick()
                  );
                this.m_context.LoadManager.LoadBlockP2d(this.replaceFile.url, !0, this.ReplaceFileEnd.bind(this));
              }
            }
          }
      }
      clearPointLine(e) {
        if (e) {
          let t = this.m_context.SceneManager.ThreeLayer.children.filter((t) => {
            if (t.userData.name != e) return t;
            ec(t);
          });
          (this.m_context.SceneManager.ThreeLayer.children = t), 'drawP' == e && (this.drawPoints = []);
        } else {
          let e = this.m_context.SceneManager.ThreeLayer.children.filter((e) => {
            if ('drawP' != e.userData.name && 'drawL' != e.userData.name && 'drawP2' != e.userData.name) return e;
            ec(e);
          });
          (this.m_context.SceneManager.ThreeLayer.children = e), (this.drawPoints = []);
        }
        this.m_context.ViewManager.Render();
      }
      stopDrawLine() {
        if (
          (this.m_eventManager.removeEventListener(iu.drawline, this.drawlineEve),
          (this.m_selectionState = tu.None),
          this.drawPoints.splice(this.drawPoints.length - 1, 1),
          this.lineObj)
        ) {
          let e = this.lineObj.geometry.attributes.position.array.length,
            t = this.lineObj.geometry.attributes.position.array;
          (this.lineObj.geometry.attributes.position.array = t.slice(0, e - 3)),
            (this.lineObj.geometry.attributes.position.count -= 1),
            (this.lineObj.geometry.attributes.position.needsUpdate = !0);
        }
        let e;
        (e =
          this.drawPoints.length > 1
            ? this.m_context.SceneManager.ThreeLayer.children.filter((e) => {
                if ('drawP2' != e.userData.name) return e;
                ec(e);
              })
            : this.m_context.SceneManager.ThreeLayer.children.filter((e) => {
                if ('drawP2' != e.userData.name && 'drawP' != e.userData.name) return e;
                ec(e);
              })),
          (this.m_context.SceneManager.ThreeLayer.children = e),
          this.m_context.ViewManager.Render();
      }
      checkIntersect(e) {
        for (let t = 0; t < this.holeArr.length; t++) if (this.holeArr[t].intersectsBox(e)) return !0;
        return !1;
      }
      get HoverData() {
        return this.m_hoverData.getObjects();
      }
      onMouseDown(e) {
        var t;
        if (0 == e.button)
          if (
            ((this.multiSelect && this.m_enableShift) ||
              (this.m_selection.clear(), (this.selectionDataArr.length = 0), this.m_context.ViewManager.Render()),
            this.m_selectionState == tu.SelectionBox)
          )
            (this.m_context.ViewManager.Controls.EnablePan = !1),
              null === (t = this.selectionBox) ||
                void 0 === t ||
                t.m_startPoint.set(
                  (e.offsetX / this.m_context.Dom.clientWidth) * 2 - 1,
                  (-e.offsetY / this.m_context.Dom.clientHeight) * 2 + 1,
                  0.5,
                );
          else if (this.m_selectionState == tu.Pick);
          else if (this.m_selectionState == tu.Place);
          else if (this.m_selectionState == tu.None) {
            if (
              (this.moveStart || this.rotateStart) &&
              (this.moveLineSelect.length > 0 || this.moveMeshSelect.length > 0)
            )
              if ((this.moveLineAuxPointDownCount++, 2 == this.moveLineAuxPointDownCount))
                this.moveStart ? this.EndMove() : this.rotateStart && this.EndRotate();
              else {
                let t = this.GetPointByScreenXY(e.offsetX, e.offsetY);
                (this.moveLineAuxStartPoint = t),
                  this.createdMoveLineAux(),
                  window.addEventListener('wheel', this.updateDashSizeAndGapSizeBind),
                  this.rotateStart && (this.m_context.Dom.style.cursor = 'all-scroll');
              }
          } else this.m_selectionState, tu.drawline;
      }
      onMouseMove(e) {
        var t, i, n;
        if (
          (this.m_hoverData.clear(),
          (this.mouseMovePosition = this.GetPointByScreenXY(e.offsetX, e.offsetY)),
          this.m_context.ViewManager.Controls.IsPan)
        )
          return this.leftMoveNum++, void (this.leftMoveNum > 10 && (this.m_measurement.isLifeMove = !0));
        switch (((this.leftMoveNum = 0), (this.m_measurement.isLifeMove = !1), this.m_selectionState)) {
          case tu.drawline:
            {
              let t = this.GetPointByScreenXY(e.offsetX, e.offsetY);
              if ((this.sphereTmp && this.sphereTmp.position.copy(t), this.lineObj)) {
                let e = this.lineObj.geometry.attributes.position.array.length;
                (this.lineObj.geometry.attributes.position.array[e - 3] = t.x),
                  (this.lineObj.geometry.attributes.position.array[e - 2] = t.y),
                  (this.lineObj.geometry.attributes.position.array[e - 1] = t.z),
                  (this.lineObj.geometry.attributes.position.needsUpdate = !0);
              }
            }
            break;
          case tu.None:
            if (this.m_isHover || this.m_selectionState.toString() == tu.Place) {
              let i = !1,
                n = this.GetPointByScreenXY(e.offsetX, e.offsetY);
              if (
                (this.GetInsertObject(e.offsetX, e.offsetY, (e) => {
                  e.adjust && (n = new Pe(e.adjust.x, e.adjust.y, e.adjust.z)),
                    this.m_eventManager.dispatchEvent(iu.inserts, e),
                    (i = !0),
                    this.HighLighting && this.m_hoverData.addObjects(...e.obejct);
                }),
                !i)
              ) {
                let t = this.GetPointByScreenXY(e.offsetX, e.offsetY);
                this.m_eventManager.dispatchEvent(iu.inserts, new Jh(t, 0, '', []));
              }
              if ((this.m_measurement.drawLine(n), this.m_measurement.DetectionLine(e), this.moveLineAux)) {
                null === (t = this.moveLineAux) ||
                  void 0 === t ||
                  t.geometry.setAttribute(
                    'position',
                    new Zt(
                      new Float32Array([
                        this.moveLineAuxStartPoint.x,
                        this.moveLineAuxStartPoint.y,
                        this.moveLineAuxStartPoint.z,
                        n.x,
                        n.y,
                        n.z,
                      ]),
                      3,
                    ),
                  ),
                  this.moveLineAux.computeLineDistances();
                let e = new Pe();
                if (
                  ((e.x = n.x - this.moveLineAuxStartPoint.x),
                  (e.y = n.y - this.moveLineAuxStartPoint.y),
                  this.moveStart &&
                    (this.moveLineSelect.forEach((t) => {
                      (t.position.x = t.startPosition.x + e.x), (t.position.y = t.startPosition.y + e.y);
                    }),
                    this.moveMeshSelect.forEach((t) => {
                      (t.position.x = t.startPosition.x + e.x), (t.position.y = t.startPosition.y + e.y);
                    })),
                  this.rotateStart)
                ) {
                  let t = new Pe(1, 0, 0),
                    i = 0;
                  i = e.y < 0 ? -e.angleTo(t) : e.angleTo(t);
                  let n = i - this.preRotateAngle;
                  this.moveLineSelect.forEach((e, t) => {
                    if (e instanceof _a) {
                      let i = e.geometry.attributes.position.clone();
                      for (let e = 0; e < i.count; e++) {
                        let t = new Pe(i.getX(e), i.getY(e), i.getZ(e));
                        t.sub(this.moveLineAuxStartPoint),
                          t.applyAxisAngle(new Pe(0, 0, 1), n),
                          t.add(this.moveLineAuxStartPoint),
                          i.setXYZ(e, t.x, t.y, t.z);
                      }
                      if (
                        (e.geometry.attributes.position.copy(i),
                        (e.geometry.attributes.position.needsUpdate = !0),
                        e.geometry.computeBoundingBox(),
                        e.geometry.computeBoundingSphere(),
                        this.moveLineSelect[t - 1] instanceof Kc)
                      ) {
                        let e = this.moveLineSelect[t - 1].geometry;
                        e.setPositions(i.array), e.computeBoundingBox(), e.computeBoundingSphere();
                      }
                    }
                  }),
                    this.moveMeshSelect.forEach((e) => {
                      let t = e.geometry.attributes.position.clone();
                      for (let e = 0; e < t.count; e++) {
                        let i = new Pe(t.getX(e), t.getY(e), t.getZ(e));
                        i.sub(this.moveLineAuxStartPoint),
                          i.applyAxisAngle(new Pe(0, 0, 1), n),
                          i.add(this.moveLineAuxStartPoint),
                          t.setXYZ(e, i.x, i.y, i.z);
                      }
                      e.geometry.attributes.position.copy(t),
                        (e.geometry.attributes.position.needsUpdate = !0),
                        e.geometry.computeBoundingBox(),
                        e.geometry.computeBoundingSphere();
                    }),
                    (this.preRotateAngle = i);
                }
              }
            }
            if (this.isInsertFile) {
              let t = this.GetPointByScreenXY(e.offsetX, e.offsetY);
              null === (i = this.insertGroup) || void 0 === i || i.position.copy(t);
            }
            break;
          case tu.Place:
            if (this.m_paceObject) {
              let t = this.GetPointByScreenXY(e.offsetX, e.offsetY);
              this.m_paceObject.position.copy(t);
            }
          case tu.Pick:
            if (!this.m_isHover) return;
            this.GetInsertObject(e.offsetX, e.offsetY, (e) => {
              this.m_hoverData.addObjects(...e.obejct);
            });
            break;
          case tu.SelectionBox:
            this.helper1 &&
              this.helper1.isDown &&
              (null === (n = this.selectionBox) ||
                void 0 === n ||
                n.m_endPoint.set(
                  (e.offsetX / this.m_context.Dom.clientWidth) * 2 - 1,
                  (-e.offsetY / this.m_context.Dom.clientHeight) * 2 + 1,
                  0.5,
                ));
        }
      }
      keydown(e) {
        17 != e.keyCode || this.isSingleSelect || (this.m_enableShift = !0),
          46 == e.keyCode && this.m_measurement.deleteIntersectsGroup();
      }
      keyup(e) {
        (this.m_enableShift = !1),
          27 == e.keyCode && this.m_measurement.clearMeasure(),
          32 == e.keyCode && this.insertFile && this.insertGeoAndDataSetRotate(this.insertRotate);
      }
      insertGeoAndDataSetRotate(e) {
        this.insertFileRotate >= 2 * Math.PI && (this.insertFileRotate = 0), (this.insertFileRotate += e);
        let t = new Pe(0, 0, 0);
        this.insertGroup &&
          this.insertGroup.traverse((i) => {
            if (i instanceof wi || i instanceof _a) {
              let n = i.geometry.attributes.position.clone();
              this.insertFileRotateOffsetArr.length || (this.originCenter = i.geometry.boundingSphere.center.clone());
              for (let s = 0; s < n.count; s++) {
                let r = new Pe(n.getX(s), n.getY(s), n.getZ(s));
                r.sub(t),
                  r.applyAxisAngle(new Pe(0, 0, 1), e),
                  r.add(t),
                  n.setXYZ(s, r.x, r.y, r.z),
                  i.geometry.attributes.position.copy(n),
                  (i.geometry.attributes.position.needsUpdate = !0),
                  i.geometry.computeBoundingBox(),
                  i.geometry.computeBoundingSphere(),
                  this.m_context.ViewManager.Render();
              }
              let s = i.geometry.boundingSphere.center.clone();
              this.insertFileRotateOffsetArr.length
                ? (this.insertFileRotateOffsetArr[0] = new Pe(
                    s.x - this.originCenter.x,
                    s.y - this.originCenter.y,
                    s.z - this.originCenter.z,
                  ))
                : this.insertFileRotateOffsetArr.push(
                    new Pe(s.x - this.originCenter.x, s.y - this.originCenter.y, s.z - this.originCenter.z),
                  );
            }
          });
        for (const i in this.insertGeos.lines)
          this.insertGeos.lines[i].lines.forEach((n) => {
            var s;
            let r = [...n.points],
              a = new Zt(new Float32Array(r), 3);
            for (let r = 0; r < a.count; r++) {
              let o = new Pe(a.getX(r), a.getY(r), a.getZ(r));
              o.sub(t),
                o.applyAxisAngle(new Pe(0, 0, 1), e),
                o.add(t),
                a.setXYZ(r, o.x, o.y, o.z),
                (n.points = a.array);
              let l = this.insertGeos.lines[i].model.geometry.boundingSphere.center;
              (n.sphere.center = { x: l.x, y: l.y, z: l.z }),
                (n.sphere.radius =
                  null === (s = this.insertGeos.lines[i].model.geometry.boundingSphere) || void 0 === s
                    ? void 0
                    : s.radius),
                this.m_context.ViewManager.Render();
            }
          });
        for (const i in this.insertGeos.meshs)
          this.insertGeos.meshs[i].meshs.forEach((n) => {
            var s;
            let r = new Zt(n.vertexs, 3);
            for (let a = 0; a < r.count; a++) {
              let o = new Pe(r.getX(a), r.getY(a), r.getZ(a));
              o.sub(t),
                o.applyAxisAngle(new Pe(0, 0, 1), e),
                o.add(t),
                r.setXYZ(a, o.x, o.y, o.z),
                (n.vertexs = r.array);
              let l = this.insertGeos.meshs[i].model.geometry.boundingSphere.center;
              (n.sphere.center = { x: l.x, y: l.y, z: l.z }),
                (n.sphere.radius =
                  null === (s = this.insertGeos.meshs[i].model.geometry.boundingSphere) || void 0 === s
                    ? void 0
                    : s.radius),
                this.m_context.ViewManager.Render();
            }
          });
      }
      GetInsertObject(e, t, i) {
        let n = this.m_context.ViewManager.Camera,
          s = (e / this.m_context.Dom.offsetWidth) * 2 - 1,
          r = (-t / this.m_context.Dom.offsetHeight) * 2 + 1;
        this.m_raycaster.setFromCamera(new se(s, r), n);
        let a = this.m_raycaster.ray,
          o = new Pe();
        n.getWorldPosition(o).z;
        let l = 0.5 * n.fov * (Math.PI / 180),
          h = (Math.tan(l) * n.position.z * 2) / this.m_context.Dom.offsetHeight,
          c = 5 * h;
        if (this.m_raycaster.intersectObject(this.m_context.SceneManager.MaskLayer).length > 0) return;
        let u = [];
        if (
          (this.m_context.ModelManager.GetInsertObject(a, c, (e) => (u.push(e), this.m_enableSnap)),
          this.m_eventManager.dispatchEvent(iu.snapFilter, { ray: a, array: u, tol: c }),
          u.length > 0)
        ) {
          if (this.m_enableSnap) {
            let e = u.map((e) => e.position),
              t = u.filter(
                (t) =>
                  !(e.includes('start') || e.includes('end') || e.includes('cross')) ||
                  !t.position.includes('aux') ||
                  void 0,
              ),
              n = Ac.min(t, (e) => e.distance);
            if (n) {
              i(n);
              let e = n.adjust
                  ? new Pe(n.adjust.x, n.adjust.y, n.adjust.z)
                  : new Pe(n.location.x, n.location.y, n.location.z),
                t = {
                  start: () => {
                    this.m_snapModel.set(Ec.end, e, h);
                  },
                  end: () => {
                    this.m_snapModel.set(Ec.end, e, h);
                  },
                  center: () => {
                    this.m_snapModel.set(Ec.center, e, h);
                  },
                  insert: () => {
                    this.m_snapModel.set(Ec.insert, e, h);
                  },
                  cross: () => {
                    this.m_snapModel.set(Ec.cross, e, h);
                  },
                  vertical: () => {
                    this.m_snapModel.set(Ec.vertical, e, h);
                  },
                  auxOrthogonal: () => {
                    this.m_snapModel.set(Ec.other, e, h);
                  },
                  auxVertical: () => {
                    this.m_snapModel.set(Ec.other, e, h);
                  },
                };
              t[n.position] ? t[n.position]() : this.m_snapModel.set(Ec.none, new Pe(0, 0, 0), h);
            }
          } else i(u[0]), this.m_snapModel.set(Ec.none, new Pe(0, 0, 0), h);
          return;
        }
        this.m_snapModel.set(Ec.none, new Pe(0, 0, 0), h);
        let d = this.m_raycaster.intersectObject(this.m_context.SceneManager.SignModel);
        if (d.length > 0) {
          let e = d[0].object,
            t = { x: Number(d[0].point.x), y: Number(d[0].point.y), z: Number(d[0].point.z) };
          return void i(new Jh(t, d[0].distance, '', [e]));
        }
        let m = [];
        if (
          (this.m_context.SceneManager.ThreeLayer.userData.disEnable ||
            (d = this.m_raycaster.intersectObject(this.m_context.SceneManager.ThreeLayer)),
          d.forEach((e) => {
            e.object.visible && m.push(e);
          }),
          (d = m),
          d.length > 0)
        ) {
          let e = d.map((e) => e.object),
            t = { x: Number(d[0].point.x), y: Number(d[0].point.y), z: Number(d[0].point.z) };
          i(new Jh(t, d[0].distance, '', e));
        } else;
      }
      get CameraRay() {
        return this.m_raycaster;
      }
      distanceSqLineToPoint(e, t, i) {
        let n = t.clone().sub(e),
          s = i.clone().sub(e),
          r = n.dot(s) / n.lengthSq();
        return r < 0
          ? s.lengthSq()
          : r > 1
          ? i.clone().sub(t).lengthSq()
          : i
              .clone()
              .sub(e.clone().add(n.clone().multiplyScalar(r)))
              .lengthSq();
      }
      Pick(e, t, i = !1) {
        (this.m_context.Dom.style.cursor = 'crosshair'), (this.multiSelect = !0), (this.isSingleSelect = i);
        let n = [];
        if (t)
          for (let e in this.m_context.ModelManager.LayerTable) {
            (this.m_context.ModelManager.LayerTable[e].Id = t) && n.push(t);
          }
        (this.pick = (t) => {
          let i = [];
          this.selectionDataArr.forEach((e, n) => {
            t.entity instanceof fc &&
              (t.entity.root_reference_id
                ? e.entity.root_reference_id == t.entity.root_reference_id && i.push(n)
                : e.entity.id + e.entity.block_path == t.entity.id + t.entity.block_path && i.push(n));
          }),
            i.length > 0 ? this.selectionDataArr.splice(i[0], 1) : this.selectionDataArr.push(t),
            (this.selectData = [...this.selectionDataArr]),
            Array.isArray(this.selectData) && 1 == this.selectData.length && (this.selectData = this.selectData[0]),
            e(this.selectData) ||
              (this.selectionData = Object.assign(Object.assign({}, t), { entity: Object.assign({}, t.entity) }));
        }),
          this.m_eventManager.addEventListener(iu.Pick, this.pick),
          (this.m_selectionState = tu.Pick);
      }
      clearSelection() {
        this.moveLineSelect.forEach((e) => {
          e.material.dispose(), e.geometry.dispose(), this.m_context.SceneManager.ModelLayer.remove(e);
        }),
          this.moveMeshSelect.forEach((e) => {
            if (e instanceof wi) {
              e.material.dispose(), e.geometry.dispose(), this.m_context.SceneManager.ModelLayer.remove(e);
            }
          }),
          (this.moveDbLines.length = 0),
          (this.moveLineSelect.length = 0),
          (this.moverDbMesh.length = 0),
          (this.moveMeshSelect.length = 0);
      }
      clearSelectFn() {
        this.moveLineSelect.forEach((e) => {
          if ('activeLine' == e.name) {
            e.material.dispose(), e.geometry.dispose(), this.m_context.SceneManager.ModelLayer.remove(e);
          }
          if (e instanceof _a || 'moveLine' == e.name) {
            e.material.dispose(), e.geometry.dispose(), this.m_context.SceneManager.ModelLayer.remove(e);
          }
        }),
          this.moveMeshSelect.forEach((e) => {
            if (e instanceof wi) {
              e.material.dispose(), e.geometry.dispose(), this.m_context.SceneManager.ModelLayer.remove(e);
            }
          });
        for (const e in this.linesModelsAll)
          this.moveDbLines.forEach((t, i) => {
            t.key == e && this.linesModelsAll[e].lines.push(t.line);
          }),
            this.linesToModel(this.linesModelsAll[e].lines, this.linesModelsAll[e].model);
        for (const e in this.meshsModelsAll)
          this.meshsModelsAll[e].meshs.length > 0
            ? this.meshsModelsAll[e].meshs.forEach((t, i) => {
                this.moverDbMesh.forEach((t, i) => {
                  t.key == e &&
                    (this.meshsModelsAll[e].meshs.includes(t.mesh) || this.meshsModelsAll[e].meshs.push(t.mesh));
                });
              })
            : this.moverDbMesh.forEach((t, i) => {
                t.key == e &&
                  (this.meshsModelsAll[e].meshs.includes(t.mesh) || this.meshsModelsAll[e].meshs.push(t.mesh));
              }),
            this.MeshToModel(this.meshsModelsAll[e].meshs, this.meshsModelsAll[e].model);
        (this.moveDbLines.length = 0), (this.moverDbMesh.length = 0);
      }
      filtrateRootIdLineAndMesh(e) {
        this.multiSelect || this.clearSelectFn();
        for (const t in this.linesModelsAll)
          if (
            this.linesModelsAll[t] &&
            this.linesModelsAll[t].canEdit &&
            (this.linesModelsAll[t].lines.forEach((i, n) => {
              i.root_reference_id == e.root_reference_id &&
                (this.createdMoveLine(i, this.linesModelsAll[t].model.material),
                this.moveDbLines.push({ line: i, key: t }));
            }),
            this.moveDbLines.some((e) => e.key == t))
          ) {
            let e = this.moveDbLines.map((e) => e.line.root_reference_id + e.line.block_path + e.line.id);
            (this.linesModelsAll[t].lines = this.linesModelsAll[t].lines.filter((t, i) => {
              let n = t.root_reference_id + t.block_path + t.id;
              if (!e.includes(n)) return !0;
            })),
              this.linesToModel(this.linesModelsAll[t].lines, this.linesModelsAll[t].model);
          }
        for (const t in this.meshsModelsAll) {
          if (
            this.meshsModelsAll[t] &&
            this.meshsModelsAll[t].canEdit &&
            (this.meshsModelsAll[t].meshs.forEach((i, n) => {
              i.root_reference_id == e.root_reference_id &&
                (this.createdMoveMesh(i, this.meshsModelsAll[t].model.material),
                this.moverDbMesh.push({ mesh: i, key: t }));
            }),
            this.moverDbMesh.some((e) => e.key == t))
          ) {
            let e = this.moverDbMesh.map((e) => e.mesh.root_reference_id + e.mesh.block_path + e.mesh.id);
            (this.meshsModelsAll[t].meshs = this.meshsModelsAll[t].meshs.filter((t, i) => {
              let n = t.root_reference_id + t.block_path + t.id;
              return !n || !e.includes(n) || void 0;
            })),
              this.MeshToModel(this.meshsModelsAll[t].meshs, this.meshsModelsAll[t].model);
          }
          this.moveMeshSelect.forEach((e) => {
            let t = e.material.clone();
            (t.color = new ve(4906476)), (e.material = t);
          });
        }
      }
      filtrateIdAndBlockPathLineAndMesh(e) {
        this.multiSelect || this.clearSelectFn();
        for (const t in this.linesModelsAll)
          if (
            this.linesModelsAll[t] &&
            this.linesModelsAll[t].canEdit &&
            (this.linesModelsAll[t].lines.forEach((i, n) => {
              i.id == e.id &&
                i.block_path == e.block_path &&
                (this.createdMoveLine(i, this.linesModelsAll[t].model.material),
                this.moveDbLines.push({ line: i, key: t }));
            }),
            this.moveDbLines.some((e) => e.key == t))
          ) {
            let e = this.moveDbLines.map((e) => e.root_reference_id + e.line.block_path + e.line.id);
            (this.linesModelsAll[t].lines = this.linesModelsAll[t].lines.filter((t, i) => {
              let n = t.root_reference_id + t.block_path + t.id;
              if (!e.includes(n)) return !0;
            })),
              this.linesToModel(this.linesModelsAll[t].lines, this.linesModelsAll[t].model);
          }
        for (const t in this.meshsModelsAll) {
          if (
            this.meshsModelsAll[t] &&
            this.meshsModelsAll[t].canEdit &&
            (this.meshsModelsAll[t].meshs.forEach((i, n) => {
              i.block_path + i.id == e.block_path + e.id &&
                (this.createdMoveMesh(i, this.meshsModelsAll[t].model.material),
                this.moverDbMesh.push({ mesh: i, key: t }));
            }),
            this.moverDbMesh.some((e) => e.key == t))
          ) {
            let e = this.moverDbMesh.map((e) => e.root_reference_id + e.mesh.block_path + e.mesh.id);
            (this.meshsModelsAll[t].meshs = this.meshsModelsAll[t].meshs.filter((t, i) => {
              let n = t.root_reference_id + t.block_path + t.id;
              if (!e.includes(n)) return !0;
            })),
              this.MeshToModel(this.meshsModelsAll[t].meshs, this.meshsModelsAll[t].model);
          }
          this.moveMeshSelect.forEach((e) => {
            let t = e.material.clone();
            (t.color = new ve(4906476)), (e.material = t);
          });
        }
      }
      moveLineAndMeshToModel() {
        for (const e in this.linesModelsAll)
          this.linesModelsAll[e].lines.length > 0
            ? this.linesModelsAll[e].lines.forEach((t, i) => {
                this.moveDbLines.forEach((t, i) => {
                  t.key == e &&
                    (this.linesModelsAll[e].lines.includes(t.line) || this.linesModelsAll[e].lines.push(t.line));
                });
              })
            : this.moveDbLines.forEach((t, i) => {
                t.key == e &&
                  (this.linesModelsAll[e].lines.includes(t.line) || this.linesModelsAll[e].lines.push(t.line));
              }),
            this.linesModelsAll[e].model.position.set(0, 0, 0),
            this.linesToModel(this.linesModelsAll[e].lines, this.linesModelsAll[e].model);
        for (const e in this.meshsModelsAll)
          this.meshsModelsAll[e].meshs.length > 0
            ? this.meshsModelsAll[e].meshs.forEach((t, i) => {
                this.moverDbMesh.forEach((t, i) => {
                  t.key == e &&
                    (this.meshsModelsAll[e].meshs.includes(t.mesh) || this.meshsModelsAll[e].meshs.push(t.mesh));
                });
              })
            : this.moverDbMesh.forEach((t, i) => {
                t.key == e &&
                  (this.meshsModelsAll[e].meshs.includes(t.mesh) || this.meshsModelsAll[e].meshs.push(t.mesh));
              }),
            this.meshsModelsAll[e].model.position.set(0, 0, 0),
            this.MeshToModel(this.meshsModelsAll[e].meshs, this.meshsModelsAll[e].model);
      }
      StartMoveSelect(e, t, i = !0) {
        (this.startEditSelect = !0),
          (this.linesModelsAll = this.m_context.ModelManager.Lines),
          (this.meshsModelsAll = this.m_context.ModelManager.Meshs),
          (this.selcetCallBack = e),
          this.Pick(e, t, i);
      }
      createdMoveLine(e, t) {
        const i = new ai();
        i.setAttribute('position', new Zt(e.points, 3)), i.setIndex([...e.indexes]);
        const n = new _a(i, t);
        (n.startPosition = n.position.clone()),
          (n.name = 'moveLine'),
          (n.userData = { id: e.id, block_path: e.block_path, root_reference_id: e.root_reference_id }),
          this.createdActiveLine(e.points),
          this.moveLineSelect.push(n),
          this.m_context.SceneManager.ModelLayer.add(n);
      }
      createdActiveLine(e) {
        const t = new Jc();
        t.setPositions(e);
        const i = new Dc({ color: 4906476, linewidth: 1, dashed: !1 });
        i.resolution.set(window.innerWidth, window.innerHeight);
        const n = new Kc(t, i);
        (n.startPosition = n.position.clone()),
          (n.name = 'activeLine'),
          this.moveLineSelect.push(n),
          this.m_context.SceneManager.ModelLayer.add(n);
      }
      linesToModel(e, t) {
        let i = [],
          n = 0,
          s = [];
        e.forEach((e) => {
          var t;
          e.points.forEach((e) => {
            i.push(e);
          }),
            null === (t = e.indexes) ||
              void 0 === t ||
              t.forEach((e) => {
                s.push(e + n);
              }),
            (n += e.points.length / 3);
        });
        let r = new Float32Array(i),
          a = t.geometry;
        a.setAttribute('position', new Zt(r, 3)),
          a.setIndex(s),
          (a.attributes.position.needsUpdate = !0),
          a.computeBoundingBox(),
          a.computeBoundingSphere();
      }
      createdMoveMesh(e, t) {
        const i = new ai();
        i.setAttribute('position', new Zt(e.vertexs, 3));
        const n = new wi(i, t);
        (n.name = 'moveMesh'),
          (n.userData = { id: e.id, block_path: e.block_path, root_reference_id: e.root_reference_id }),
          (n.startPosition = n.position.clone()),
          this.moveMeshSelect.push(n),
          this.m_context.SceneManager.ModelLayer.add(n);
      }
      MeshToModel(e, t) {
        let i = [];
        e.forEach((e) => {
          var t;
          null === (t = e.vertexs) ||
            void 0 === t ||
            t.forEach((e) => {
              i.push(e);
            });
        });
        let n = new Float32Array(i),
          s = t.geometry;
        s.setAttribute('position', new Zt(n, 3)),
          (s.attributes.position.needsUpdate = !0),
          s.computeBoundingBox(),
          s.computeBoundingSphere();
      }
      createdMoveLineAux() {
        const e = new ai(),
          t = new Co({
            color: 16241994,
            linewidth: 1,
            scale: 1,
            dashSize: 0.01 * this.m_context.ViewManager.Camera.position.z,
            gapSize: 0.01 * this.m_context.ViewManager.Camera.position.z,
          });
        let i = new Zt(
          new Float32Array([
            this.moveLineAuxStartPoint.x,
            this.moveLineAuxStartPoint.y,
            this.moveLineAuxStartPoint.z,
            this.moveLineAuxStartPoint.x,
            this.moveLineAuxStartPoint.y,
            this.moveLineAuxStartPoint.z,
          ]),
          3,
        );
        e.setAttribute('position', i);
        let n = new pa(e, t);
        (n.name = 'moveLineAux'),
          n.computeLineDistances(),
          this.m_context.SceneManager.ModelLayer.add(n),
          (this.moveLineAux = n);
      }
      filterSelectionData() {
        this.m_selection.clear(),
          this.selectionDataArr.length
            ? this.selectionDataArr.forEach((e) => {
                if (e.entity) {
                  let t = e.entity;
                  t.root_reference_id ? this.filtrateRootIdLineAndMesh(t) : this.filtrateIdAndBlockPathLineAndMesh(t);
                }
              })
            : this.CancelPick();
      }
      StartMoveLines() {
        (this.m_selectionState = tu.None),
          this.copyStart || this.filterSelectionData(),
          (this.moverDbMesh.length || this.moveDbLines.length) &&
            ((this.moveStart = !0),
            (this.m_context.Dom.style.cursor = 'crosshair'),
            (this.selectionData.entity = void 0));
      }
      EndMove() {
        var e;
        (this.moveLineAuxPointDownCount = 0), (this.moveStart = !1);
        let t = [];
        if (this.moveLineAux) {
          null === (e = this.moveLineAux) || void 0 === e || e.geometry.dispose(),
            this.moveLineAux.material.dispose(),
            this.m_context.SceneManager.ModelLayer.remove(this.moveLineAux),
            (this.moveLineAux = void 0);
        }
        let i = new Pe();
        this.moveLineSelect.forEach((e) => {
          if ('activeLine' == e.name) {
            e.material.dispose(), e.geometry.dispose(), this.m_context.SceneManager.ModelLayer.remove(e);
          }
          if (e instanceof _a || 'moveLine' == e.name) {
            (i = e.position.clone()),
              e.material.dispose(),
              e.geometry.dispose(),
              this.m_context.SceneManager.ModelLayer.remove(e);
          }
        }),
          this.moveDbLines.forEach((e, n) => {
            var s, r;
            if (
              (e.line.points.forEach((t, n) => {
                (n + 1) % 3 == 1 && (e.line.points[n] += i.x), (n + 1) % 3 == 2 && (e.line.points[n] += i.y);
              }),
              (this.moveDbLines[n].line.sphere.center.x =
                (null === (s = e.line.sphere) || void 0 === s ? void 0 : s.center.x) + i.x),
              (this.moveDbLines[n].line.sphere.center.y =
                (null === (r = e.line.sphere) || void 0 === r ? void 0 : r.center.y) + i.y),
              !this.copyStart)
            )
              if ('insert' === e.line.type)
                this.insertGroupPositions.forEach((t) => {
                  if (t.rootId == e.line.root_reference_id) {
                    let n = i.clone().add(t.position.clone());
                    this.m_context.ModelManager.setInstances(e.line.root_reference_id, n);
                  }
                });
              else {
                let n = this.instancePosition(e.line.root_reference_id);
                if (n) {
                  let s = n.add(i);
                  t.push({ rootId: e.line.root_reference_id, pos: s });
                }
              }
          }),
          this.moveMeshSelect.forEach((e) => {
            if (e instanceof wi) {
              (i = e.position.clone()),
                e.material.dispose(),
                e.geometry.dispose(),
                this.m_context.SceneManager.ModelLayer.remove(e);
            }
          }),
          this.moverDbMesh.forEach((e, n) => {
            var s, r, a;
            if (
              (null === (s = e.mesh.vertexs) ||
                void 0 === s ||
                s.forEach((e, t) => {
                  (t + 1) % 3 == 1 && (this.moverDbMesh[n].mesh.vertexs[t] += i.x),
                    (t + 1) % 3 == 2 && (this.moverDbMesh[n].mesh.vertexs[t] += i.y);
                }),
              (this.moverDbMesh[n].mesh.sphere.center.x =
                (null === (r = e.mesh.sphere) || void 0 === r ? void 0 : r.center.x) + i.x),
              (this.moverDbMesh[n].mesh.sphere.center.y =
                (null === (a = e.mesh.sphere) || void 0 === a ? void 0 : a.center.y) + i.y),
              !this.copyStart)
            )
              if ('insert' === e.mesh.type)
                this.insertGroupPositions.forEach((t) => {
                  if (t.rootId == e.mesh.root_reference_id) {
                    let n = i.clone().add(t.position.clone());
                    this.m_context.ModelManager.setInstances(e.mesh.root_reference_id, n);
                  }
                });
              else {
                let n = this.instancePosition(e.mesh.root_reference_id);
                if (n) {
                  let s = n.add(i);
                  t.push({ rootId: e.mesh.root_reference_id, pos: s });
                }
              }
          });
        let n = this.arrObjDeWeight(t);
        n.length &&
          n.forEach((e) => {
            this.m_context.ModelManager.setInstances(e.rootId, e.pos);
          });
        let s = [];
        Array.isArray(this.selectData)
          ? this.selectData.forEach((e, t) => {
              (e.offset = { x: i.x, y: i.y, z: i.z }),
                s.push(Object.assign({}, e)),
                (s[t].entity = Object.assign({}, e.entity));
            })
          : ((this.selectData.offset = { x: i.x, y: i.y, z: i.z }),
            (s = Object.assign({}, this.selectData)),
            (s.entity = Object.assign({}, this.selectData.entity))),
          this.copyStart
            ? ((this.copyDbLines = this.moveDbLines.map((e, t) => {
                let i = {
                  key: e.key,
                  line: new gc({
                    id: e.line.id,
                    blockId: e.line.blockId,
                    indexes: e.line.indexes,
                    layerId: e.line.layerId,
                    points: e.line.points,
                    root_block_id: e.line.root_block_id,
                  }),
                  location: { x: 0, y: 0, z: 0 },
                };
                if (
                  ((i.line.sphere = Object.assign({}, e.line.sphere)),
                  (i.line.box = Object.assign({}, e.line.box)),
                  (i.line.block_path = yc()),
                  (i.line.id = yc()),
                  e.line.root_reference_id)
                ) {
                  if (
                    ((i.line.root_reference_id = e.line.root_reference_id + this.copyCount.toString() + 'x'),
                    Array.isArray(s))
                  )
                    s.forEach((t) => {
                      t.entity.root_reference_id == e.line.root_reference_id &&
                        (t.entity.root_reference_id = i.line.root_reference_id);
                    });
                  else {
                    let t = s.entity;
                    t.root_reference_id == e.line.root_reference_id && (t.root_reference_id = i.line.root_reference_id);
                  }
                  this.m_context.ModelManager.Group[i.line.root_reference_id] ||
                    (this.m_context.ModelManager.Group[i.line.root_reference_id] = { key: e.key, lines: [], mesh: [] }),
                    this.m_context.ModelManager.Group[i.line.root_reference_id].lines.push(i.line);
                }
                return this.insertItemPosition(i, e.line.root_reference_id), i;
              })),
              this.copyDbLines.forEach((e) => {
                let t = new Pe(e.location.x, e.location.y, e.location.z).add(i.clone());
                this.m_context.ModelManager.setInstances(e.line.root_reference_id, t);
              }),
              (this.copyDbMeshs = this.moverDbMesh.map((e, t) => {
                let i = {
                  key: e.key,
                  mesh: new _c({
                    id: e.mesh.id,
                    blockId: e.mesh.blockId,
                    indexes: e.mesh.indexes,
                    layerId: e.mesh.layerId,
                    vertexs: e.mesh.vertexs,
                    root_block_id: e.mesh.root_block_id,
                  }),
                  location: { x: 0, y: 0, z: 0 },
                };
                if (
                  ((i.mesh.sphere = Object.assign({}, e.mesh.sphere)),
                  (i.mesh.box = Object.assign({}, e.mesh.box)),
                  (i.mesh.block_path = yc()),
                  (i.mesh.id = yc()),
                  (i.mesh.root_reference_id = e.mesh.root_reference_id),
                  e.mesh.root_reference_id)
                ) {
                  if (
                    ((i.mesh.root_reference_id = e.mesh.root_reference_id + this.copyCount.toString() + 'x'),
                    Array.isArray(s))
                  )
                    s.forEach((t) => {
                      t.entity.root_reference_id == e.mesh.root_reference_id &&
                        (t.entity.root_reference_id = i.mesh.root_reference_id);
                    });
                  else {
                    let t = s.entity;
                    t.root_reference_id == e.mesh.root_reference_id && (t.root_reference_id = i.mesh.root_reference_id);
                  }
                  this.m_context.ModelManager.Group[i.mesh.root_reference_id] ||
                    (this.m_context.ModelManager.Group[i.mesh.root_reference_id] = { key: e.key, lines: [], mesh: [] }),
                    this.m_context.ModelManager.Group[i.mesh.root_reference_id].mesh.push(i.mesh);
                }
                return this.insertItemPosition(i, e.mesh.root_reference_id), i;
              })),
              this.copyDbMeshs.forEach((e) => {
                let t = new Pe(e.location.x, e.location.y, e.location.z).add(i.clone());
                this.m_context.ModelManager.setInstances(e.mesh.root_reference_id, t);
              }),
              this.copyLineAndMeshToModel(),
              this.selcetCallBack(s))
            : (this.moveLineAndMeshToModel(), this.selcetCallBack(this.selectData)),
          this.CancelPick(),
          (this.moveDbLines.length = 0),
          (this.moveLineSelect.length = 0),
          (this.moverDbMesh.length = 0),
          (this.moveMeshSelect.length = 0),
          (this.copyStart = !1),
          window.removeEventListener('wheel', this.updateDashSizeAndGapSizeBind);
      }
      arrObjDeWeight(e) {
        let t = new Map();
        for (const i of e) t.has(i.rootId) || t.set(i.rootId, i);
        return [...t.values()];
      }
      instancePosition(e) {
        let t = this.m_context.ModelManager.Instances;
        if (Object.keys(t).length)
          for (const i in t)
            for (let n = 0; n < t[i].length; n++)
              if (t[i][n].id == e) {
                let e = new Pe();
                return e.setFromMatrixPosition(t[i][n].matrix), e;
              }
      }
      insertItemPosition(e, t) {
        let i = this.m_context.ModelManager.Instances;
        if (Object.keys(i).length)
          for (const n in i)
            i[n].forEach((i) => {
              if (i.id == t) {
                let t = { x: 0, y: 0, z: 0 };
                (t.x = i.matrix.elements[12]),
                  (t.y = i.matrix.elements[13]),
                  (t.z = i.matrix.elements[14]),
                  (e.location = t);
              }
            });
      }
      updateDashSizeAndGapSize() {
        if (!this.moveLineAux) return;
        let e = this.moveLineAux.material;
        (e.dashSize = 0.01 * this.m_context.ViewManager.Camera.position.z),
          (e.gapSize = 0.01 * this.m_context.ViewManager.Camera.position.z);
      }
      DeletedSelect() {
        if (!this.startEditSelect) return;
        let e = [];
        this.m_selection.getObjects().forEach((t) => {
          t instanceof fc && e.push(t);
        }),
          this.m_context.ModelManager.DeleteEntity(...e),
          this.ClearSelected(),
          this.CancelPick();
      }
      CopySelect() {
        this.startEditSelect &&
          (this.copyCount++,
          (this.copyDbLinesOrgin.length = 0),
          (this.copyDbLines.length = 0),
          (this.copyDbMeshs.length = 0),
          (this.copyDbMeshsOrgin.length = 0),
          (this.copyStart = !0),
          this.filterSelectionData(),
          this.moveLineAndMeshToModel(),
          (this.copyDbLinesOrgin = this.copyDbLinesFn()),
          (this.copyDbMeshsOrgin = this.copyDbMeshFn()),
          this.StartMoveLines());
      }
      copyDbLinesFn() {
        return this.moveDbLines.map((e) => {
          let t = {
            key: e.key,
            line: new gc({
              id: e.line.id,
              blockId: e.line.blockId,
              indexes: e.line.indexes,
              layerId: e.line.layerId,
              points: new Float32Array([...e.line.points]),
              root_reference_id: e.line.root_reference_id,
              root_block_id: e.line.root_block_id,
            }),
          };
          return (
            (t.line.sphere = Object.assign(Object.assign({}, e.line.sphere), {
              center: Object.assign({}, e.line.sphere.center),
            })),
            (t.line.block_path = e.line.block_path),
            (t.line.box = Object.assign(Object.assign({}, e.line.box), {
              max: Object.assign({}, e.line.box.max),
              min: Object.assign({}, e.line.box.min),
            })),
            (t.line.type = e.line.type),
            t
          );
        });
      }
      copyDbMeshFn() {
        return this.moverDbMesh.map((e) => {
          let t = {
            key: e.key,
            mesh: new _c({
              id: e.mesh.id,
              blockId: e.mesh.blockId,
              layerId: e.mesh.layerId,
              indexes: e.mesh.indexes,
              vertexs: new Float32Array([...e.mesh.vertexs]),
              root_reference_id: e.mesh.root_reference_id,
              root_block_id: e.mesh.root_block_id,
            }),
          };
          return (
            (t.mesh.sphere = Object.assign(Object.assign({}, e.mesh.sphere), {
              center: Object.assign({}, e.mesh.sphere.center),
            })),
            (t.mesh.block_path = e.mesh.block_path),
            (t.mesh.box = Object.assign(Object.assign({}, e.mesh.box), {
              max: Object.assign({}, e.mesh.box.max),
              min: Object.assign({}, e.mesh.box.min),
            })),
            (t.mesh.type = e.mesh.type),
            t
          );
        });
      }
      copyLineAndMeshToModel() {
        for (const e in this.linesModelsAll)
          this.linesModelsAll[e].lines.length > 0
            ? this.linesModelsAll[e].lines.forEach((t, i) => {
                this.copyDbLines.forEach((t, i) => {
                  t.key == e &&
                    (this.linesModelsAll[e].lines.includes(t.line) || this.linesModelsAll[e].lines.push(t.line));
                }),
                  this.copyDbLinesOrgin.forEach((i, n) => {
                    i.key == e &&
                      (this.linesModelsAll[e].lines.includes(i.line) || this.linesModelsAll[e].lines.push(i.line),
                      t.root_reference_id && i.line.root_reference_id
                        ? (this.linesModelsAll[e].lines = this.linesModelsAll[e].lines.filter((e) => {
                            if (e.root_reference_id !== i.line.root_reference_id) return !0;
                          }))
                        : i.line.root_reference_id ||
                          (this.linesModelsAll[e].lines = this.linesModelsAll[e].lines.filter((e) => {
                            if (e.id !== i.line.id && e.block_path !== i.line.block_path) return !0;
                          })));
                  });
              })
            : this.copyDbLines.forEach((t, i) => {
                t.key == e &&
                  (this.linesModelsAll[e].lines.includes(t.line) || this.linesModelsAll[e].lines.push(t.line));
              }),
            this.copyDbLinesOrgin.forEach((t, i) => {
              t.key == e &&
                (this.linesModelsAll[e].lines.includes(t.line) || this.linesModelsAll[e].lines.push(t.line));
            }),
            this.linesToModel(this.linesModelsAll[e].lines, this.linesModelsAll[e].model);
        for (const e in this.meshsModelsAll)
          this.meshsModelsAll[e].meshs.length > 0
            ? this.meshsModelsAll[e].meshs.forEach((t, i) => {
                this.copyDbMeshs.forEach((t, i) => {
                  t.key == e &&
                    (this.meshsModelsAll[e].meshs.includes(t.mesh) || this.meshsModelsAll[e].meshs.push(t.mesh));
                }),
                  this.copyDbMeshsOrgin.forEach((i, n) => {
                    i.key == e &&
                      (this.meshsModelsAll[e].meshs.includes(i.mesh) || this.meshsModelsAll[e].meshs.push(i.mesh),
                      t.root_reference_id && i.mesh.root_reference_id
                        ? (this.meshsModelsAll[e].meshs = this.meshsModelsAll[e].meshs.filter((e) => {
                            if (e.root_reference_id !== i.mesh.root_reference_id) return !0;
                          }))
                        : (this.meshsModelsAll[e].meshs = this.meshsModelsAll[e].meshs.filter((e) => {
                            if (e.id !== i.mesh.id && e.block_path !== i.mesh.block_path) return !0;
                          })));
                  });
              })
            : this.copyDbMeshs.forEach((t, i) => {
                t.key == e &&
                  (this.meshsModelsAll[e].meshs.includes(t.mesh) || this.meshsModelsAll[e].meshs.push(t.mesh));
              }),
            this.copyDbMeshsOrgin.forEach((t, i) => {
              t.key == e &&
                (this.meshsModelsAll[e].meshs.includes(t.mesh) || this.meshsModelsAll[e].meshs.push(t.mesh));
            }),
            this.MeshToModel(this.meshsModelsAll[e].meshs, this.meshsModelsAll[e].model);
        this.copyDbLinesOrgin.forEach((e) => {
          this.m_context.ModelManager.Group[e.line.root_reference_id] &&
            (this.m_context.ModelManager.Group[e.line.root_reference_id].lines = this.copyDbLinesOrgin
              .filter((t) => {
                if (t.line.root_reference_id == e.line.root_reference_id) return !0;
              })
              .map((e) => e.line));
        }),
          this.copyDbMeshsOrgin.forEach((e) => {
            this.m_context.ModelManager.Group[e.mesh.root_reference_id] &&
              (this.m_context.ModelManager.Group[e.mesh.root_reference_id].mesh = this.copyDbMeshsOrgin
                .filter((t) => {
                  if (t.mesh.root_reference_id == e.mesh.root_reference_id) return !0;
                })
                .map((e) => e.mesh));
          });
      }
      InsertFile(e, t, i = !1, n = 1, s) {
        (this.insertFile = e),
          (this.insertFileScale = n),
          (this.isInsertContinuous = i),
          (this.m_context.ModelManager.isInsert = !0),
          (this.isInsertFile = !0),
          (this.insertFileRotate = 0),
          (this.insertGroup = this.m_context.SceneManager.ModelLayer.getObjectByName('insertGroup')),
          this.insertGroup
            ? (this.insertGroup.children.forEach((e) => {
                this.m_context.SceneManager.ModelLayer.remove(e);
              }),
              (this.insertGroup.children.length = 0),
              (this.insertGeos.lines = {}),
              (this.insertGeos.meshs = {}),
              (this.insertRootId = ''),
              this.m_context.ViewManager.Render())
            : (this.m_context.ModelManager.addInsertGroup(),
              (this.insertGroup = this.m_context.SceneManager.ModelLayer.getObjectByName('insertGroup'))),
          this.m_context.LoadManager.LoadBlockP2d(e.url, !0, () => {
            (this.m_context.Dom.style.cursor = 'crosshair'),
              (this.insertGroup.visible = !0),
              (this.insertFileComplete = !0),
              (this.insertMangerCount = 1),
              (this.insertCallback = t),
              (this.isInsertManger = s),
              this.insertGeoSetScale(),
              this.insertDataSetScale(),
              (this.insertFileRotateOffsetArr.length = 0);
          });
      }
      insertGeoSetScale() {
        this.insertGroup &&
          this.insertGroup.traverse((e) => {
            (e instanceof wi || e instanceof _a) &&
              e.geometry.scale(this.insertFileScale, this.insertFileScale, this.insertFileScale);
          });
      }
      insertDataSetScale() {
        this.insertGeos = this.m_context.ModelManager.insertGeos;
        for (const e in this.insertGeos.lines)
          this.insertGeos.lines[e].lines.forEach((e) => {
            let t = [...e.points];
            t.forEach((e, i) => {
              (i + 1) % 3 != 0 && (t[i] *= this.insertFileScale);
            }),
              (e.points = new Float32Array(t));
          });
        for (const e in this.insertGeos.meshs)
          this.insertGeos.meshs[e].meshs.forEach((e) => {
            let t = [...e.vertexs];
            t.forEach((e, i) => {
              (i + 1) % 3 != 0 && (t[i] *= this.insertFileScale);
            }),
              (e.vertexs = new Float32Array(t));
          });
      }
      InsetFileEnd(e = !1) {
        if (((this.insertFileComplete = !1), (this.insertMangerCount = 0), e))
          return (
            this.insertGroup.children.forEach((e) => {
              this.m_context.SceneManager.ModelLayer.remove(e);
            }),
            (this.insertGroup.children.length = 0),
            (this.insertGeos.lines = {}),
            (this.insertGeos.meshs = {}),
            (this.insertRootId = ''),
            this.m_context.ViewManager.Render(),
            (this.isInsertFile = this.m_context.ModelManager.isInsert = !1),
            void (this.insertGroup.visible = !1)
          );
        this.InsertFilePositions &&
          this.InsertFilePositions.length &&
          this.insertGroup.position.set(
            this.InsertFilePositions[this.InsertFileToPositionNum].x,
            this.InsertFilePositions[this.InsertFileToPositionNum].y,
            this.InsertFilePositions[this.InsertFileToPositionNum].z,
          );
        let t = this.insertGroup.position.clone(),
          i = new ot();
        i.compose(
          t,
          new Ce().setFromAxisAngle(new Pe(0, 0, 1), this.insertFileRotate),
          new Pe(this.insertFileScale, this.insertFileScale, this.insertFileScale),
        );
        const n = () => {
          this.insertCallback(t, this.m_selection.getObjects(), this.m_raycaster, i).then(
            ({ isInsert: e, rootId: i }) => {
              if (!e)
                return (
                  this.insertGroup.children.forEach((e) => {
                    (e instanceof wi || e instanceof _a) &&
                      (e.geometry.dispose(), e.material.dispose(), e.removeFromParent());
                  }),
                  (this.insertGroup.children.length = 0),
                  (this.insertGeos.lines = {}),
                  void (this.insertGeos.meshs = {})
                );
              (this.insertRootId = i.toString()),
                this.insertLineAndMeshToModel(t),
                this.insertFileRotateOffsetArr.length &&
                  ((t.x += this.insertFileRotateOffsetArr[0].x),
                  (t.y += this.insertFileRotateOffsetArr[0].y),
                  (t.z += this.insertFileRotateOffsetArr[0].z)),
                this.m_context.ModelManager.setInstances(this.insertRootId, t);
              for (const e in this.insertGeos.lines) {
                let t = this.insertGeos.lines[e].lines.length;
                for (let n = this.linesModelsAll[e].lines.length - t; n < this.linesModelsAll[e].lines.length; n++)
                  this.linesModelsAll[e].lines[n].root_reference_id = i;
                this.addRootReferenceId(this.insertRootId, e, this.insertGeos.lines[e], 'lines');
              }
              for (const e in this.insertGeos.meshs) {
                let t = this.insertGeos.meshs[e].meshs.length;
                for (let n = this.meshsModelsAll[e].meshs.length - t; n < this.meshsModelsAll[e].meshs.length; n++)
                  this.meshsModelsAll[e].meshs[n].root_reference_id = i;
                this.addRootReferenceId(this.insertRootId, e, this.insertGeos.meshs[e], 'meshs');
              }
              if (
                (this.insertGroupPositions.push({ rootId: this.insertRootId, position: t }),
                this.isInsertContinuous ||
                  ((this.isInsertFile = this.m_context.ModelManager.isInsert = !1), (this.insertGroup.visible = !1)),
                (this.insertGeos.lines = {}),
                (this.insertGeos.meshs = {}),
                this.InsertFilePositions && this.InsertFilePositions.length)
              )
                if ((this.InsertFileToPositionNum++, this.InsertFileToPositionNum < this.InsertFilePositions.length)) {
                  this.isInsertFile = this.m_context.ModelManager.isInsert = !0;
                  for (const e in this.insertGeosCopy.lines) {
                    let t = {};
                    (t[e] = this.insertGeosCopy.lines[e].lines.map((e) => {
                      let t = new gc({
                        id: yc(),
                        blockId: e.blockId,
                        indexes: e.indexes,
                        layerId: e.layerId,
                        points: new Float32Array([...e.points]),
                        root_reference_id: e.root_reference_id,
                        root_block_id: e.root_block_id,
                      });
                      return (
                        (t.sphere = Object.assign(Object.assign({}, e.sphere), {
                          center: Object.assign({}, e.sphere.center),
                        })),
                        (t.block_path = yc()),
                        (t.box = Object.assign(Object.assign({}, e.box), {
                          max: Object.assign({}, e.box.max),
                          min: Object.assign({}, e.box.min),
                        })),
                        (t.type = e.type),
                        t
                      );
                    })),
                      this.m_context.ModelManager.addlines(t, this.insertGeosCopy.lines[e].canEdit);
                  }
                  for (const e in this.insertGeosCopy.meshs) {
                    let t = {};
                    (t[e] = this.insertGeosCopy.meshs[e].meshs.map((e) => {
                      let t = new _c({
                        id: e.id,
                        blockId: e.blockId,
                        layerId: e.layerId,
                        indexes: e.indexes,
                        vertexs: new Float32Array([...e.vertexs]),
                        root_reference_id: e.root_reference_id,
                        root_block_id: e.root_block_id,
                      });
                      return (
                        (t.sphere = Object.assign(Object.assign({}, e.sphere), {
                          center: Object.assign({}, e.sphere.center),
                        })),
                        (t.block_path = e.block_path),
                        (t.box = Object.assign(Object.assign({}, e.box), {
                          max: Object.assign({}, e.box.max),
                          min: Object.assign({}, e.box.min),
                        })),
                        (t.type = e.type),
                        t
                      );
                    })),
                      this.m_context.ModelManager.addMeshs(t, this.insertGeosCopy.meshs[e].canEdit);
                  }
                  this.InsetFileEnd();
                } else
                  (this.InsertFilePositions.length = 0),
                    this.CloseContinuousInsert(),
                    (this.insertGeos.lines = {}),
                    (this.insertGeos.meshs = {}),
                    (this.insertGeosCopy.lines = {}),
                    (this.insertGeosCopy.meshs = {}),
                    (this.isInsertFile = this.m_context.ModelManager.isInsert = !1),
                    this.insertFileToPositionEndCallBack();
              (this.insertRootId = ''),
                this.isInsertContinuous &&
                  this.InsertFile(this.insertFile, this.insertCallback, !0, this.insertFileScale, this.isInsertManger);
            },
          );
        };
        this.isInsertManger ? this.isInsertManger(n) : n();
      }
      InsertFileToPosition(e, t, i, n = 1, s) {
        this.isMultipleInsert &&
          ((this.insertFileToPositionEndCallBack = s),
          (this.InsertFileToPositionNum = 0),
          (this.insertCallback = t),
          (this.isInsertContinuous = !1),
          (this.InsertFilePositions = i),
          (this.multipleFile = e),
          (this.insertFileScale = n),
          this.multipleInsertFile());
      }
      multipleInsertFile() {
        (this.isInsertFile = this.m_context.ModelManager.isInsert = !0),
          (this.insertGroup = this.m_context.SceneManager.ModelLayer.getObjectByName('insertGroup')),
          (this.insertGeos = this.m_context.ModelManager.insertGeos),
          this.insertGroup ||
            (this.m_context.ModelManager.addInsertGroup(),
            (this.insertGroup = this.m_context.SceneManager.ModelLayer.getObjectByName('insertGroup')),
            (this.insertGeos = this.m_context.ModelManager.insertGeos)),
          this.m_context.LoadManager.LoadBlockP2d(this.multipleFile.url, !0, () => {
            (this.m_context.Dom.style.cursor = 'crosshair'),
              (this.insertGroup.visible = !0),
              (this.insertFileComplete = !0),
              this.insertGeoSetScale(),
              this.insertDataSetScale(),
              this.copyInsertGeosFn(this.insertGeos, this.insertGeosCopy),
              this.InsetFileEnd();
          });
      }
      copyInsertGeosFn(e, t, i) {
        for (const n in e.lines)
          (t.lines[n] = Object.assign({}, e.lines[n])),
            (t.lines[n].lines = e.lines[n].lines.map((e) => {
              let t = new gc({
                id: e.id,
                blockId: e.blockId,
                indexes: e.indexes,
                layerId: e.layerId,
                points: new Float32Array([...e.points]),
                root_block_id: e.root_block_id,
              });
              return (
                (t.sphere = Object.assign(Object.assign({}, e.sphere), { center: Object.assign({}, e.sphere.center) })),
                (t.block_path = e.block_path),
                (t.box = Object.assign(Object.assign({}, e.box), {
                  max: Object.assign({}, e.box.max),
                  min: Object.assign({}, e.box.min),
                })),
                (t.root_reference_id = i || e.root_reference_id),
                (t.type = e.type),
                t
              );
            }));
        for (const n in e.meshs)
          (t.meshs[n] = Object.assign({}, e.meshs[n])),
            (t.meshs[n].meshs = e.meshs[n].meshs.map((e) => {
              let t = new _c({
                id: e.id,
                blockId: e.blockId,
                layerId: e.layerId,
                indexes: e.indexes,
                vertexs: new Float32Array([...e.vertexs]),
                root_block_id: e.root_block_id,
              });
              return (
                (t.sphere = Object.assign(Object.assign({}, e.sphere), { center: Object.assign({}, e.sphere.center) })),
                (t.block_path = e.block_path),
                (t.box = Object.assign(Object.assign({}, e.box), {
                  max: Object.assign({}, e.box.max),
                  min: Object.assign({}, e.box.min),
                })),
                (t.root_reference_id = i || e.root_reference_id),
                (t.type = e.type),
                t
              );
            }));
      }
      CloseContinuousInsert() {
        (this.isInsertContinuous = !1),
          this.InsetFileEnd(!0),
          (this.m_context.Dom.style.cursor = 'default'),
          (this.isMultipleInsert = !1);
      }
      insertLineAndMeshToModel(e) {
        this.insertGroup.traverse((e) => {
          (e instanceof wi || e instanceof _a || e instanceof oa) && (e.name = 'insert');
        }),
          this.insertGroup.children.forEach((e) => {
            (e.parent = this.m_context.SceneManager.ModelLayer), this.m_context.SceneManager.ModelLayer.add(e);
          }),
          this.emptyInsertGroup(),
          this.m_context.SceneManager.ModelLayer.traverse((t) => {
            if ('insert' == t.name && (t instanceof wi || t instanceof _a || t instanceof oa)) {
              let i = t.geometry.attributes.position.array;
              if (i.length > 0) {
                for (let t = 0; t < i.length; t++) (t + 1) % 3 == 1 && (i[t] += e.x), (t + 1) % 3 == 2 && (i[t] += e.y);
                (t.geometry.attributes.position.needsUpdate = !0),
                  t.geometry.computeBoundingBox(),
                  t.geometry.computeBoundingSphere(),
                  (t.name = '');
              }
            }
          });
        for (const t in this.insertGeos.lines)
          this.insertGeos.lines[t].lines.forEach((i) => {
            this.insertGeos.lines[t].canEdit &&
              (i.points.forEach((t, n) => {
                (n + 1) % 3 == 1 && (i.points[n] += e.x), (n + 1) % 3 == 2 && (i.points[n] += e.y);
              }),
              (i.type = 'insert'),
              (i.sphere.center.x += e.x),
              (i.sphere.center.y += e.y));
          });
        for (const t in this.insertGeos.meshs)
          this.insertGeos.meshs[t].meshs.forEach((i) => {
            var n;
            this.insertGeos.meshs[t].canEdit &&
              (null === (n = i.vertexs) ||
                void 0 === n ||
                n.forEach((t, n) => {
                  (n + 1) % 3 == 1 && (i.vertexs[n] += e.x), (n + 1) % 3 == 2 && (i.vertexs[n] += e.y);
                }),
              (i.type = 'insert'),
              (i.sphere.center.x += e.x),
              (i.sphere.center.y += e.y));
          });
        this.insertFileToSumData();
      }
      emptyInsertGroup() {
        this.insertGroup.traverse((e) => {
          (e instanceof wi || e instanceof _a || e instanceof oa) && (e.geometry.dispose(), e.material.dispose());
        }),
          (this.insertGroup.children.length = 0);
      }
      addRootReferenceId(e, t, i, n = 'lines') {
        switch (
          (this.m_context.ModelManager.Group[e] ||
            (this.m_context.ModelManager.Group[e] = { key: t, lines: [], mesh: [] }),
          n)
        ) {
          case 'lines':
            this.m_context.ModelManager.Group[e].lines.push(...i.lines);
            break;
          case 'meshs':
            this.m_context.ModelManager.Group[e].mesh.push(...i.meshs);
        }
      }
      insertFileToSumData() {
        (this.linesModelsAll = this.m_context.ModelManager.Lines),
          (this.meshsModelsAll = this.m_context.ModelManager.Meshs);
        let e = Object.keys(this.linesModelsAll),
          t = Object.keys(this.insertGeos.lines),
          i = Object.keys(this.meshsModelsAll),
          n = Object.keys(this.insertGeos.meshs);
        t.length &&
          t.forEach((t) => {
            if (e.includes(t)) {
              if (
                (this.linesModelsAll[t].lines.push(...this.insertGeos.lines[t].lines),
                this.isInsertFile || this.isReplaceFile)
              ) {
                let e = Qc([this.linesModelsAll[t].model.geometry, this.insertGeos.lines[t].model.geometry]);
                (this.linesModelsAll[t].model.geometry = e),
                  this.m_context.SceneManager.ModelLayer.remove(this.insertGeos.lines[t].model);
              }
            } else this.linesModelsAll[t] = this.insertGeos.lines[t];
          }),
          n.length &&
            n.forEach((e) => {
              if (i.includes(e)) {
                if (
                  (this.meshsModelsAll[e].meshs.push(...this.insertGeos.meshs[e].meshs),
                  this.isInsertFile || this.isReplaceFile)
                ) {
                  let t = Qc([this.meshsModelsAll[e].model.geometry, this.insertGeos.meshs[e].model.geometry]);
                  (this.meshsModelsAll[e].model.geometry = t),
                    this.m_context.SceneManager.ModelLayer.remove(this.insertGeos.meshs[e].model);
                }
              } else this.meshsModelsAll[e] = this.insertGeos.meshs[e];
            });
        let s = yc(),
          r = [];
        for (const e in this.insertGeos.lines)
          this.insertGeos.lines[e].lines.forEach((t) => {
            this.insertGeos.lines[e].canEdit &&
              (this.m_context.ModelManager.Group[t.root_reference_id] && r.push(t.root_reference_id),
              (t.root_reference_id = s));
          }),
            this.addRootReferenceId(s, e, this.insertGeos.lines[e], 'lines');
        (r = Array.from(new Set(r))),
          r.forEach((e) => {
            this.m_context.ModelManager.Group[e].lines.splice(this.m_context.ModelManager.Group[e].lines.length / 2);
          });
        let a = [];
        for (const e in this.insertGeos.meshs)
          this.insertGeos.meshs[e].meshs.forEach((t) => {
            this.insertGeos.meshs[e].canEdit &&
              (this.m_context.ModelManager.Group[t.root_reference_id] && a.push(t.root_reference_id),
              (t.root_reference_id = s));
          }),
            this.addRootReferenceId(s, e, this.insertGeos.meshs[e], 'meshs');
        (a = Array.from(new Set(a))),
          a.forEach((e) => {
            this.m_context.ModelManager.Group[e].mesh.splice(this.m_context.ModelManager.Group[e].mesh.length / 2);
          });
      }
      ReplaceFile(e, t, i = 1) {
        if (this.selectionDataArr.length > 1) throw new Error('');
        this.selectionData.entity || this.StartMoveSelect((e) => !1),
          (this.replaceRootId = t),
          (this.replaceFile = e),
          (this.insertFileScale = i),
          (this.m_context.Dom.style.cursor = 'crosshair'),
          (this.isReplaceFile = !0),
          (this.m_context.ModelManager.isInsert = !0);
      }
      ReplaceFileEnd() {
        if (!this.selectionData.entity || !this.isReplaceFile) return;
        this.filterSelectionData(),
          (this.insertGroup = this.m_context.SceneManager.ModelLayer.getObjectByName('insertGroup')),
          (this.insertGroup.visible = !0),
          this.insertGeoSetScale(),
          this.insertDataSetScale();
        let e = this.m_context.ModelManager.Instances,
          t = new Pe();
        for (const i in e)
          e[i].forEach((e, i) => {
            e.id == this.selectionData.entity.root_reference_id &&
              (this.insertGroup.traverse((e) => {
                (e instanceof wi || e instanceof _a || e instanceof oa) && (e.name = 'replace');
              }),
              this.insertGroup.children.forEach((e) => {
                (e.parent = this.m_context.SceneManager.ModelLayer), this.m_context.SceneManager.ModelLayer.add(e);
              }),
              this.emptyInsertGroup(),
              this.m_context.SceneManager.ModelLayer.traverse((i) => {
                if ('replace' == i.name && (i instanceof wi || i instanceof _a || i instanceof oa)) {
                  let n = new Pe(e.matrix.elements[12], e.matrix.elements[13], e.matrix.elements[14]);
                  t.copy(n);
                  let s = i.geometry.attributes.position.array;
                  if (s.length > 0)
                    for (let e = 0; e < s.length; e++)
                      (e + 1) % 3 == 1 && (s[e] += t.x), (e + 1) % 3 == 2 && (s[e] += t.y);
                  i.geometry.setAttribute(
                    'position',
                    new Zt(new Float32Array(i.geometry.attributes.position.array), 3),
                  ),
                    (i.geometry.attributes.position.needsUpdate = !0),
                    (i.name = ''),
                    i.geometry.computeBoundingBox(),
                    i.geometry.computeBoundingSphere();
                }
              }),
              this.replaceModel(t));
          });
        (this.isReplaceFile = this.m_context.ModelManager.isInsert = !1),
          (this.m_context.Dom.style.cursor = 'default'),
          (this.selectionData.entity = void 0);
      }
      replaceModel(e) {
        this.clearSelection(),
          this.isReplaceFile || (this.selectionData.entity = void 0),
          this.CancelPick(),
          (this.insertGeos = this.m_context.ModelManager.insertGeos);
        for (const t in this.insertGeos.lines)
          this.insertGeos.lines[t].lines.forEach((i) => {
            this.insertGeos.lines[t].canEdit &&
              (i.points.forEach((t, n) => {
                (n + 1) % 3 == 1 && (i.points[n] += e.x), (n + 1) % 3 == 2 && (i.points[n] += e.y);
              }),
              (i.type = 'replace'),
              (i.sphere.center.x += e.x),
              (i.sphere.center.y += e.y));
          });
        for (const t in this.insertGeos.meshs)
          this.insertGeos.meshs[t].meshs.forEach((i) => {
            var n;
            this.insertGeos.meshs[t].canEdit &&
              (null === (n = i.vertexs) ||
                void 0 === n ||
                n.forEach((t, n) => {
                  (n + 1) % 3 == 1 && (i.vertexs[n] += e.x), (n + 1) % 3 == 2 && (i.vertexs[n] += e.y);
                }),
              (i.type = 'replace'),
              (i.sphere.center.x += e.x),
              (i.sphere.center.y += e.y));
          });
        this.insertFileToSumData(),
          (this.insertGeos.lines = {}),
          (this.insertGeos.meshs = {}),
          (this.insertGroup.visible = !1);
      }
      RotateSelect() {
        this.filterSelectionData(),
          this.CancelPick(),
          (this.moverDbMesh.length || this.moveDbLines.length) &&
            ((this.startEditSelect = !1), (this.rotateStart = !0), (this.m_context.Dom.style.cursor = 'crosshair'));
      }
      EndRotate() {
        var e;
        if (((this.moveLineAuxPointDownCount = 0), (this.rotateStart = !1), this.moveLineAux)) {
          null === (e = this.moveLineAux) || void 0 === e || e.geometry.dispose(),
            this.moveLineAux.material.dispose(),
            this.m_context.SceneManager.ModelLayer.remove(this.moveLineAux),
            (this.moveLineAux = void 0);
        }
        (this.m_context.Dom.style.cursor = 'default'),
          this.moveLineSelect.forEach((e, t) => {
            if ('activeLine' == e.name) {
              e.material.dispose(), e.geometry.dispose(), this.m_context.SceneManager.ModelLayer.remove(e);
            }
            if (e instanceof _a || 'moveLine' == e.name) {
              if (e.userData.root_reference_id)
                if (Array.isArray(this.selectData))
                  for (let t = 0; t < this.selectData.length; t++) {
                    let i = this.selectData[t].entity;
                    if (
                      i.root_reference_id + i.id + i.block_path ==
                      e.userData.root_reference_id + e.userData.id + e.userData.block_path
                    ) {
                      let n = this.instancePosition(e.userData.root_reference_id),
                        s = e.geometry.boundingSphere.center.x - i.sphere.center.x,
                        r = e.geometry.boundingSphere.center.y - i.sphere.center.y,
                        a = new Pe(s, r, 0),
                        o = new Pe();
                      (this.selectData[t].offset = { x: a.x, y: a.y, z: 0 }),
                        o.addVectors(n, a),
                        this.m_context.ModelManager.setInstances(e.userData.root_reference_id.toString(), o);
                    }
                  }
                else {
                  let t = this.selectData.entity;
                  if (
                    t.root_reference_id + t.id + t.block_path ==
                    e.userData.root_reference_id + e.userData.id + e.userData.block_path
                  ) {
                    let i = this.instancePosition(e.userData.root_reference_id),
                      n = e.geometry.boundingSphere.center.x - t.sphere.center.x,
                      s = e.geometry.boundingSphere.center.y - t.sphere.center.y,
                      r = new Pe(n, s, 0),
                      a = new Pe();
                    (this.selectData.offset = { x: r.x, y: r.y, z: 0 }),
                      a.addVectors(i, r),
                      this.m_context.ModelManager.setInstances(e.userData.root_reference_id.toString(), a);
                  }
                }
              (this.moveDbLines[(t + 1) / 2 - 1].line.points = e.geometry.attributes.position.array),
                (this.moveDbLines[(t + 1) / 2 - 1].line.sphere.center = {
                  x: e.geometry.boundingSphere.center.x,
                  y: e.geometry.boundingSphere.center.y,
                  z: e.geometry.boundingSphere.center.z,
                }),
                (this.moveDbLines[(t + 1) / 2 - 1].line.sphere.radius = e.geometry.boundingSphere.radius),
                e.material.dispose(),
                e.geometry.dispose(),
                this.m_context.SceneManager.ModelLayer.remove(e);
            }
          }),
          this.moveMeshSelect.forEach((e, t) => {
            if (e instanceof wi) {
              if (e.userData.root_reference_id)
                if (Array.isArray(this.selectData))
                  for (let t = 0; t < this.selectData.length; t++) {
                    let i = this.selectData[t].entity;
                    if (
                      i.root_reference_id + i.id + i.block_path ==
                      e.userData.root_reference_id + e.userData.id + e.userData.block_path
                    ) {
                      let n = this.instancePosition(e.userData.root_reference_id),
                        s = e.geometry.boundingSphere.center.x - i.sphere.center.x,
                        r = e.geometry.boundingSphere.center.y - i.sphere.center.y,
                        a = new Pe(s, r, 0),
                        o = new Pe();
                      (this.selectData[t].offset = { x: a.x, y: a.y, z: 0 }),
                        o.addVectors(n, a),
                        this.m_context.ModelManager.setInstances(e.userData.root_reference_id.toString(), o);
                    }
                  }
                else {
                  let t = this.selectData.entity;
                  if (
                    t.root_reference_id + t.id + t.block_path ==
                    e.userData.root_reference_id + e.userData.id + e.userData.block_path
                  ) {
                    let i = this.instancePosition(e.userData.root_reference_id),
                      n = e.geometry.boundingSphere.center.x - t.sphere.center.x,
                      s = e.geometry.boundingSphere.center.y - t.sphere.center.y,
                      r = new Pe(n, s, 0),
                      a = new Pe();
                    (this.selectData.offset = { x: r.x, y: r.y, z: 0 }),
                      a.addVectors(i, r),
                      this.m_context.ModelManager.setInstances(e.userData.root_reference_id.toString(), a);
                  }
                }
              (this.moverDbMesh[t].mesh.vertexs = e.geometry.attributes.position.array),
                (this.moverDbMesh[t].mesh.sphere.center = {
                  x: e.geometry.boundingSphere.center.x,
                  y: e.geometry.boundingSphere.center.y,
                  z: 0,
                }),
                (this.moverDbMesh[t].mesh.sphere.radius = e.geometry.boundingSphere.radius),
                e.material.dispose(),
                e.geometry.dispose(),
                this.m_context.SceneManager.ModelLayer.remove(e);
            }
          }),
          this.selcetCallBack(this.selectData),
          this.moveLineAndMeshToModel(),
          (this.moveDbLines.length = 0),
          (this.moveLineSelect.length = 0),
          (this.moverDbMesh.length = 0),
          (this.moveMeshSelect.length = 0),
          (this.selectionDataArr.length = 0),
          (this.selectionData.entity = void 0);
      }
      ResetState(e) {
        switch ((this.ClearSelected(), this.CancelPick(), this.CloseState(e), e)) {
          case 'move':
            (this.copyStart = !1), (this.isInsertFile = !1), (this.isReplaceFile = !1), (this.rotateStart = !1);
            break;
          case 'delate':
            (this.copyStart = !1),
              (this.moveStart = !1),
              (this.isInsertFile = !1),
              (this.isReplaceFile = !1),
              (this.rotateStart = !1);
            break;
          case 'copy':
            (this.moveStart = !1), (this.isInsertFile = !1), (this.isReplaceFile = !1), (this.rotateStart = !1);
            break;
          case 'insert':
            (this.copyStart = !1), (this.moveStart = !1), (this.isReplaceFile = !1), (this.rotateStart = !1);
            break;
          case 'replace':
            (this.moveStart = !1), (this.isInsertFile = !1), (this.copyStart = !1), (this.rotateStart = !1);
            break;
          case 'rotate':
            (this.moveStart = !1), (this.isInsertFile = !1), (this.copyStart = !1), (this.isReplaceFile = !1);
        }
        (this.startEditSelect = !1), this.m_context.ViewManager.Render();
      }
      CloseState(e) {
        switch (e) {
          case 'move':
            this.isInsertFile && this.CloseContinuousInsert(),
              this.copyStart && this.clearSelection(),
              this.isReplaceFile && this.emptyInsertGroup(),
              this.rotateStart && this.EndRotate();
            break;
          case 'delate':
            this.isInsertFile && this.CloseContinuousInsert(),
              this.isReplaceFile && this.emptyInsertGroup(),
              this.copyStart && this.clearSelection(),
              this.moveStart && !this.copyStart && this.EndMove(),
              this.rotateStart && this.EndRotate();
            break;
          case 'copy':
            this.isInsertFile && this.CloseContinuousInsert(),
              this.moveStart && this.EndMove(),
              this.isReplaceFile && this.emptyInsertGroup(),
              this.rotateStart && this.EndRotate();
            break;
          case 'insert':
            this.moveStart && !this.copyStart && this.EndMove(),
              this.copyStart && this.clearSelection(),
              this.isReplaceFile && this.emptyInsertGroup(),
              this.rotateStart && this.EndRotate();
            break;
          case 'replace':
            this.isInsertFile && this.CloseContinuousInsert(),
              this.moveStart && !this.copyStart && this.EndMove(),
              this.copyStart && this.clearSelection(),
              this.rotateStart && this.EndRotate();
            break;
          case 'rotate':
            this.isInsertFile && this.CloseContinuousInsert(),
              this.moveStart && !this.copyStart && this.EndMove(),
              this.copyStart && this.clearSelection(),
              this.isReplaceFile && this.emptyInsertGroup();
        }
      }
      SelectAll() {
        let e = [];
        return (
          this.m_context.SceneManager.ThreeLayer.children.forEach((t) => {
            t instanceof wi && t.userData.id && e.push(t);
          }),
          this.ClearSelected(),
          this.m_selection.addObjects(...e),
          e.map((e) => e.userData.id)
        );
      }
      CancelPick() {
        this.m_eventManager.ClearListener(iu.Pick),
          (this.selectionDataArr.length = 0),
          (this.m_selectionState = tu.None),
          (this.m_context.Dom.style.cursor = ''),
          (this.m_enableShift = !1),
          (this.multiSelect = !1),
          this.m_context.ViewManager.Render();
      }
      PickRectangle(e) {
        let t = (i, n) => {
          e(i, n) ||
            (this.m_eventManager.removeEventListener(iu.SelectionBox, t),
            (this.m_selectionState = tu.None),
            this.cancelSelectBox());
        };
        this.m_eventManager.addEventListener(iu.SelectionBox, t),
          (this.m_selectionState = tu.SelectionBox),
          this.OpenSelectBox();
      }
      PlaceEntity(e, t, i) {}
      PlaceSign(e, t, i, n, s = () => !0) {
        let r = Yh.GetScale(this.m_context.ViewManager.Camera, this.m_context.Dom.offsetHeight),
          a = new $o(),
          o = new Cr({ map: a.load(e) });
        (this.m_paceObject = new Hr(o)),
          this.m_paceObject.scale.set(t * r, i * r, 1),
          (this.m_paceObject.userData.scale = { x: t, y: i, z: 1 }),
          this.m_context.SceneManager.AuxModel.add(this.m_paceObject);
        let l = (e) => {
          var t;
          if (
            (n(e) ||
              (this.m_eventManager.removeEventListener(iu.Place, l),
              (this.m_selectionState = tu.None),
              this.m_paceObject &&
                (this.m_context.SceneManager.AuxModel.remove(this.m_paceObject), ec(this.m_paceObject)),
              this.CancelPlaceSign()),
            this.m_paceObject)
          ) {
            let i = Yh.GetScale(this.m_context.ViewManager.Camera, this.m_context.Dom.offsetHeight),
              n = this.m_paceObject.userData.scale;
            null === (t = this.m_paceObject) || void 0 === t || t.scale.set(n.x * i, n.y * i, 1);
            let s = e.place.entity.userData.scale;
            e.place.entity.scale.set(s.x * i, s.y * i, 1);
          }
        };
        this.m_eventManager.addEventListener(iu.Place, l),
          (this.m_selectionState = tu.Place),
          (this.PlaceBeforeCallBack = s);
      }
      DrawLine(e) {
        this.stopDrawLine(),
          this.clearPointLine(),
          (this.drawlineEve = (t) => {
            e(t) ||
              (this.m_eventManager.removeEventListener(iu.drawline, this.drawlineEve),
              (this.m_selectionState = tu.None));
          }),
          this.m_eventManager.addEventListener(iu.drawline, this.drawlineEve),
          (this.m_selectionState = tu.drawline);
      }
      get PlaceObject() {
        return this.m_paceObject;
      }
      CancelPlaceSign() {
        this.m_eventManager.ClearListener(iu.Place),
          this.m_paceObject && this.m_context.SceneManager.AuxModel.remove(this.m_paceObject),
          (this.m_selectionState = tu.None);
      }
      ClearSelected() {
        this.m_selection.clear();
      }
      GetSelected() {
        return this.m_selection.getObjects();
      }
      RemoveSelect(e) {
        this.m_selection.clearObj(e);
      }
      GetPointByScreenXY(e, t) {
        const i = (e / this.m_context.Dom.clientWidth) * 2 - 1,
          n = (-t / this.m_context.Dom.clientHeight) * 2 + 1;
        this.m_raycaster.setFromCamera(new se(i, n), this.m_context.ViewManager.Camera);
        let s = new Pe();
        return this.m_raycaster.ray.intersectPlane(this.m_context.ViewManager.m_controls.m_plane, s), s;
      }
      SetSelected(...e) {
        this.m_selection.addObjects(...e), this.m_context.ViewManager.Render();
      }
      EnableSnap(e) {
        this.m_enableSnap = e;
      }
      MeasureDistance(e, t = 'm', i = 0, n = !0, s) {
        switch (
          (this.m_measurement.setUnit(t),
          this.m_measurement.setPrecision(i),
          s && this.m_measurement.setCallback(s),
          this.m_measurement.setAuxLabelVisible(n),
          e)
        ) {
          case !0:
            this.m_measurement.start(), this.EnableSnap(!0);
            break;
          case !1:
            this.m_measurement.stop(), this.EnableSnap(!1);
        }
      }
      ClearMeasure() {
        this.m_measurement.clearAllMeasure();
      }
    }
    !(function (e) {
      (e[(e.complete = 0)] = 'complete'), (e[(e.cancel = 1)] = 'cancel');
    })(nu || (nu = {}));
    class ru {
      constructor(e, t) {
        (this.m_visibility = !0),
          (this.m_root = t),
          (this.m_panelDom = document.createElement('div')),
          this.m_panelDom.classList.add('u3d-div'),
          (this.m_panelDom.style.position = 'absolute'),
          t.appendChild(this.m_panelDom),
          (this.m_view = e);
      }
      SetLocation(e, t) {
        let i = e.clone().project(this.m_view.Camera);
        var n = this.m_root.offsetWidth / 2,
          s = this.m_root.offsetHeight / 2,
          r = Math.round(i.x * n + n),
          a = Math.round(-i.y * s + s);
        (this.m_panelDom.style.left = `${r - 0.5 * this.m_panelDom.offsetWidth + this.m_root.offsetLeft}px`),
          (this.m_panelDom.style.top = `${a - 0.5 * this.m_panelDom.offsetHeight + this.m_root.offsetTop}px`);
        let o = new Pe(),
          l = new Pe(),
          h = new Pe();
        this.m_view.Camera.matrixWorldInverse.extractBasis(o, l, h), t.projectOnPlane(h.clone());
        let c = t.angleTo(o);
        o.applyAxisAngle(h, c).angleTo(t) < 1e-5 && (c = Math.PI - c),
          (c = (180 * c) / Math.PI),
          c > 90 && (c -= 180),
          (this.m_panelDom.style.transform = `rotate(${c}deg)`);
      }
      set Visibility(e) {
        this.m_visibility != e && ((this.m_panelDom.style.display = e ? 'block' : 'none'), (this.m_visibility = e));
      }
      get Visibility() {
        return this.m_visibility;
      }
      dispose() {
        this.m_panelDom && this.m_root.removeChild(this.m_panelDom);
      }
    }
    class au extends ru {
      constructor(e, t) {
        super(e, t),
          (this.m_dom = document.createElement('p')),
          (this.m_dom.style.width = '100%'),
          (this.m_dom.style.height = '100%'),
          (this.m_dom.style.fontSize = '10px'),
          (this.m_dom.style.textAlign = 'center'),
          (this.m_dom.style.border = '0px solid #101010'),
          (this.m_dom.style.background = 'rgba(220,38,38,0)'),
          (this.m_dom.style.color = '#fff'),
          this.m_panelDom.appendChild(this.m_dom),
          (this.m_panelDom.style.pointerEvents = 'none');
      }
      SetVaule(e, t, i) {
        let n = 6 * e.length + 4;
        n <= 40 && (n = 40),
          (this.m_panelDom.style.width = `${n}px`),
          (this.m_dom.innerHTML = e),
          t && i && this.SetLocation(t, i);
      }
    }
    class ou {
      constructor(e, t) {
        (this.m_root = t), (this.m_view = e);
      }
      dispose() {}
    }
    class lu extends ou {
      constructor(e, t) {
        super(e, t), (this.m_input = new au(e, e.m_context.Dom)), (this.m_input.Visibility = !1), (this.m_root = t);
      }
      SetVaule(e) {
        this.m_input.SetVaule(e), (this.m_input.Visibility = !0);
      }
      SetDimension(e, t, i, n) {
        let s = t.angleTo(i),
          r = Ac.angleTo(t, i, new Pe(0, 0, 1)),
          a = [0, 0, 0];
        new La(0, 0, 50 * n, 0, r != s ? 2 * Math.PI - s : s, r != s).getPoints(10 * r).forEach((e) => {
          a.push(e.x, e.y, 0);
        }),
          this.m_dimension ||
            ((this.m_dimension = new _a(new ai(), new Co({ color: 'green', dashSize: 2, gapSize: 2, scale: 1 }))),
            (this.m_dimension.frustumCulled = !1),
            this.m_root.add(this.m_dimension));
        let o = (180 * s) / Math.PI,
          l = [];
        for (let e = 0; e < a.length; e++) l.push(e), 0 != e && e != a.length - 1 && l.push(e);
        this.m_dimension.geometry.setAttribute('position', new Zt(new Float32Array(a), 3)),
          this.m_dimension.geometry.setIndex(l),
          this.m_dimension.position.copy(e);
        let h = r > Math.PI ? -s : s;
        h *= 0.5;
        let c = new Pe(50 * Math.cos(h) * n + e.x, 50 * Math.sin(h) * n + e.y, 0);
        this.m_input.SetVaule(`${Math.floor(o)}`, c, new Pe(1, 0, 0));
      }
      dispose() {
        this.m_dimension && (this.m_root.remove(this.m_dimension), this.m_dimension.geometry.dispose()),
          this.m_input && this.m_input.dispose();
      }
    }
    class hu extends ru {
      constructor(e, t) {
        super(e, t),
          (this.m_dom = document.createElement('input')),
          this.m_dom.setAttribute('type', 'text'),
          (this.m_dom.style.width = '100%'),
          (this.m_dom.style.height = '100%'),
          (this.m_dom.style.fontSize = '10px'),
          (this.m_dom.style.textAlign = 'center'),
          (this.m_dom.style.border = '1px solid #101010'),
          (this.m_dom.style.background = '#303030'),
          (this.m_dom.style.color = '#fff'),
          this.m_panelDom.appendChild(this.m_dom),
          (this.m_panelDom.style.pointerEvents = 'none');
      }
      SetVaule(e, t, i) {
        let n = 6 * e.length + 4;
        n <= 40 && (n = 40),
          (this.m_panelDom.style.width = `${n}px`),
          (this.m_dom.value = e),
          t && i && this.SetLocation(t, i);
      }
    }
    class cu extends ou {
      constructor(e, t) {
        super(e, t), (this.m_input = new hu(e, e.m_context.Dom)), (this.m_input.Visibility = !1), (this.m_root = t);
      }
      SetVaule(e) {
        this.m_input.SetVaule(e), (this.m_input.Visibility = !0);
      }
      SetDimension(e, t, i) {
        let n = e.clone().sub(t).normalize(),
          s = n.angleTo(new Pe(1, 0, 0));
        new Pe(1, 0, 0).applyAxisAngle(new Pe(0, 0, 1), s).angleTo(n) > 1e-5 && (s = Math.PI - (s % Math.PI)),
          s >= Math.PI && (s = 0);
        let r = new Pe(1, 0, 0).applyAxisAngle(new Pe(0, 0, 1), s + 0.5 * Math.PI),
          a = r.clone().multiplyScalar(30 * i),
          o = r.clone().multiplyScalar(15 * i),
          l = [e.clone().add(o), t.clone().add(o)];
        l.push(e, e.clone().add(a)),
          l.push(t, t.clone().add(a)),
          this.m_dimension ||
            ((this.m_dimension = new _a(new ai(), new la({ color: 'green' }))),
            (this.m_dimension.frustumCulled = !1),
            this.m_root.add(this.m_dimension)),
          this.m_dimension.geometry.setFromPoints(l);
        let h = e.clone().add(a).add(t).add(a).multiplyScalar(0.5);
        this.m_input.SetVaule(`${(1e3 * e.distanceTo(t)).toFixed(3)}`, h, n);
      }
      dispose() {
        this.m_dimension && (this.m_root.remove(this.m_dimension), this.m_dimension.geometry.dispose()),
          this.m_input && this.m_input.dispose();
      }
    }
    class uu extends ou {
      constructor(e, t) {
        super(e, t), (this.m_root = t);
      }
      SetPoint(e, t) {
        this.m_line && (this.m_line.visible = e.length > 0);
        let i = [];
        if (
          (e.forEach((e) => {
            i.push(-5 * t + e.x, e.y, 0, 5 * t + e.x, e.y, 0), i.push(e.x, 5 * t + e.y, 0, e.x, -5 * t + e.y, 0);
          }),
          this.m_line)
        )
          this.m_line.geometry.setAttribute('position', new Zt(new Float32Array(i), 3));
        else {
          let e = new ai();
          e.setAttribute('position', new Zt(new Float32Array(i), 3)),
            (this.m_line = new _a(e, new la({ color: 'green' }))),
            (this.m_line.frustumCulled = !1),
            this.m_root.add(this.m_line);
        }
      }
      dispose() {
        this.m_line && (this.m_root.remove(this.m_line), this.m_line.geometry.dispose());
      }
    }
    class du {
      constructor(e, t) {
        (this.Origin = e), (this.Direction = t);
      }
      distanceSqToRay(e, t) {
        let i = e.origin.clone().sub(this.Origin),
          n = this.Direction.clone().multiplyScalar(i.dot(this.Direction)),
          s = this.Origin.clone().add(n);
        return t && t.copy(s), e.distanceSqToPoint(s);
      }
      distanceSqPoint(e, t) {
        let i = e.clone().sub(this.Origin),
          n = this.Direction.clone().multiplyScalar(i.dot(this.Direction)),
          s = this.Origin.clone().add(n);
        return t && t.copy(s), s.distanceToSquared(e);
      }
    }
    class mu extends ou {
      constructor(e, t) {
        super(e, t);
      }
      set visible(e) {
        this.m_line && (this.m_line.visible = e);
      }
      Set(e, t, i, n) {
        var s;
        this.visible = !0;
        let r = [];
        if (n) r.push(e, n);
        else {
          let n = Math.sqrt(
            this.m_view.Canvas.offsetWidth * this.m_view.Canvas.offsetWidth +
              this.m_view.Canvas.offsetHeight * this.m_view.Canvas.offsetHeight,
          );
          r.push(e.clone().add(t.clone().multiplyScalar(n * i)), e.clone().sub(t.clone().multiplyScalar(n * i)));
        }
        if (this.m_line)
          this.m_line.geometry.setFromPoints(r),
            this.m_line.computeLineDistances(),
            ((null === (s = this.m_line) || void 0 === s ? void 0 : s.material).scale = 1 / i);
        else {
          let e = new ai();
          e.setFromPoints(r),
            (this.m_line = new pa(e, new Co({ color: 'green', dashSize: 1, gapSize: 2, scale: 1 / i }))),
            this.m_line.computeLineDistances(),
            (this.m_line.frustumCulled = !1),
            this.m_root.add(this.m_line);
        }
      }
      dispose() {
        this.m_line && (this.m_line.geometry.dispose(), this.m_root.remove(this.m_line));
      }
    }
    class pu {
      constructor(e, t, i = !1) {
        (this.points = []),
          (this.m_size = { x: 1, y: 1, z: 1 }),
          (this.inputVuale = ''),
          (this.m_auxPoints = []),
          (this.m_preMovePoint = { point: new Pe(), time: 0 }),
          (this.isSubsection = !1),
          (this.m_model = e.model),
          (this.m_layer = e.layer),
          (this.m_auxLayer = e.auxLayer),
          (this.m_material = new la({ color: e.layer.Color })),
          (this.m_locationObject = this.createLine(
            [-20, 0, 0, 20, 0, 0, 0, -20, 0, 0, 20, 0],
            void 0,
            new la({ color: 'green' }),
          )),
          (this.view = e.view);
        let n = e.view.ScreenModelScale;
        this.m_locationObject.scale.set(
          n * this.m_locationObject.userData.scale.x,
          n * this.m_locationObject.userData.scale.y,
          n * this.m_locationObject.userData.scale.z,
        ),
          this.m_auxLayer.add(this.m_locationObject),
          (this.m_dimension = new fu(e.view, this.m_auxLayer)),
          (this.canDrawCallBack = t),
          (this.isSubsection = i);
      }
      onMouseMove(e) {
        this.points.length > 0 &&
          (this.m_dimension.Line.SetDimension(this.originPoint, this.curPoint, this.scale),
          this.m_dimension.Arc.SetDimension(this.originPoint, new Pe(1, 0, 0), this.curDir, this.scale)),
          this.m_dimension.Anchor.SetPoint(this.auxPoint, this.scale);
      }
      onKeyDown(e) {
        var t;
        if (((this.m_auxPoints = []), 'Backspace' == e.key))
          this.inputVuale.length > 0 &&
            ((this.inputVuale = this.inputVuale.substring(0, this.inputVuale.length - 1)),
            this.m_dimension.Line.SetVaule(this.inputVuale));
        else if ((e.key >= '0' && e.key <= '9') || '.' == e.key) {
          if (null === (t = this.inputVuale) || void 0 === t ? void 0 : t.includes('.')) return;
          (this.inputVuale += e.key), this.m_dimension.Line.SetVaule(this.inputVuale);
        } else if ('Enter' == e.key && '' != this.inputVuale && this.points.length > 0) {
          let e = 0.001 * parseFloat(this.inputVuale),
            t = this.m_locationObject.position.clone(),
            i = this.points[this.points.length - 1].clone().sub(t).normalize();
          (t = this.points[this.points.length - 1].clone().add(i.multiplyScalar(-e))),
            this.points.push(t),
            this.OnMovePoint({ point: this.m_locationObject.position, geo: void 0, position: Kh.None }),
            this.view.Render();
        }
      }
      get originPoint() {
        return this.points[this.points.length - 1];
      }
      get curPoint() {
        return this.m_locationObject.position;
      }
      get curDir() {
        return this.curPoint.clone().sub(this.originPoint).normalize();
      }
      OnZoom(e) {
        this.m_auxPoints = [];
        let t = this.scale;
        this.points.length > 0 &&
          (this.m_dimension.Line.SetDimension(this.originPoint, this.curPoint, t),
          this.m_dimension.Arc.SetDimension(this.originPoint, new Pe(1, 0, 0), this.curDir, t)),
          this.m_dimension.Anchor.SetPoint(this.auxPoint, t),
          (this.m_dimension.OrthogonalAux.visible = !1),
          this.m_auxOrthogonalOrVertical &&
            this.m_dimension.OrthogonalAux.Set(
              this.m_auxOrthogonalOrVertical.origin,
              this.m_auxOrthogonalOrVertical.dir,
              t,
              this.m_auxOrthogonalOrVertical.position == Kh.AuxOrthogonal ? void 0 : this.curPoint,
            );
      }
      OnMovePointBefore(e) {
        let t = e.tol * e.tol;
        if (this.points.length > 0) {
          let i = new Pe(),
            n = new Pe(),
            s = new Pe(),
            r = new Pe();
          this.points[this.points.length - 1];
          if (this.points.length > 1) {
            for (let a = 0; a < this.points.length - 1; a++) {
              i.copy(this.points[a]), n.copy(this.points[a + 1]);
              let o = e.ray.distanceSqToSegment(i, n, s, r);
              if (o <= t) {
                let t = { x: Number(r.x.toFixed(3)), y: Number(r.y.toFixed(3)), z: Number(r.z.toFixed(3)) },
                  s = new Pe(0.5 * (i.x + n.x), 0.5 * (i.y + n.y), 0.5 * (i.z + n.z)),
                  a = i.distanceTo(r),
                  l = s.distanceTo(r),
                  h = n.distanceTo(r),
                  c = Kh.None,
                  u = Math.min(a, l, h),
                  d = r.clone();
                u <= e.tol &&
                  (u == a && ((c = Kh.Start), (d = i.clone())),
                  u == l && ((c = Kh.Center), (d = s)),
                  u == h && ((c = Kh.End), (d = n.clone())));
                let m = new Jh(t, o, '', []);
                (m.adjust = d), (m.position = c), (m.geo = new Pl(i.clone(), n.clone())), e.array.push(m);
              }
            }
            {
              let t = new Pe();
              this.view.Camera.getWorldDirection(t);
              let i = new Pl(this.points[this.points.length - 2].clone(), this.points[this.points.length - 1].clone()),
                n = new Pe(),
                s = (e.ray.intersectPlane(new Bi(t, 0), n), i.end.clone().sub(i.start).normalize()),
                r = n.clone().sub(i.end).normalize(),
                a = Ac.angleTo(s, r, t),
                o = (180 * a) / Math.PI,
                l = n.distanceTo(i.end),
                h = (((e.tol / l) * 180) / Math.PI) * 2,
                c = (o + h) % 90;
              if (c <= 2 * h) {
                a -= ((c - h) * Math.PI) / 180;
                let r = s.applyAxisAngle(t, a).multiplyScalar(n.distanceTo(i.end));
                r = i.end.clone().add(s);
                let o = new Jh(r, Math.sqrt(e.ray.distanceSqToPoint(r)), '', []);
                (o.adjust = r), (o.position = Kh.AuxOrthogonal), e.array.push(o);
              }
            }
          }
          {
            let t = new Pe();
            this.view.Camera.getWorldDirection(t);
            let i = this.points[this.points.length - 1].clone(),
              n = new Pe();
            e.ray.intersectPlane(new Bi(t, 0), n);
            let s = new Pe(1, 0, 0),
              r = n.clone().sub(i).normalize(),
              a = Ac.angleTo(s, r, t),
              o = (180 * a) / Math.PI,
              l = n.distanceTo(i),
              h = (((e.tol / l) * 180) / Math.PI) * 2,
              c = (o + h) % 90;
            if (c <= 2 * h) {
              a -= ((c - h) * Math.PI) / 180;
              let r = s.applyAxisAngle(t, a).multiplyScalar(n.distanceTo(i));
              r = i.clone().add(s);
              let o = new Jh(r, Math.sqrt(e.ray.distanceSqToPoint(r)), '', []);
              (o.adjust = r), (o.position = Kh.AuxOrthogonal), e.array.push(o);
            }
          }
        }
        let i = new at();
        if (this.m_auxPoints.length > 0) {
          let i = new Pe(0, 0, 1),
            n = new Bi(i, 0),
            s = new Pe();
          e.ray.intersectPlane(n, s);
          let r = (i, n) => {
            let r = new Pe(),
              a = i.distanceSqPoint(s, r);
            if (a <= t) {
              let t = new Jh(r, Math.sqrt(a), '', []);
              (t.adjust = r), (t.position = n), (t.geo = i), e.array.push(t);
            }
          };
          this.m_auxPoints.forEach((e) => {
            e.orgin &&
              e.dir &&
              (e.dir.distanceTo(new Pe(1, 0, 0)) <= 1e-7 ||
              e.dir.distanceTo(new Pe(-1, 0, 0)) <= 1e-7 ||
              e.dir.distanceTo(new Pe(0, 1, 0)) <= 1e-7 ||
              e.dir.distanceTo(new Pe(0, -1, 0)) <= 1e-7
                ? (r(new du(e.orgin, e.dir), Kh.AuxVertical),
                  r(new du(e.orgin, e.dir.clone().applyAxisAngle(i, 0.5 * Math.PI)), Kh.AuxVertical))
                : (r(new du(e.orgin, e.dir), Kh.AuxVertical),
                  r(new du(e.orgin, e.dir.clone().applyAxisAngle(i, 0.5 * Math.PI)), Kh.AuxVertical),
                  r(new du(e.orgin, new Pe(1, 0, 0)), Kh.AuxOrthogonal),
                  r(new du(e.orgin, new Pe(0, 1, 0)), Kh.AuxOrthogonal)));
          });
        }
        e.array.forEach((t) => {
          var n;
          if (('none' == t.position && (t.position = Kh.Insert), t.geo && t.geo instanceof Pl)) {
            let s = t.geo,
              r = null !== (n = t.adjust) && void 0 !== n ? n : t.location,
              a = s.start.clone().sub(s.end.clone()).clone().normalize();
            if (this.points.length > 0) {
              let i = this.points[this.points.length - 1],
                n = new Pe(r.x - i.x, r.y - i.y, r.z - i.z),
                s = a.multiplyScalar(n.dot(a));
              s.lengthSq() <= e.tol * e.tol &&
                ((t.position = Kh.Vertical), (t.adjust = new Pe(r.x - s.x, r.y - s.y, r.z - s.z)));
            }
            i.set(s.start, s.end.clone().sub(s.start).normalize()),
              e.array.forEach((e) => {
                if (e.geo instanceof Pl) {
                  let n = e.geo;
                  if (s != n) {
                    let e = new Pe(),
                      r = new Pe();
                    i.distanceSqToSegment(n.start.clone(), n.end.clone(), e) < 1e-7 &&
                      (s.closestPointToPoint(e, !0, r),
                      e.distanceTo(r) < 1e-8 &&
                        ((t.position = Kh.Cross),
                        (t.adjust = e),
                        (t.distance = e.distanceTo(new Pe(t.location.x, t.location.y, t.location.z)))));
                  }
                }
              });
          }
        });
      }
      OnMovePoint(e) {
        if (
          ((this.inputVuale = ''),
          this.m_locationObject.position.copy(e.point),
          (this.m_locationObject.visible = !0),
          e.point.distanceTo(this.m_preMovePoint.point) < this.scale)
        ) {
          if (
            (e.position == Kh.End || e.position == Kh.Start || e.position == Kh.Center || e.position == Kh.Cross) &&
            new Date().getTime() - this.m_preMovePoint.time > 300
          ) {
            let t = e.geo && e.geo instanceof Pl ? e.geo.end.clone().sub(e.geo.start).normalize() : void 0;
            this.m_auxPoints.push({ orgin: e.point, dir: t });
          }
        } else (this.m_preMovePoint.time = new Date().getTime()), this.m_preMovePoint.point.copy(e.point);
        if (((this.m_dimension.OrthogonalAux.visible = !1), e.position == Kh.AuxOrthogonal)) {
          let t =
            e.geo instanceof du
              ? { origin: e.geo.Origin, dir: e.geo.Direction }
              : e.geo instanceof Pl
              ? { origin: e.point, dir: e.geo.end.clone().sub(e.geo.start).normalize() }
              : void 0;
          t &&
            (this.m_dimension.OrthogonalAux.Set(t.origin, t.dir, this.scale),
            (this.m_auxOrthogonalOrVertical = { position: e.position, origin: t.origin, dir: t.dir }));
        }
        if (e.position == Kh.AuxVertical) {
          let t =
            e.geo instanceof du
              ? { origin: e.geo.Origin, dir: e.geo.Direction }
              : e.geo instanceof Pl
              ? { origin: e.point, dir: e.geo.end.clone().sub(e.geo.start).normalize() }
              : void 0;
          t &&
            (this.m_dimension.OrthogonalAux.Set(t.origin, t.dir, this.scale, e.point),
            (this.m_auxOrthogonalOrVertical = { position: e.position, origin: t.origin, dir: t.dir }));
        }
        if (0 == this.points.length) return;
        let t = [];
        t.push(...this.points),
          t.push(e.point),
          this.m_geometry
            ? this.m_geometry.setFromPoints(t)
            : ((this.m_geometry = new ai()),
              this.m_geometry.setFromPoints(t),
              (this.m_tempObject = new pa(this.m_geometry, this.m_material)),
              (this.m_tempObject.frustumCulled = !1),
              this.m_auxLayer.add(this.m_tempObject)),
          this.m_dimension.Arc.SetDimension(
            this.points[this.points.length - 1],
            new Pe(1, 0, 0),
            e.point
              .clone()
              .sub(this.points[this.points.length - 1])
              .normalize(),
            this.scale,
          ),
          this.m_dimension.Line.SetDimension(this.points[this.points.length - 1], e.point, this.scale);
      }
      OnDownPoint(e) {
        this.canDrawCallBack(e) &&
          (this.points.length <= 1 && ((this.m_auxPoints = []), this.points.push(e.point)),
          this.points.length > 1 &&
            this.points[this.points.length - 1].x == e.point.x &&
            this.points[this.points.length - 1].y == e.point.y &&
            this.points[this.points.length - 1].z == e.point.z &&
            ((this.points.length = this.points.length - 1), (this.m_auxPoints = []), this.points.push(e.point)),
          this.points.length > 1 &&
            ((this.points[this.points.length - 1].x == e.point.x &&
              this.points[this.points.length - 1].y == e.point.y &&
              this.points[this.points.length - 1].z == e.point.z) ||
              ((this.m_auxPoints = []), this.points.push(e.point))));
      }
      GetPoints() {
        return this.points;
      }
      get auxPoint() {
        let e = [];
        return (
          this.m_auxPoints.forEach((t) => {
            e.push(t.orgin);
          }),
          e
        );
      }
      Finish(e) {
        var t, i;
        if (
          (this.m_tempObject && this.m_auxLayer.remove(this.m_tempObject),
          this.m_geometry && this.m_geometry.dispose(),
          this.m_locationObject &&
            (this.m_auxLayer.remove(this.m_locationObject), this.m_locationObject.geometry.dispose()),
          this.m_dimension && this.m_dimension.dispose(),
          e == nu.complete)
        ) {
          if (this.points.length > 1) {
            let e = `${this.m_layer.Id}_${this.m_layer.Color}`,
              n =
                null !== (i = null === (t = this.m_model.Lines[e]) || void 0 === t ? void 0 : t.lines) && void 0 !== i
                  ? i
                  : [],
              s = [],
              r = 0,
              a = [],
              o = [];
            if (
              (this.points.forEach((e) => {
                s.push(e.x, e.y, e.z), a.push(r), 0 != r && r != this.points.length - 1 && a.push(r), r++;
              }),
              this.isSubsection)
            ) {
              for (let e = 0; e < s.length; e++)
                if (e % 3 == 0 && e + 3 < s.length) {
                  let t = new gc({
                      id: yc(),
                      layerId: this.m_layer.Id,
                      blockId: '',
                      points: new Float32Array([s[e], s[e + 1], s[e + 2], s[e + 3], s[e + 4], s[e + 5]]),
                      indexes: new Int32Array([0, 1]),
                    }),
                    i = new $e(),
                    r = new Re();
                  r.setFromArray(t.points), r.getBoundingSphere(i), (t.sphere = i), (t.box = r), n.push(t), o.push(t);
                }
            } else {
              let e = new gc({
                  id: yc(),
                  layerId: this.m_layer.Id,
                  blockId: '',
                  points: new Float32Array(s),
                  indexes: new Int32Array(a),
                }),
                t = new $e(),
                i = new Re();
              i.setFromArray(e.points), i.getBoundingSphere(t), (e.sphere = t), (e.box = i), n.push(e), o.push(e);
            }
            return (
              this.m_layer.Color &&
                (this.m_model.Lines[e]
                  ? ((this.m_model.Lines[e].canEdit = !0),
                    (this.m_model.Lines[e].lines = n),
                    (this.m_model.Lines[e].model = this.m_model.addLinesToModel(
                      this.m_layer.Id,
                      this.m_layer.Color,
                      n,
                    )))
                  : (this.m_model.Lines[e] = {
                      canEdit: !0,
                      lines: n,
                      model: this.m_model.addLinesToModel(this.m_layer.Id, this.m_layer.Color, n),
                    })),
              this.isSubsection ? o : o[0]
            );
          }
        } else if (e == nu.cancel) return;
      }
      createLine(e, t, i) {
        let n = new ai();
        n.setAttribute('position', new Zt(new Float32Array(e), 3)), t && n.setIndex(t);
        let s = new _a(n, i);
        return (s.renderOrder = 20), (s.userData.scale = this.m_size), s;
      }
      get scale() {
        return this.view.ScreenModelScale;
      }
    }
    class fu {
      constructor(e, t) {
        (this.m_arcDimension = new lu(e, t)),
          (this.m_dimension = new cu(e, t)),
          (this.m_anchor = new uu(e, t)),
          (this.m_orthogonalAux = new mu(e, t));
      }
      get Line() {
        return this.m_dimension;
      }
      get Arc() {
        return this.m_arcDimension;
      }
      get Anchor() {
        return this.m_anchor;
      }
      get OrthogonalAux() {
        return this.m_orthogonalAux;
      }
      dispose() {
        this.Line && this.Arc.dispose(),
          this.Line && this.Line.dispose(),
          this.m_anchor && this.m_anchor.dispose(),
          this.m_orthogonalAux && this.m_orthogonalAux.dispose();
      }
    }
    class gu extends i {
      constructor(e) {
        super(e),
          (this.m_positions = []),
          (this.isClose = !1),
          (this.m_modelLayer = this.m_context.SceneManager.ModelLayer),
          (this.m_model = this.m_context.ModelManager),
          (this.m_auxModel = this.m_context.SceneManager.AuxModel),
          (this.m_signModel = this.m_context.SceneManager.SignModel),
          (this.m_eventManager = new jh()),
          (this.m_selectionManager = this.m_context.SelectionManager),
          (this.m_view = e.ViewManager);
      }
      initEvent() {
        (this.onMouseMoveBind = this.onMouseMove.bind(this)),
          this.m_context.ViewManager.EventManager.addEventListener('pointermove', this.onMouseMoveBind),
          (this.onMouseUpBind = this.onMouseUp.bind(this)),
          this.m_context.ViewManager.EventManager.addEventListener('pointerup', this.onMouseUpBind),
          (this.onMouseDownBind = this.onMouseDown.bind(this)),
          this.m_context.ViewManager.EventManager.addEventListener('pointerdown', this.onMouseDownBind),
          (this.onKeyDownBind = this.onKeyDown.bind(this)),
          window.addEventListener('keydown', this.onKeyDownBind),
          (this.onSnapFilterBind = this.onSnapFilter.bind(this)),
          this.m_selectionManager.EventManager.addEventListener(iu.snapFilter, this.onSnapFilterBind),
          (this.onInsertCallbackBind = this.onInsertCallback.bind(this)),
          this.m_selectionManager.EventManager.addEventListener(iu.inserts, this.onInsertCallbackBind),
          (this.onZoomBind = this.OnZoom.bind(this)),
          this.m_context.ViewManager.Controls.addEventListener('zoom', this.onZoomBind);
      }
      unInitEvent() {
        this.onMouseMoveBind &&
          this.m_context.ViewManager.EventManager.removeEventListener('pointermove', this.onMouseMoveBind),
          this.onMouseUpBind &&
            this.m_context.ViewManager.EventManager.removeEventListener('pointerup', this.onMouseUpBind),
          this.onMouseDownBind &&
            this.m_context.ViewManager.EventManager.removeEventListener('pointerdown', this.onMouseDownBind),
          this.onKeyDownBind && window.removeEventListener('keydown', this.onKeyDownBind),
          this.onSnapFilterBind &&
            this.m_selectionManager.EventManager.removeEventListener(iu.snapFilter, this.onSnapFilterBind),
          this.onInsertCallbackBind &&
            this.m_selectionManager.EventManager.removeEventListener(iu.inserts, this.onInsertCallbackBind),
          this.onZoomBind && this.m_context.ViewManager.Controls.removeEventListener('zoom', this.onZoomBind);
      }
      DrawInit() {
        this.m_selectionManager.EnableSnap(!0),
          (this.m_selectionManager.HighLighting = !1),
          (this.m_context.ViewManager.Controls.MouseLeftPan = !1),
          this.initEvent();
      }
      DrawEnd() {
        this.m_selectionManager.EnableSnap(!1),
          (this.m_selectionManager.HighLighting = !0),
          (this.m_context.ViewManager.Controls.MouseLeftPan = !0),
          this.unInitEvent(),
          this.m_view.Render();
      }
      OnZoom(e) {
        var t;
        null === (t = this.drawObject) || void 0 === t || t.OnZoom(e);
      }
      onKeyDown(e) {
        var t, i;
        null === (t = this.drawObject) || void 0 === t || t.onKeyDown(e),
          'Escape' == e.key && this.drawObject instanceof pu && this.DrawLineFinish(nu.complete),
          e.ctrlKey &&
            'z' == e.key &&
            (this.drawObject.GetPoints().pop(),
            null === (i = this.drawObject) || void 0 === i || i.OnMovePoint(this.curpositon),
            this.m_view.Render());
      }
      onMouseMove(e) {
        var t;
        null === (t = this.drawObject) || void 0 === t || t.onMouseMove(e);
      }
      onMouseUp(e) {}
      onMouseDown(e) {
        var t;
        this.curpositon &&
          0 == e.button &&
          (null === (t = this.drawObject) ||
            void 0 === t ||
            t.OnDownPoint({
              point: this.curpositon.point,
              geo: this.curpositon.geo,
              position: this.curpositon.position,
            }));
      }
      onInsertCallback(e) {
        var t, i;
        let n = null !== (t = e.adjust) && void 0 !== t ? t : e.location;
        (this.curpositon = { point: new Pe(n.x, n.y, n.z), geo: e.geo, position: e.position }),
          null === (i = this.drawObject) || void 0 === i || i.OnMovePoint(this.curpositon);
      }
      onSnapFilter(e) {
        var t;
        null === (t = this.drawObject) || void 0 === t || t.OnMovePointBefore(e);
      }
      DrawLine(e, t, i, n = !1, s = !1) {
        (this.m_completeCallback = t), (this.isClose = n);
        let r = this.m_model.GetLayerByName(e);
        return (
          r ||
            ((r = new vu(e, yc())),
            (r.Color = 16777215),
            (r.ColorIndex = 1),
            (r.Objects = []),
            this.m_model.addLayer(r)),
          this.DrawInit(),
          (this.drawObject = new pu(
            { layer: r, model: this.m_model, auxLayer: this.m_auxModel, view: this.m_context.ViewManager },
            i,
            s,
          )),
          this.drawObject
        );
      }
      DrawLineFinish(e) {
        var t;
        let i;
        switch (e) {
          case nu.cancel:
            this.drawObject = void 0;
            break;
          case nu.complete:
            if (((i = this.drawObject), i)) {
              let e = i.points;
              this.isClose && e && (e[e.length] = e[0]);
            }
            let n = null === (t = this.drawObject) || void 0 === t ? void 0 : t.Finish(e);
            n && this.m_completeCallback && this.m_completeCallback(n), (this.drawObject = void 0);
        }
        return this.DrawEnd(), (this.m_completeCallback = void 0), i;
      }
      get Positions() {
        var e;
        return null === (e = this.drawObject) || void 0 === e ? void 0 : e.GetPoints();
      }
    }
    class _u {
      constructor(e) {
        (this.m_dom = e.div),
          (this.m_sceneManager = new dc(this)),
          (this.m_viewManager = new hc(this)),
          (this.m_loadManager = new Xh(this)),
          (this.m_modelManager = new Mc(this)),
          (this.m_materialManager = new bc(this)),
          (this.m_selectionManager = new su(this)),
          (this.m_drawManager = new gu(this));
      }
      get Dom() {
        return this.m_dom;
      }
      get LoadManager() {
        return this.m_loadManager;
      }
      get SceneManager() {
        return this.m_sceneManager;
      }
      get ViewManager() {
        return this.m_viewManager;
      }
      get ModelManager() {
        return this.m_modelManager;
      }
      get MaterialManager() {
        return this.m_materialManager;
      }
      get SelectionManager() {
        return this.m_selectionManager;
      }
      get DrawManager() {
        return this.m_drawManager;
      }
    }
    class vu {
      constructor(e, t) {
        (this.Enabled = !0), (this.Visible = !0), (this.Objects = []), (this.Name = e), (this.Id = t);
      }
    }
    let xu;
    class yu {
      get LoadManager() {
        return xu.LoadManager;
      }
      constructor(e) {
        xu = new _u({ div: e });
      }
      LoadModel(e) {
        this.LoadManager.LoadModel(e);
      }
      get SceneManager() {
        return xu.SceneManager;
      }
      get ViewManager() {
        return xu.ViewManager;
      }
      get SelectionManager() {
        return xu.SelectionManager;
      }
      get ModelManager() {
        return xu.ModelManager;
      }
      get DrawManager() {
        return xu.DrawManager;
      }
    }
    class Mu {
      get LoadManager() {
        return xu.LoadManager;
      }
      constructor(e) {
        xu = new _u({ div: e });
      }
      get SceneManager() {
        return xu.SceneManager;
      }
      get ViewManager() {
        return xu.ViewManager;
      }
      get SelectionManager() {
        return xu.SelectionManager;
      }
      get ModelManager() {
        return xu.ModelManager;
      }
    }
  })(),
    (CadEngine = t);
})();
//# sourceMappingURL=CadEngine.js.map
